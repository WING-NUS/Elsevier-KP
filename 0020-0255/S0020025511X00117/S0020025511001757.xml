<doc:document xmlns:doc="http://www.elsevier.com/xml/document/schema"><rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="http://dx.doi.org/10.1016/j.ins.2011.04.007"><dc:format xmlns:dc="http://purl.org/dc/elements/1.1/">application/xml</dc:format><dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Tabu search based multi-watermarks embedding algorithm with multiple description coding</dc:title><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/"><rdf:Seq><rdf:li>Hsiang-Cheh Huang</rdf:li><rdf:li>Shu-Chuan Chu</rdf:li><rdf:li>Jeng-Shyang Pan</rdf:li><rdf:li>Chun-Yen Huang</rdf:li><rdf:li>Bin-Yih Liao</rdf:li></rdf:Seq></dc:creator><dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/"><rdf:Bag><rdf:li>Watermarking</rdf:li><rdf:li>Error resilience</rdf:li><rdf:li>Multiple description coding</rdf:li><rdf:li>Vector quantization</rdf:li><rdf:li>Optimization</rdf:li><rdf:li>Tabu search</rdf:li></rdf:Bag></dc:subject><dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">Information Sciences 181 (2011) 3379-3396. doi:10.1016/j.ins.2011.04.007</dc:description><prism:aggregationType xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">journal</prism:aggregationType><prism:publicationName xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Information Sciences</prism:publicationName><prism:copyright xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Copyright © 2011 Elsevier Inc. All rights reserved.</prism:copyright><dc:publisher xmlns:dc="http://purl.org/dc/elements/1.1/">Elsevier Inc.</dc:publisher><prism:issn xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">0020-0255</prism:issn><prism:volume xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">181</prism:volume><prism:number xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">16</prism:number><prism:coverDisplayDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">2011</prism:coverDisplayDate><prism:coverDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">2011</prism:coverDate><prism:pageRange xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3379-3396</prism:pageRange><prism:startingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3379</prism:startingPage><prism:endingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3396</prism:endingPage><prism:doi xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">10.1016/j.ins.2011.04.007</prism:doi><prism:url xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">http://dx.doi.org/10.1016/j.ins.2011.04.007</prism:url><dc:identifier xmlns:dc="http://purl.org/dc/elements/1.1/">doi:10.1016/j.ins.2011.04.007</dc:identifier></rdf:Description></rdf:RDF><dp:document-properties xmlns:dp="http://www.elsevier.com/xml/common/doc-properties/schema"><dp:aggregation-type>Journals</dp:aggregation-type><dp:version-number>S300.1</dp:version-number></dp:document-properties><ja:article docsubtype="fla" xml:lang="en" version="5.1" xmlns:ja="http://www.elsevier.com/xml/ja/schema">
		<ja:item-info>
			<ja:jid>INS</ja:jid>
			<ja:aid>9058</ja:aid>
			<ce:pii xmlns:ce="http://www.elsevier.com/xml/common/schema">S0020-0255(11)00175-7</ce:pii>
			<ce:doi xmlns:ce="http://www.elsevier.com/xml/common/schema">10.1016/j.ins.2011.04.007</ce:doi>
			<ce:copyright type="full-transfer" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema">Elsevier Inc.</ce:copyright>
		</ja:item-info>
		<ce:floats xmlns:ce="http://www.elsevier.com/xml/common/schema">
			<ce:figure id="f0005">
				<ce:label>Fig. 1</ce:label>
				<ce:caption>
					<ce:simple-para id="sp010" view="all">A block diagram for vector quantization. All the 
						<ce:italic>L</ce:italic> codewords form a codebook of size 
						<ce:italic>L</ce:italic>, that is, 
						<ce:bold>
							<ce:italic>C</ce:italic>
						</ce:bold>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>{
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">0</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>…
						<ce:hsp sp="0.12"/>,
						<ce:hsp sp="0.12"/>
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>−1
						</ce:inf>}. 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf> means the vector, or a small block in the original image 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>, and 
						<mml:math altimg="si1.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msubsup>
									<mml:mrow>
										<mml:mi mathvariant="bold-italic">X</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>k</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mo>′</mml:mo>
									</mml:mrow>
								</mml:msubsup>
							</mml:mrow>
						</mml:math> is the reconstructed vector.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr1"/>
			</ce:figure>
			<ce:figure id="f0010">
				<ce:label>Fig. 2</ce:label>
				<ce:caption>
					<ce:simple-para id="sp015" view="all">The generic model for MD source coding with two channels and three receivers. The general case has 
						<ce:italic>P</ce:italic> channels and (2
						<ce:sup loc="post">
							<ce:italic>P</ce:italic>
						</ce:sup>
						<ce:hsp sp="0.25"/>−
						<ce:hsp sp="0.25"/>1) receivers.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr2"/>
			</ce:figure>
			<ce:figure id="f0015">
				<ce:label>Fig. 3</ce:label>
				<ce:caption>
					<ce:simple-para id="sp020" view="all">The structure for MDSQ for two descriptions over two independent channels with mutually independent breakdown probabilities.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr3"/>
			</ce:figure>
			<ce:figure id="f0020">
				<ce:label>Fig. 4</ce:label>
				<ce:caption>
					<ce:simple-para id="sp025" view="all">The illustrations of the nested index assignment in MDSQ for two channels with codebook size 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>8. (a) With spread 
						<ce:italic>m</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0. (b) With spread 
						<ce:italic>m</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr4"/>
			</ce:figure>
			<ce:figure id="f0025">
				<ce:label>Fig. 5</ce:label>
				<ce:caption>
					<ce:simple-para id="sp030" view="all">The structure for MDVQ for two descriptions over two independent channels with mutually independent breakdown probabilities.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr5"/>
			</ce:figure>
			<ce:figure id="f0030">
				<ce:label>Fig. 6</ce:label>
				<ce:caption>
					<ce:simple-para id="sp035" view="all">The structure for embedding two watermarks with two descriptions for transmission in MDC. The two independent channels have mutually independent breakdown probabilities.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr6"/>
			</ce:figure>
			<ce:figure id="f0035">
				<ce:label>Fig. 7</ce:label>
				<ce:caption>
					<ce:simple-para id="sp040" view="all">An example of the combination of MDC and watermarking, an extension to 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(b) with spread 
						<ce:italic>m</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr7"/>
			</ce:figure>
			<ce:figure id="f0040">
				<ce:label>Fig. 8</ce:label>
				<ce:caption>
					<ce:simple-para id="sp045" view="all">The two watermarks used for embedding in our simulation. Both have sizes 128
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>128. Watermark 1 shows a flower, while watermark 2 denotes the characters KUAS, representing the author’s affiliation.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr8"/>
			</ce:figure>
			<ce:figure id="f0045">
				<ce:label>Fig. 9</ce:label>
				<ce:caption>
					<ce:simple-para id="sp050" view="all">The two extracted watermarks under different channel erasure probabilities, with a codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>512.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr9"/>
			</ce:figure>
			<ce:figure id="f0050">
				<ce:label>Fig. 10</ce:label>
				<ce:caption>
					<ce:simple-para id="sp055" view="all">The two extracted watermarks for the case when one channel suffers a total breakdown, with a codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>512.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr10"/>
			</ce:figure>
			<ce:figure id="f0055">
				<ce:label>Fig. 11</ce:label>
				<ce:caption>
					<ce:simple-para id="sp060" view="all">The two extracted watermarks under different channel erasure probabilities, for a codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1024.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr11"/>
			</ce:figure>
			<ce:figure id="f0060">
				<ce:label>Fig. 12</ce:label>
				<ce:caption>
					<ce:simple-para id="sp065" view="all">The two extracted watermarks for the case when one channel suffers a total breakdown, for a codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1024.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr12"/>
			</ce:figure>
			<ce:table frame="topbot" id="t0005" rowsep="0" colsep="0">
				<ce:label>Table 1</ce:label>
				<ce:caption>
					<ce:simple-para id="sp070" view="all">Comparisons of watermarked image quality under different channel erasure probabilities for the codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>512 after considering watermark embedding.
					</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="5" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="left"/>
					<cals:colspec colname="col3" align="char" char="."/>
					<cals:colspec colname="col4" align="char" char="."/>
					<cals:colspec colname="col5" align="char" char="."/>
					<cals:thead>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col2">Channel erasure prob.</ce:entry>
							<ce:entry morerows="1" rowsep="1">PSNR with our method (in dB)</ce:entry>
							<ce:entry morerows="1" rowsep="1">PSNR with 
								<ce:cross-ref refid="b0135">[27]</ce:cross-ref> (in dB)
							</ce:entry>
							<ce:entry morerows="1" rowsep="1">PSNR with 
								<ce:cross-ref refid="b0180">[36]</ce:cross-ref> (in dB)
							</ce:entry>
						</cals:row>
						<cals:row rowsep="1" valign="top">
							<ce:entry>
								<ce:italic>p</ce:italic>
								<ce:inf loc="post">1</ce:inf>
							</ce:entry>
							<ce:entry>
								<ce:italic>p</ce:italic>
								<ce:inf loc="post">2</ce:inf>
							</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>0</ce:entry>
							<ce:entry>0</ce:entry>
							<ce:entry align="char" char=".">30.74</ce:entry>
							<ce:entry align="char" char=".">30.46</ce:entry>
							<ce:entry align="char" char=".">30.64</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.1</ce:entry>
							<ce:entry>0.1</ce:entry>
							<ce:entry align="char" char=".">28.15</ce:entry>
							<ce:entry align="char" char=".">28.14</ce:entry>
							<ce:entry align="char" char=".">28.56</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.25</ce:entry>
							<ce:entry>0.25</ce:entry>
							<ce:entry align="char" char=".">24.39</ce:entry>
							<ce:entry align="char" char=".">24.37</ce:entry>
							<ce:entry align="char" char=".">24.40</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.5</ce:entry>
							<ce:entry>0.5</ce:entry>
							<ce:entry align="char" char=".">19.88</ce:entry>
							<ce:entry align="char" char=".">19.93</ce:entry>
							<ce:entry align="char" char=".">19.86</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0</ce:entry>
							<ce:entry>1</ce:entry>
							<ce:entry align="char" char=".">26.19</ce:entry>
							<ce:entry align="char" char=".">25.92</ce:entry>
							<ce:entry align="char" char=".">25.41</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>1</ce:entry>
							<ce:entry>0</ce:entry>
							<ce:entry align="char" char=".">26.13</ce:entry>
							<ce:entry align="char" char=".">26.04</ce:entry>
							<ce:entry align="char" char=".">25.48</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0010" rowsep="0" colsep="0">
				<ce:label>Table 2</ce:label>
				<ce:caption>
					<ce:simple-para id="sp075" view="all">Comparisons of watermark robustness under different channel erasure probabilities for the codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>512 after considering watermark embedding.
					</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="6" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="left"/>
					<cals:colspec colname="col3" align="left"/>
					<cals:colspec colname="col4" align="left"/>
					<cals:colspec colname="col5" align="left"/>
					<cals:colspec colname="col6" align="left"/>
					<cals:thead>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col2" rowsep="1">Channel erasure probability</ce:entry>
							<ce:entry namest="col3" nameend="col4" rowsep="1">BCR with our method (in %)</ce:entry>
							<ce:entry>BCR with 
								<ce:cross-ref refid="b0135">[27]</ce:cross-ref> (in %)
							</ce:entry>
							<ce:entry>BCR with 
								<ce:cross-ref refid="b0180">[36]</ce:cross-ref> (in %)
							</ce:entry>
						</cals:row>
						<cals:row rowsep="1" valign="top">
							<ce:entry>
								<ce:italic>p</ce:italic>
								<ce:inf loc="post">1</ce:inf>
							</ce:entry>
							<ce:entry>
								<ce:italic>p</ce:italic>
								<ce:inf loc="post">2</ce:inf>
							</ce:entry>
							<ce:entry>
								<mml:math altimg="si2.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>
							</ce:entry>
							<ce:entry>
								<mml:math altimg="si3.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>
							</ce:entry>
							<ce:entry>
								<mml:math altimg="si4.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>
							</ce:entry>
							<ce:entry>
								<mml:math altimg="si5.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>
							</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>0</ce:entry>
							<ce:entry>0</ce:entry>
							<ce:entry>100</ce:entry>
							<ce:entry>100</ce:entry>
							<ce:entry>100</ce:entry>
							<ce:entry>100</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.1</ce:entry>
							<ce:entry>0.1</ce:entry>
							<ce:entry>94.12</ce:entry>
							<ce:entry>93.60</ce:entry>
							<ce:entry>90.48</ce:entry>
							<ce:entry>94.90</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.25</ce:entry>
							<ce:entry>0.25</ce:entry>
							<ce:entry>87.50</ce:entry>
							<ce:entry>85.64</ce:entry>
							<ce:entry>78.47</ce:entry>
							<ce:entry>87.19</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.5</ce:entry>
							<ce:entry>0.5</ce:entry>
							<ce:entry>74.30</ce:entry>
							<ce:entry>72.08</ce:entry>
							<ce:entry>62.88</ce:entry>
							<ce:entry>74.69</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0</ce:entry>
							<ce:entry>1</ce:entry>
							<ce:entry>81.03</ce:entry>
							<ce:entry>68.23</ce:entry>
							<ce:entry>75.72</ce:entry>
							<ce:entry>79.72</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>1</ce:entry>
							<ce:entry>0</ce:entry>
							<ce:entry>67.00</ce:entry>
							<ce:entry>69.71</ce:entry>
							<ce:entry>66.38</ce:entry>
							<ce:entry>66.52</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0015" rowsep="0" colsep="0">
				<ce:label>Table 3</ce:label>
				<ce:caption>
					<ce:simple-para id="sp080" view="all">Comparisons of watermarked image quality under different channel erasure probabilities for the codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1024 after considering watermark embedding.
					</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="5" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="left"/>
					<cals:colspec colname="col3" align="char" char="."/>
					<cals:colspec colname="col4" align="char" char="."/>
					<cals:colspec colname="col5" align="char" char="."/>
					<cals:thead>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col2" rowsep="1">Channel erasure prob.</ce:entry>
							<ce:entry morerows="1" rowsep="1">PSNR with our method (in dB)</ce:entry>
							<ce:entry morerows="1" rowsep="1">PSNR with 
								<ce:cross-ref refid="b0135">[27]</ce:cross-ref> (in dB)
							</ce:entry>
							<ce:entry morerows="1" rowsep="1">PSNR with 
								<ce:cross-ref refid="b0180">[36]</ce:cross-ref> (in dB)
							</ce:entry>
						</cals:row>
						<cals:row rowsep="1" valign="top">
							<ce:entry>
								<ce:italic>p</ce:italic>
								<ce:inf loc="post">1</ce:inf>
							</ce:entry>
							<ce:entry>
								<ce:italic>p</ce:italic>
								<ce:inf loc="post">2</ce:inf>
							</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>0</ce:entry>
							<ce:entry>0</ce:entry>
							<ce:entry align="char" char=".">32.74</ce:entry>
							<ce:entry align="char" char=".">31.84</ce:entry>
							<ce:entry align="char" char=".">32.20</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.1</ce:entry>
							<ce:entry>0.1</ce:entry>
							<ce:entry align="char" char=".">28.35</ce:entry>
							<ce:entry align="char" char=".">28.47</ce:entry>
							<ce:entry align="char" char=".">28.88</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.25</ce:entry>
							<ce:entry>0.25</ce:entry>
							<ce:entry align="char" char=".">24.27</ce:entry>
							<ce:entry align="char" char=".">24.33</ce:entry>
							<ce:entry align="char" char=".">24.34</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.5</ce:entry>
							<ce:entry>0.5</ce:entry>
							<ce:entry align="char" char=".">19.78</ce:entry>
							<ce:entry align="char" char=".">19.77</ce:entry>
							<ce:entry align="char" char=".">19.79</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0</ce:entry>
							<ce:entry>1</ce:entry>
							<ce:entry align="char" char=".">25.10</ce:entry>
							<ce:entry align="char" char=".">24.88</ce:entry>
							<ce:entry align="char" char=".">25.17</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>1</ce:entry>
							<ce:entry>0</ce:entry>
							<ce:entry align="char" char=".">25.04</ce:entry>
							<ce:entry align="char" char=".">24.72</ce:entry>
							<ce:entry align="char" char=".">25.17</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0020" rowsep="0" colsep="0">
				<ce:label>Table 4</ce:label>
				<ce:caption>
					<ce:simple-para id="sp085" view="all">Comparisons of watermark robustness under different channel erasure probabilities for the codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1024 after considering watermark embedding.
					</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="6" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="left"/>
					<cals:colspec colname="col3" align="left"/>
					<cals:colspec colname="col4" align="left"/>
					<cals:colspec colname="col5" align="left"/>
					<cals:colspec colname="col6" align="left"/>
					<cals:thead>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col2" rowsep="1">Channel erasure probability</ce:entry>
							<ce:entry namest="col3" nameend="col4" rowsep="1">BCR with our method (in %)</ce:entry>
							<ce:entry>BCR with 
								<ce:cross-ref refid="b0135">[27]</ce:cross-ref> (in %)
							</ce:entry>
							<ce:entry>BCR with 
								<ce:cross-ref refid="b0180">[36]</ce:cross-ref>
							</ce:entry>
						</cals:row>
						<cals:row rowsep="1" valign="top">
							<ce:entry>
								<ce:italic>p</ce:italic>
								<ce:inf loc="post">1</ce:inf>
							</ce:entry>
							<ce:entry>
								<ce:italic>p</ce:italic>
								<ce:inf loc="post">2</ce:inf>
							</ce:entry>
							<ce:entry>
								<mml:math altimg="si6.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>
							</ce:entry>
							<ce:entry>
								<mml:math altimg="si7.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>
							</ce:entry>
							<ce:entry>
								<mml:math altimg="si8.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>
							</ce:entry>
							<ce:entry>
								<mml:math altimg="si9.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>
							</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>0</ce:entry>
							<ce:entry>0</ce:entry>
							<ce:entry>100</ce:entry>
							<ce:entry>100</ce:entry>
							<ce:entry>100</ce:entry>
							<ce:entry>100</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.1</ce:entry>
							<ce:entry>0.1</ce:entry>
							<ce:entry>94.27</ce:entry>
							<ce:entry>93.44</ce:entry>
							<ce:entry>90.77</ce:entry>
							<ce:entry>94.76</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.25</ce:entry>
							<ce:entry>0.25</ce:entry>
							<ce:entry>86.52</ce:entry>
							<ce:entry>84.78</ce:entry>
							<ce:entry>79.06</ce:entry>
							<ce:entry>85.77</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0.5</ce:entry>
							<ce:entry>0.5</ce:entry>
							<ce:entry>73.28</ce:entry>
							<ce:entry>71.34</ce:entry>
							<ce:entry>62.66</ce:entry>
							<ce:entry>72.42</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>0</ce:entry>
							<ce:entry>1</ce:entry>
							<ce:entry>76.61</ce:entry>
							<ce:entry>70.78</ce:entry>
							<ce:entry>75.89</ce:entry>
							<ce:entry>80.94</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>1</ce:entry>
							<ce:entry>0</ce:entry>
							<ce:entry>68.56</ce:entry>
							<ce:entry>70.26</ce:entry>
							<ce:entry>66.66</ce:entry>
							<ce:entry>68.13</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
		</ce:floats>
		<ja:head>
			<ce:title xmlns:ce="http://www.elsevier.com/xml/common/schema">Tabu search based multi-watermarks embedding algorithm with multiple description coding</ce:title>
			<ce:author-group xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:author>
					<ce:given-name>Hsiang-Cheh</ce:given-name>
					<ce:surname>Huang</ce:surname>
					<ce:cross-ref refid="aff1">
						<ce:sup loc="post">a</ce:sup>
					</ce:cross-ref>
					<ce:cross-ref refid="cor1">
						<ce:sup loc="post">⁎</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">huang.hc@gmail.com</ce:e-address>
				</ce:author>
				<ce:author>
					<ce:given-name>Shu-Chuan</ce:given-name>
					<ce:surname>Chu</ce:surname>
					<ce:cross-ref refid="aff2">
						<ce:sup loc="post">b</ce:sup>
					</ce:cross-ref>
				</ce:author>
				<ce:author>
					<ce:given-name>Jeng-Shyang</ce:given-name>
					<ce:surname>Pan</ce:surname>
					<ce:cross-ref refid="aff3">
						<ce:sup loc="post">c</ce:sup>
					</ce:cross-ref>
				</ce:author>
				<ce:author>
					<ce:given-name>Chun-Yen</ce:given-name>
					<ce:surname>Huang</ce:surname>
					<ce:cross-ref refid="aff3">
						<ce:sup loc="post">c</ce:sup>
					</ce:cross-ref>
				</ce:author>
				<ce:author>
					<ce:given-name>Bin-Yih</ce:given-name>
					<ce:surname>Liao</ce:surname>
					<ce:cross-ref refid="aff3">
						<ce:sup loc="post">c</ce:sup>
					</ce:cross-ref>
				</ce:author>
				<ce:affiliation id="aff1">
					<ce:label>a</ce:label>
					<ce:textfn>National University of Kaohsiung, 700 University Rd., Kaohsiung 811, Taiwan, ROC</ce:textfn>
				</ce:affiliation>
				<ce:affiliation id="aff2">
					<ce:label>b</ce:label>
					<ce:textfn>School of Computer Science, Engineering and Mathematics, Flinders University of South Australia, Australia</ce:textfn>
				</ce:affiliation>
				<ce:affiliation id="aff3">
					<ce:label>c</ce:label>
					<ce:textfn>National Kaohsiung University of Applied Sciences, 415 Chien-Kung Rd., Kaohsiung 807, Taiwan, ROC</ce:textfn>
				</ce:affiliation>
				<ce:correspondence id="cor1">
					<ce:label>⁎</ce:label>
					<ce:text>Corresponding author. Tel.: +886 918 952075.</ce:text>
				</ce:correspondence>
			</ce:author-group>
			<ce:date-received day="5" month="2" year="2005" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:date-revised day="2" month="4" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:date-accepted day="6" month="4" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:abstract class="author" xml:lang="en" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Abstract</ce:section-title>
				<ce:abstract-sec>
					<ce:simple-para id="sp005" view="all">Digital watermarking is a useful solution for digital rights management systems, and it has been a popular research topic in the last decade. Most watermarking related literature focuses on how to resist deliberate attacks by applying benchmarks to watermarked media that assess the effectiveness of the watermarking algorithm. Only a few papers have concentrated on the error-resilient transmission of watermarked media. In this paper, we propose an innovative algorithm for vector quantization (VQ) based image watermarking, which is suitable for error-resilient transmission over noisy channels. By incorporating watermarking with multiple description coding (MDC), the scheme we propose to embed multiple watermarks can effectively overcome channel impairments while retaining the capability for copyright and ownership protection. In addition, we employ an optimization technique, called tabu search, to optimize both the watermarked image quality and the robustness of the extracted watermarks. We have obtained promising simulation results that demonstrate the utility and practicality of our algorithm.</ce:simple-para>
				</ce:abstract-sec>
			</ce:abstract>
			<ce:keywords class="keyword" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Keywords</ce:section-title>
				<ce:keyword>
					<ce:text>Watermarking</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Error resilience</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Multiple description coding</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Vector quantization</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Optimization</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Tabu search</ce:text>
				</ce:keyword>
			</ce:keywords>
		</ja:head>
		<ja:body view="all">
			<ce:sections xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section id="s0005" view="all">
					<ce:label>1</ce:label>
					<ce:section-title>Introduction</ce:section-title>
					<ce:para id="p0005" view="all">Digital watermarking 
						<ce:cross-refs refid="b0105 b0170 b0215">[21,34,43]</ce:cross-refs>, in conjunction with encryption 
						<ce:cross-refs refid="b0005 b0125">[1,25]</ce:cross-refs>, is a useful solution for digital rights management (DRM) systems. It embeds secret information into the digital contents to protect the intellectual property 
						<ce:cross-refs refid="b0100 b0210">[20,42]</ce:cross-refs> or the ownership of the original multimedia sources 
						<ce:cross-refs refid="b0020 b0055">[4,11]</ce:cross-refs>. Typical watermarking schemes embed the watermark by altering coefficients related to the original source in some specific domain, including the spatial-domain methods 
						<ce:cross-ref refid="b0195">[39]</ce:cross-ref>, transform-domain techniques using discrete cosine transform (DCT) 
						<ce:cross-refs refid="b0060 b0120">[12,24]</ce:cross-refs>, discrete wavelet transform (DWT) 
						<ce:cross-ref refid="b0095">[19]</ce:cross-ref> and discrete Fourier transform (DFT) 
						<ce:cross-ref refid="b0200">[40]</ce:cross-ref>, or VQ domain schemes 
						<ce:cross-refs refid="b0135 b0180">[27,36]</ce:cross-refs>. These schemes have been popular research topics in the last decade.
					</ce:para>
					<ce:para id="p0010" view="all">There are many metrics to measure the effectiveness of a watermarking algorithm. From the algorithm design viewpoint, the three most critical requirements are: 
						<ce:italic>watermark imperceptibility</ce:italic>, 
						<ce:italic>watermark robustness</ce:italic>, and 
						<ce:italic>watermark capacity</ce:italic>. Although these requirements are all very desirable, as pointed out in the literature 
						<ce:cross-refs refid="b0015 b0140 b0150 b0250">[3,28,30,50]</ce:cross-refs>, they influence, or even conflict, with the remaining requirements. Fixing one dimension, the other two conflict with each other, and some tradeoff or compromise must be reached 
						<ce:cross-ref refid="b0145">[29]</ce:cross-ref>. The tradeoff relationships can affect all three parameters.
						<ce:list id="l0010">
							<ce:list-item id="o0035">
								<ce:label>(1)</ce:label>
								<ce:para id="p0385" view="all">Watermark imperceptibility refers to whether the viewer can perceive the existence of an embedded watermark. To make the watermark imperceptible, two situations need to be considered.
									<ce:list id="l0015">
										<ce:list-item id="o0040">
											<ce:label>(a)</ce:label>
											<ce:para id="p0390" view="all">The number of watermark bits embedded must be less than a certain amount to make the watermark imperceptible. The theoretical bound for this amount, called the watermark capacity, is described in item (3) below, and is derived in the literature 
												<ce:cross-ref refid="b0115">[23]</ce:cross-ref>. Enhanced reliability can be expected by embedding multiple watermarks into the original multimedia 
												<ce:cross-ref refid="b0205">[41]</ce:cross-ref>. Conversely, embedding fewer bits implies less robustness in the watermarking algorithm.
											</ce:para>
										</ce:list-item>
										<ce:list-item id="o0045">
											<ce:label>(b)</ce:label>
											<ce:para id="p0395" view="all">Imperceptible watermarking indicates the least modification of the original media. The watermarked image quality is supposed to be within the just noticeable distortion (JND) region 
												<ce:cross-ref refid="b0085">[17]</ce:cross-ref>. In this regard, the commonly employed scheme in the spatial domain is to embed the watermark into the least significant bits (LSB); in the frequency domain, including the DCT and DWT domains, people tend to embed the watermark into the higher frequency band coefficients. This approach is motivated by the fact that most of the energy in the multimedia content, such as an image, is concentrated in the lower frequency band coefficients 
												<ce:cross-ref refid="b0075">[15]</ce:cross-ref>. Hence, embedding the watermark bits into higher frequency band coefficients results in less modification to the original source. However,this technique renders the watermark vulnerable to common image processing steps such as low-pass filtering (LPF).
											</ce:para>
										</ce:list-item>
									</ce:list>
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0050">
								<ce:label>(2)</ce:label>
								<ce:para id="p0400" view="all">Watermark robustness refers to the capability of the watermarked media to withstand intentional or unintentional media processing, called 
									<ce:italic>attacks</ce:italic>, including filtering, transcoding, resizing, or rotation. There are benchmarks to examine the watermark robustness objectively, such as Stirmark 
									<ce:cross-ref refid="b0185">[37]</ce:cross-ref>. It is generally agreed that robustness plays an important role in the design of a watermarking algorithm. Heuristically, improving robustness requires embedding the watermark into the most significant bits (MSB) in the spatial domain or the lower frequency band coefficients in the transform domain. However, this process can seriously degrade the watermarked image quality and alert others about the existence of the watermark. Consequently, to satisfy the tradeoff between watermark imperceptibility and watermark robustness, the watermark is embedded into the “middle frequency bands” in the transform domain 
									<ce:cross-ref refid="b0065">[13]</ce:cross-ref>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0055">
								<ce:label>(3)</ce:label>
								<ce:para id="p0405" view="all">Watermark capacity is determined by the number of bits embedded in the original media; that is, the size of the watermark. Generally speaking, when more bits can be embedded, the algorithm is supposed to be more robust; however, under such a condition, the quality of watermarked media must be degraded, and hence, the existence of the watermark becomes more perceptible. Authors in 
									<ce:cross-refs refid="b0015 b0115">[3,23]</ce:cross-refs> derived theoretical bounds for watermark capacity. For image watermarking, the watermark capacity is generally a constant size. Thus, only watermark imperceptibility and watermark robustness need to be considered for the design of the algorithm.
								</ce:para>
							</ce:list-item>
						</ce:list>
					</ce:para>
					<ce:para id="p0015" view="all">After considering the three fundamental requirements for watermarking, techniques for optimizing non-linear functions with multiple variables 
						<ce:cross-refs refid="b0025 b0225">[5,45]</ce:cross-refs> can be considered to search for the optimized outcome. In this paper, we fix the watermark capacity, and employ tabu search 
						<ce:cross-refs refid="b0045 b0070">[9,14]</ce:cross-refs> to find a tradeoff between watermark imperceptibility and watermark robustness. Tabu search is an evolutionary algorithm, characterized by the use of a flexible memory. It is able to eliminate local minima and to search areas beyond a local minimum. Some research papers and applications concentrate on designing watermarking algorithms with tabu search for audio signals 
						<ce:cross-ref refid="b0220">[44]</ce:cross-ref> and images 
						<ce:cross-refs refid="b0010 b0030 b0110 b0155">[2,6,22,31]</ce:cross-refs>, which are similar to the goal for optimization presented in this paper.
					</ce:para>
					<ce:para id="p0020" view="all">Before going into more details of our proposed algorithm, we would like to briefly summarize the existing methods 
						<ce:cross-refs refid="b0010 b0030 b0110 b0155 b0220">[2,6,22,31,44]</ce:cross-refs> to design a watermarking algorithm with tabu search. These methods are closely related to the main theme of this paper. We also discuss common items and differences, in addition to the advantages and disadvantages, in the design of each algorithm.
					</ce:para>
					<ce:para id="p0025" view="all">In 
						<ce:cross-ref refid="b0220">[44]</ce:cross-ref>, the authors present a wavelet-based watermarking algorithm for audio signals with tabu search. Both 
						<ce:cross-ref refid="b0220">[44]</ce:cross-ref> and this paper share similar concepts in designing the fitness for optimizing the different goals. On the one hand, the audio quality and the robustness of the watermarking algorithm under intentional attacks are considered in 
						<ce:cross-ref refid="b0220">[44]</ce:cross-ref>. The authors use tabu search to design a robust audio watermarking algorithm that preserves good quality in the watermarked audio signal, and yields better robustness for the extracted watermark. On the other hand, we consider image quality and watermark robustness under unintentional attacks in this paper. The concepts for designing our fitness function with tabu search are similar to those presented in 
						<ce:cross-ref refid="b0220">[44]</ce:cross-ref>. However, we introduce another major theme in this paper, called “multiple description coding” (MDC). In our work, image quality is enhanced by both tabu search and error-resilient coding, in the form of MDC. Background knowledge of MDC will be covered in Section 
						<ce:cross-ref refid="s0015">3</ce:cross-ref>.
					</ce:para>
					<ce:para id="p0030" view="all">In 
						<ce:cross-ref refid="b0010">[2]</ce:cross-ref>, the author proposes a wavelet-based robust watermarking algorithm for still images. The author claims that the algorithm can cope with JPEG compression and cropping attacks. Tabu search is employed to find the region- of-interest (ROI) of the original image, and then the watermark is embedded into the ROI portion of the image with the wavelet transform. In comparison with our paper, both the concept for designing the fitness function, and the goal for developing the watermarking algorithm are different. Though both 
						<ce:cross-ref refid="b0010">[2]</ce:cross-ref> and this paper use tabu search, the goals to be optimized are significantly different.
					</ce:para>
					<ce:para id="p0035" view="all">In 
						<ce:cross-ref refid="b0110">[22]</ce:cross-ref>, the authors propose a VQ-based robust watermarking algorithm suitable for transmitting watermarked VQ indices over a binary symmetric channel (BSC). The authors integrate their watermark embedding scheme into the codebook design problem. They employ two conventional schemes for VQ codebook design with tabu search: the index assignment (IA) scheme and the energy allocation (EA) scheme. In this paper, we employ an existing codebook trained by the well-known LBG algorithm. Tabu search is employed to optimize both the watermarked image quality and the watermark robustness. Like our approach, 
						<ce:cross-ref refid="b0110">[22]</ce:cross-ref> also use tabu search to train the parameters in the fitness function. However, the methodologies for designing the algorithms in the two papers are dissimilar.
					</ce:para>
					<ce:para id="p0040" view="all">In 
						<ce:cross-ref refid="b0030">[6]</ce:cross-ref> and 
						<ce:cross-ref refid="b0155">[31]</ce:cross-ref>, the authors propose a multiple watermarking scheme for embedding two watermarks: one in the spatial domain and the other in the transform domain. They employ tabu search to develop algorithms for image-based robust watermarking by embedding one visible watermark in the spatial domain and one imperceptible watermark in the transform domain. Both the watermarked image quality and the capability to resist the JPEG attack are optimized with tabu search. Because we use a different algorithm, VQ-based invisible watermarking with the error-resilient capability of MDC, we infer that the algorithms proposed in 
						<ce:cross-refs refid="b0030 b0155">[6,31]</ce:cross-refs> are completely different from our method.
					</ce:para>
					<ce:para id="p0045" view="all">We will briefly compare the existing VQ-based watermarking algorithms to the one we proposed. In this paper, we propose an innovative, VQ-based image watermarking algorithm that is suitable for error-resilient transmission over noisy channels. A review of the research literature related to digital watermarking indicated that only a few authors have concentrated on the error-resilient transmission of watermarked media 
						<ce:cross-refs refid="b0190 b0235">[38,47]</ce:cross-refs>. Most watermarking related literature focuses on how to resist intentional attacks. For practical implementations with VQ-based watermarking, existing methods are compared to the proposed algorithm in this paper. We conduct researches in transmitting watermarked images over binary symmetric channels (BSC) 
						<ce:cross-ref refid="b0175">[35]</ce:cross-ref> and packet-loss channels 
						<ce:cross-refs refid="b0160 b0165">[32,33]</ce:cross-refs>. In general, researchers use the BSC or packet-loss channel to simulate the transmission of baseband signals. In 
						<ce:cross-refs refid="b0160 b0165">[32,33]</ce:cross-refs> and in this paper, algorithms for transmission over packet-loss channels are developed. Because these papers 
						<ce:cross-refs refid="b0160 b0165 b0175">[32,33,35]</ce:cross-refs> focus on transmitting the watermarked image over lossy channels, this could be regarded as a new branch for watermarking research.
					</ce:para>
					<ce:para id="p0050" view="all">In light of the discussions above, we would like to point out that despite superficial similarities between our proposed algorithm and prior research work, there are still significant innovations presented in this paper. Besides using tabu search for optimization, we provide an additional method, MDC, to help protect the ownership of the original image, and simultaneously retain the reconstructed image. Our proposed algorithm combines watermarking and error-resilient coding, and the results have led to promising results. Based on the experience of our previous works, we employ tabu search in this paper to obtain an optimized solution suitable for the transmission of watermarked images over lossy channels.</ce:para>
					<ce:para id="p0055" view="all">This paper is organized as follows. We describe the fundamental concepts of VQ and MDC in Section 
						<ce:cross-ref refid="s0010">2</ce:cross-ref> and Section 
						<ce:cross-ref refid="s0015">3</ce:cross-ref>, respectively. Section 
						<ce:cross-ref refid="s0020">4</ce:cross-ref> concentrates on quantization-based MDC, which is an integration between the concepts in Sections 
						<ce:cross-refs refid="s0010 s0015">2 and 3</ce:cross-refs>. Section 
						<ce:cross-ref refid="s0025">5</ce:cross-ref> and Section 
						<ce:cross-ref refid="s0040">6</ce:cross-ref> present the watermark embedding and extraction algorithms. We demonstrate an example in Section 
						<ce:cross-ref refid="s0055">7</ce:cross-ref> to improve understanding of our proposed algorithm. Optimization of our algorithm with tabu search is described in Section 
						<ce:cross-ref refid="s0060">8</ce:cross-ref>. We also study two related algorithms published in the literature and briefly describe them in Section 
						<ce:cross-ref refid="s0075">9</ce:cross-ref>. Simulation results are shown in Section 
						<ce:cross-ref refid="s0095">10</ce:cross-ref>, and comparisons between our algorithm and those in Section 
						<ce:cross-ref refid="s0075">9</ce:cross-ref> are presented. Finally, we conclude this paper in Section 
						<ce:cross-ref refid="s0100">11</ce:cross-ref>.
					</ce:para>
				</ce:section>
				<ce:section id="s0010" view="all">
					<ce:label>2</ce:label>
					<ce:section-title>Fundamentals of vector quantization</ce:section-title>
					<ce:para id="p0060" view="all">Vector quantization 
						<ce:cross-ref refid="b0040">[8]</ce:cross-ref>, one of the important techniques in multimedia compression, has received considerable attention since the 1980s. As an extension to scalar quantization, vector quantization works on vectors of raw data. A vector can be a small block of image data, for example, the grey-level values of a 4
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>4 pixel image block forms a 16-dimensional vector. 
						<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref>
						<ce:float-anchor refid="f0005"/> gives a block diagram illustration of the operation of vector quantization compression.
					</ce:para>
					<ce:para id="p0065" view="all">The original image 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold> is composed of the combination of all of the input vectors, 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf>, ∀
						<ce:italic>k</ce:italic>. The codeword search process looks for a “nearest codeword,”
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf>, from the codebook for the given input vector 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf> with the Euclidean distance measure. The codebook 
						<ce:bold>
							<ce:italic>C</ce:italic>
						</ce:bold> with size 
						<ce:italic>L</ce:italic> is composed of 
						<ce:italic>L</ce:italic> elements, or the codewords with the representation 
						<ce:bold>
							<ce:italic>C</ce:italic>
						</ce:bold>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>{
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">0</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>…
						<ce:hsp sp="0.12"/>,
						<ce:hsp sp="0.12"/>
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>−1
						</ce:inf>}.
					</ce:para>
					<ce:para id="p0070" view="all">The codebook size, or the number of codewords in a codebook, is a tradeoff between the reconstructed image quality and the compression rate. The codewords in the codebook decide the subsequent compression distortion. A dedicated procedure requires to generation the appropriate codebook.</ce:para>
				</ce:section>
				<ce:section id="s0015" view="all">
					<ce:label>3</ce:label>
					<ce:section-title>Background of multiple description coding and its generic model</ce:section-title>
					<ce:para id="p0075" view="all">During transmissions of data, loss of data is inevitable due to channel error or packet loss in various types of transmission channels. In contrast to the conventional schemes such as progressive transmission, multiple description coding (MDC) offers an alternative method for the effective delivery of compressed multimedia information.</ce:para>
					<ce:para id="p0080" view="all">MDC is an error-resilient coding technique, which can be referred to as a source coding method for a channel whose end-to-end performance includes uncorrected erasures. This channel is encountered in a packet communication system that has effective error detection but does not have the features that permit the retransmission of incorrect or lost packets. MDC uses diversity to overcome channel impairments so that a decoder that receives an arbitrary subset of the channels may reproduce a useful reconstruction 
						<ce:cross-ref refid="b0080">[16]</ce:cross-ref>. Information-theoretic issues of MDC have been studied extensively since the early 1980s 
						<ce:cross-refs refid="b0035 b0255">[7,51]</ce:cross-refs>. In multiple description (MD) coders, the same source material is coded into several pieces of data, called 
						<ce:italic>descriptions</ce:italic>, such that each description can be decoded independently to obtain minimum fidelity. This information is also combined with other descriptions to achieve a better quality. The goal of MDC, and channel coding in general, is the making effective transmission of data, and MDC offers a totally different perspective from that of channel coding 
						<ce:cross-ref refid="b0130">[26]</ce:cross-ref>.
					</ce:para>
					<ce:para id="p0085" view="all">MDC is suitable for transmission over noisy channels with long bursts of errors. To gain robustness of the loss in spite of descriptions, MDC must sacrifice some compression efficiency while still retaining the capability for error resilience. Therefore, correlations between descriptions should be intentionally induced to achieve this goal. 
						<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref>
						<ce:float-anchor refid="f0010"/> depicts the generic model for MD source coding with two channels and three decoders. The Encoder is denoted by 
						<ce:italic>α</ce:italic>
						<ce:inf loc="post">0</ce:inf>. Decoder 0, denoted by 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">0</ce:inf>, is called the 
						<ce:italic>central decoder</ce:italic>, and Decoders 1 and 2, are denoted by 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">1</ce:inf> and 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">2</ce:inf> respectively, are the 
						<ce:italic>side decoders</ce:italic>. The Euclidean distance between 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold> and 
						<mml:math altimg="si10.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msup>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msup>
							</mml:mrow>
						</mml:math> is the 
						<ce:italic>central distortion</ce:italic>, while the errors between 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold> and 
						<mml:math altimg="si11.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msup>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>i</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msup>
								<mml:mtext>,</mml:mtext>
								<mml:mi>i</mml:mi>
								<mml:mo>=</mml:mo>
								<mml:mn>1</mml:mn>
								<mml:mtext>,</mml:mtext>
								<mml:mn>2</mml:mn>
								<mml:mtext>,</mml:mtext>
							</mml:mrow>
						</mml:math> are the 
						<ce:italic>side distortions</ce:italic>. It suggests a situation in which there are three separate users or three classes of users, which could arise when broadcasting on two channels. The same abstraction holds if there is a single user that can be in one of three states depending on which descriptions are received. Generally speaking, if we extend the number of transmission channels in 
						<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref> to 
						<ce:italic>P</ce:italic>, there will be (2
						<ce:sup loc="post">
							<ce:italic>P</ce:italic>
						</ce:sup>
						<ce:hsp sp="0.25"/>−
						<ce:hsp sp="0.25"/>1) receivers that decode with different number of descriptions received and reconstruct the image with different quality levels.
					</ce:para>
					<ce:para id="p0090" view="all">In addition to theoretical research, it is also important to devise practical designs to make MDC applicable to the situation depicted in 
						<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref>. Practical applications and implementations of MDC emerged in the 1990s. Two major categories for MDC applications are: (i) 
						<ce:italic>quantization based</ce:italic> schemes, such as Multiple Description Scalar Quantization (MDSQ) 
						<ce:cross-ref refid="b0230">[46]</ce:cross-ref> and Multiple Description Vector Quantization (MDVQ) 
						<ce:cross-ref refid="b0050">[10]</ce:cross-ref>, and (ii) 
						<ce:italic>transform-domain based</ce:italic> schemes, called Multiple Description Transform Coding (MDTC) 
						<ce:cross-refs refid="b0240 b0245">[48,49]</ce:cross-refs>. In this paper, we focus on quantization based MD schemes for watermarking. Operations and realizations of quantization-based MDC will be described in Section 
						<ce:cross-ref refid="s0020">4</ce:cross-ref>. For quantization-based MDC, redundancies induced between descriptions are controlled inherently. Thus, only the watermarked image quality and the robustness should be taken care of, and this is the motivation to use MDVQ for watermarking. On the other hand, the idea for watermarking with MDTC is basically the same as that with MDVQ. For MDTC, correlations between different descriptions are controlled by the users at the encoder. After transmission, two descriptions are composed to reconstruct one 8
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>8 block at the decoder. Greater correlation between descriptions leads to better resilience to channel error in the reconstructed image, at the expense of degraded performance in compression. Taking watermark embedding into account, three parameters, including (a) the watermarked image quality, (b) the robustness, and (c) the correlation coefficient between descriptions should all be considered. Because one 8
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>8 block in the original image corresponds to one correlation coefficient, the design of the fitness function may become a difficult task. The vast quantity of correlation coefficients may impair the convergence of the training with tabu search. Thus, watermarking with MDTC is beyond the scope of this paper because the design and implementation of the algorithm need to be performed by other means. We will concentrate on watermarking with quantization-based MDC in this paper.
					</ce:para>
				</ce:section>
				<ce:section id="s0020" view="all">
					<ce:label>4</ce:label>
					<ce:section-title>Quantization-based multiple description coding</ce:section-title>
					<ce:para id="p0095" view="all">Applications of MDC focus on error concealment and error resilience. In this paper, we introduce the idea of applying MDC with watermarking schemes to cover both the reconstructed image quality after reception, and the ownership of the original image.</ce:para>
					<ce:para id="p0100" view="all">
						<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref> is the generic structure of MDC, which can also be applied to quantization based multiple-description (MD). For example, the first practical design is based on scalar quantization. Employing different quantization levels in the MD structure is a straightforward solution. In addition, MDSQ is flexible in that it allows a designer to choose the relative importance of the central distortion and each side distortion. The basic structure for MDSQ with two descriptions is illustrated in 
						<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>
						<ce:float-anchor refid="f0015"/>. The input 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold> is first quantized into a scalar 
						<ce:italic>i</ce:italic>, using the scalar quantization function 
						<ce:italic>α</ce:italic>. Then, the encoder produces a pair of quantization indices (
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">2</ce:inf>) from each scalar sample 
						<ce:italic>i</ce:italic>. This step is called “index assignment.” In 
						<ce:cross-ref refid="b0230">[46]</ce:cross-ref>, the author described in detail how to perform quantization using an invertible function and introduced a convenient way to visualize the encoding operation. The method to turn the scalar sample into the indices by carrying out the index assignment process was also developed. The encoding is first decomposed into two steps:
						<ce:display>
							<ce:formula id="e0005">
								<ce:label>(1)</ce:label>
								<mml:math altimg="si12.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:msub>
										<mml:mrow>
											<mml:mi>α</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>0</mml:mn>
										</mml:mrow>
									</mml:msub>
									<mml:mo>=</mml:mo>
									<mml:mi>l</mml:mi>
									<mml:mo>∘</mml:mo>
									<mml:mi>α</mml:mi>
									<mml:mtext>.</mml:mtext>
								</mml:math>
							</ce:formula>
						</ce:display>The initial encoder 
						<ce:italic>α</ce:italic> is a regular scalar quantizer. That is, it partitions the real line into cells that are each intervals. The index assignment 
						<ce:italic>l</ce:italic> employs the index produced by the ordinary quantizer 
						<ce:italic>α</ce:italic>, and uses the resulting encoder 
						<ce:italic>α</ce:italic>
						<ce:inf loc="post">0</ce:inf> to produce the pair of indices (
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">2</ce:inf>). After transmission of the indices over different channels with mutually independent breakdown probabilities 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">1</ce:inf> and 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">2</ce:inf>, the three decoders produce estimates from the received indices: 
						<mml:math altimg="si13.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mo stretchy="false">(</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>˜</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mtext>,</mml:mtext>
								<mml:msub>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>˜</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>2</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mo stretchy="false">)</mml:mo>
							</mml:mrow>
						</mml:math> for Decoder 0, 
						<mml:math altimg="si14.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msub>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>˜</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msub>
							</mml:mrow>
						</mml:math> for Decoder 1, and 
						<mml:math altimg="si15.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msub>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>˜</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>2</mml:mn>
									</mml:mrow>
								</mml:msub>
							</mml:mrow>
						</mml:math> for Decoder 2, respectively. The index assignment must be invertible in order for the central decoder to recover the output of 
						<ce:italic>α</ce:italic>. The visualization technique is to write 
						<ce:italic>l</ce:italic>
						<ce:sup loc="post">−1</ce:sup>, forming the index assignment matrix. Therefore, the 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">1</ce:inf> and 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">2</ce:inf> decoder mappings are indicated by the row and column positions in the MDSQ index assignment in 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>
						<ce:float-anchor refid="f0020"/>. The action of 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">0</ce:inf> is implicit. By performing the inverse quantization process, the output of the central decoder, which is the reconstructed sample 
						<mml:math altimg="si16.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msup>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msup>
							</mml:mrow>
						</mml:math>, has a low central distortion. The side decoders output the reconstructions 
						<mml:math altimg="si17.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msup>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msup>
							</mml:mrow>
						</mml:math> and 
						<mml:math altimg="si18.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msup>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>2</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msup>
							</mml:mrow>
						</mml:math> with somewhat higher side distortions.
					</ce:para>
					<ce:para id="p0105" view="all">The breakdown probabilities for the two channels, 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">1</ce:inf> and 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">2</ce:inf>, should be considered as the “packet-loss” probabilities. The meaning and usage of 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">1</ce:inf> and 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">2</ce:inf> are consistent with other MDC research papers 
						<ce:cross-refs refid="b0240 b0245">[48,49]</ce:cross-refs>.
					</ce:para>
					<ce:para id="p0110" view="all">
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref> provides a simple example of MDSQ to help visualize the encoding operation in the 
						<ce:italic>index assignment</ce:italic> portion of 
						<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>. This example has a codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>8. In the design of an MD scalar quantizer, one can optimize 
						<ce:italic>α</ce:italic>
						<ce:inf loc="post">0</ce:inf>, 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">0</ce:inf>, 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">1</ce:inf>, and 
						<ce:italic>β</ce:italic>
						<ce:inf loc="post">2</ce:inf> very easily as in 
						<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>. The optimization of the index assignment 
						<ce:italic>l</ce:italic> is very difficult. Instead of addressing the exact optimal index assignment problem, the author in 
						<ce:cross-ref refid="b0230">[46]</ce:cross-ref> presented several heuristic techniques. For example, the output for the nested index assignment is close to the best possible performance. The dimension of the matrix is denoted by 
						<ce:italic>P</ce:italic>. This equals the number of descriptions, or the number of channels available for transmission in 
						<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref>. We will set 
						<ce:italic>P</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>2 in this paper. Thus, for 
						<ce:italic>P</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>2, the descriptions of the MDSQ can be interpreted as the row and column indices of a matrix, where the codewords, or respectively, their indices, are placed. The basic ideas are to number the index assignment matrix from the upper-left corner to the lower-right corner and to fill in from the main diagonal outward. A set of index pairs are constructed from those that lie on the main diagonal and on the 2
						<ce:italic>m</ce:italic> diagonals closest to the main diagonal. The parameter 
						<ce:italic>m</ce:italic> is called 
						<ce:italic>spread</ce:italic>. The index assignment, shown in 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>, is called the “nested index assignment,” where the row and column indices, 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">1</ce:inf>, and 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">2</ce:inf>, are transmitted over two independent channels.
					</ce:para>
					<ce:para id="p0115" view="all">The cells of the encoder 
						<ce:italic>α</ce:italic> are used in increasing values of 
						<ce:italic>i</ce:italic>, and are numbered from 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">0</ce:inf> to 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">7</ce:inf> in 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(a), and 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">0</ce:inf> to 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">21</ce:inf> in 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(b), respectively. 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(a) is an index assignment scheme with a spread 
						<ce:italic>m</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0. Only eight samples, or 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">0</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>…
						<ce:hsp sp="0.12"/>,
						<ce:hsp sp="0.12"/>
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">7</ce:inf>, are the valid scalar samples for transmission. Generally speaking, an 
						<ce:italic>n</ce:italic>-bit sample can be represented by log
						<ce:inf loc="post">2</ce:inf>(
						<ce:italic>n</ce:italic>)-bit strings. The eight samples can be represented by 3-bit strings. Thus, if 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">3</ce:inf> is the scalar sample to be transmitted, then after the index assignment step 
						<ce:italic>l</ce:italic>, we obtain 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">1</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>011 and 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">2</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>011 represented in their binary forms. The central distortion is the quantization error between the input and the quantized samples. This configuration with a spread of 
						<ce:italic>m</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0 can be regarded as repetition of samples. It indicates that a total of 6 bits will be received if no channel breakdown occurs. Consequently, 6 bits need to be transmitted over two different channels to describe 3 bits of information. This produces a redundancy of 
						<mml:math altimg="si19.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mrow>
									<mml:mfenced open="(" close=")">
										<mml:mrow>
											<mml:mfrac>
												<mml:mrow>
													<mml:mn>6</mml:mn>
													<mml:mo>-</mml:mo>
													<mml:mn>3</mml:mn>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>3</mml:mn>
												</mml:mrow>
											</mml:mfrac>
										</mml:mrow>
									</mml:mfenced>
								</mml:mrow>
								<mml:mo>×</mml:mo>
								<mml:mn>100</mml:mn>
								<mml:mo>%</mml:mo>
								<mml:mo>=</mml:mo>
								<mml:mn>100</mml:mn>
								<mml:mo>%</mml:mo>
							</mml:mrow>
						</mml:math>. In decoding the received descriptions, if both are obtained, as depicted in 
						<ce:cross-ref refid="b0230">[46]</ce:cross-ref> by calculating the conditional expectation, the reconstructed image decoded from both descriptions can be obtained. The conditional probabilities for receiving both descriptions in 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(a) are:
						<ce:display>
							<ce:formula id="e0010">
								<ce:label>(2)</ce:label>
								<mml:math altimg="si20.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mi>p</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>j</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>t</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">|</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
										</mml:mrow>
									</mml:msub>
									<mml:mo>=</mml:mo>
									<mml:mn>011</mml:mn>
									<mml:mtext>,</mml:mtext>
									<mml:msub>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
										</mml:mrow>
									</mml:msub>
									<mml:mo>=</mml:mo>
									<mml:mn>011</mml:mn>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mfenced open="{" close="">
											<mml:mrow>
												<mml:mtable>
													<mml:mtr>
														<mml:mtd columnalign="left">
															<mml:mn>1</mml:mn>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
														<mml:mtd columnalign="left">
															<mml:mtext>if</mml:mtext>
															<mml:mspace width="0.35em"/>
															<mml:mi>t</mml:mi>
															<mml:mo>=</mml:mo>
															<mml:mn>3</mml:mn>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
													</mml:mtr>
													<mml:mtr>
														<mml:mtd columnalign="left">
															<mml:mn>0</mml:mn>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
														<mml:mtd columnalign="left">
															<mml:mtext>otherwise.</mml:mtext>
														</mml:mtd>
													</mml:mtr>
												</mml:mtable>
											</mml:mrow>
										</mml:mfenced>
									</mml:mrow>
								</mml:math>
							</ce:formula>
						</ce:display>Because the conditional probability for transmitting 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">3</ce:inf> is 1.0, given the received conditions, we determine that the transmitted index is 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">3</ce:inf>. If one of the channels breaks down, say, Channel 1, 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">2</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>011 is received. Using 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(a) and calculating the conditional probability at the decoder as indicated in Eq. 
						<ce:cross-ref refid="e0010">(2)</ce:cross-ref>, we visualize the column containing ‘011’. We can then determine that the transmitted scalar is 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">3</ce:inf> with a probability of 1.0. This is equivalent to when both descriptions are received. In this circumstance, the central distortion is the same as the side distortion at a cost of 100% redundancy when the spread is 
						<ce:italic>m</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0 in MDSQ.
					</ce:para>
					<ce:para id="p0120" view="all">
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(b) is an index assignment scheme with a spread of 
						<ce:italic>m</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1. There are only 22 samples, or 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">0</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>…
						<ce:hsp sp="0.12"/>,
						<ce:hsp sp="0.12"/>
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">21</ce:inf>, which are the valid scalar samples for transmission. This shows that the quality of side reconstructions is represented by the small ranges of values in any row or any column depending on the received description from any one channel. An index assignment matrix with a higher fraction of occupied cells leads to a quantizer pair with lower redundancy. From the viewpoint of practical implementation, the 22 samples can be represented by ⌈log
						<ce:inf loc="post">2</ce:inf>(22)⌉-bit, or 5-bit strings, where ⌈•⌉ indicates a ceiling function. If 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">7</ce:inf> is the scalar sample to be transmitted, after the index assignment step 
						<ce:italic>l</ce:italic>, we obtain 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">1</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>010 and 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">2</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>011. By doing this and when both descriptions are received, the transmitted sample 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">7</ce:inf> is determined with a probability of 1.0 with 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(b). That is,
						<ce:display>
							<ce:formula id="e0015">
								<ce:label>(3)</ce:label>
								<mml:math altimg="si21.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mi>p</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>j</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>t</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">|</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
										</mml:mrow>
									</mml:msub>
									<mml:mo>=</mml:mo>
									<mml:mn>010</mml:mn>
									<mml:mtext>,</mml:mtext>
									<mml:msub>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
										</mml:mrow>
									</mml:msub>
									<mml:mo>=</mml:mo>
									<mml:mn>011</mml:mn>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mfenced open="{" close="">
											<mml:mrow>
												<mml:mtable>
													<mml:mtr>
														<mml:mtd columnalign="left">
															<mml:mn>1</mml:mn>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
														<mml:mtd columnalign="left">
															<mml:mtext>if</mml:mtext>
															<mml:mspace width="0.35em"/>
															<mml:mi>t</mml:mi>
															<mml:mo>=</mml:mo>
															<mml:mn>7</mml:mn>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
													</mml:mtr>
													<mml:mtr>
														<mml:mtd columnalign="left">
															<mml:mn>0</mml:mn>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
														<mml:mtd columnalign="left">
															<mml:mtext>otherwise</mml:mtext>
														</mml:mtd>
													</mml:mtr>
												</mml:mtable>
											</mml:mrow>
										</mml:mfenced>
									</mml:mrow>
								</mml:math>
							</ce:formula>
						</ce:display>and the redundancy is reduced to 
						<mml:math altimg="si22.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mrow>
									<mml:mfenced open="(" close=")">
										<mml:mrow>
											<mml:mfrac>
												<mml:mrow>
													<mml:mn>6</mml:mn>
													<mml:mo>-</mml:mo>
													<mml:mo>⌈</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="normal">log</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mn>2</mml:mn>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mn>22</mml:mn>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>⌉</mml:mo>
												</mml:mrow>
												<mml:mrow>
													<mml:mo>⌈</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="normal">log</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mn>2</mml:mn>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mn>22</mml:mn>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>⌉</mml:mo>
												</mml:mrow>
											</mml:mfrac>
										</mml:mrow>
									</mml:mfenced>
								</mml:mrow>
								<mml:mo>×</mml:mo>
								<mml:mn>100</mml:mn>
								<mml:mo>%</mml:mo>
								<mml:mo>=</mml:mo>
								<mml:mn>20.00</mml:mn>
								<mml:mo>%</mml:mo>
							</mml:mrow>
						</mml:math>. If one of the channels breaks down, say, Channel 1, only 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">2</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>011 is received. With the aid of 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(b), we visualize the column containing ‘011’ and estimate that there are three possible candidates. These are 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">7</ce:inf>, 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">9</ce:inf>, and 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">11</ce:inf>, which may have been transmitted, with the conditional probabilities:
						<ce:display>
							<ce:formula id="e0020">
								<ce:label>(4)</ce:label>
								<mml:math altimg="si23.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mi>p</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>j</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>t</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">|</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
										</mml:mrow>
									</mml:msub>
									<mml:mo>=</mml:mo>
									<mml:mn>011</mml:mn>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mfenced open="{" close="">
											<mml:mrow>
												<mml:mtable>
													<mml:mtr>
														<mml:mtd columnalign="left">
															<mml:mfrac>
																<mml:mrow>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																	<mml:mi>m</mml:mi>
																	<mml:mo>+</mml:mo>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
															</mml:mfrac>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
														<mml:mtd columnalign="left">
															<mml:mtext>if</mml:mtext>
															<mml:mspace width="0.35em"/>
															<mml:mi>t</mml:mi>
															<mml:mo>=</mml:mo>
															<mml:mn>7</mml:mn>
															<mml:mspace width="0.35em"/>
															<mml:mtext>or</mml:mtext>
															<mml:mspace width="0.35em"/>
															<mml:mn>9</mml:mn>
															<mml:mspace width="0.35em"/>
															<mml:mtext>or</mml:mtext>
															<mml:mspace width="0.35em"/>
															<mml:mn>11</mml:mn>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
													</mml:mtr>
													<mml:mtr>
														<mml:mtd columnalign="left">
															<mml:mn>0</mml:mn>
															<mml:mtext>,</mml:mtext>
														</mml:mtd>
														<mml:mtd columnalign="left">
															<mml:mtext>otherwise,</mml:mtext>
														</mml:mtd>
													</mml:mtr>
												</mml:mtable>
											</mml:mrow>
										</mml:mfenced>
									</mml:mrow>
								</mml:math>
							</ce:formula>
						</ce:display>where 
						<ce:italic>m</ce:italic> denotes the spread. The side distortion would be larger than the central distortion, because the side distortion is the error between the transmitted 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">7</ce:inf> and the conditional expectation in Eq. 
						<ce:cross-ref refid="e0020">(4)</ce:cross-ref>, 
						<mml:math altimg="si24.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mfrac>
									<mml:mrow>
										<mml:mn>1</mml:mn>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>3</mml:mn>
									</mml:mrow>
								</mml:mfrac>
								<mml:mo stretchy="false">(</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>j</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>7</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mo>+</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>j</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>9</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mo>+</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>j</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>11</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mo stretchy="false">)</mml:mo>
							</mml:mrow>
						</mml:math>. Comparing this to the case when 
						<ce:italic>m</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0, the redundancy is greatly reduced, while the side distortion is somewhat increased.
					</ce:para>
					<ce:para id="p0125" view="all">It is a straightforward task to extend MDSQ to MDVQ, though the index assignment of MDVQ is more difficult than MDSQ. 
						<ce:cross-ref refid="f0025">Fig. 5</ce:cross-ref>
						<ce:float-anchor refid="f0025"/> demonstrates the MDVQ structure with two descriptions. Here, by following 
						<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref>, the input 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf> denotes the small block or code vector. For example, 
						<mml:math altimg="si25.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msub>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>k</mml:mi>
									</mml:mrow>
								</mml:msub>
							</mml:mrow>
						</mml:math> denotes the 4
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>4 block described in Section 
						<ce:cross-ref refid="s0010">2</ce:cross-ref>, for VQ operation. The reconstruction 
						<mml:math altimg="si26.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msubsup>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>k</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msubsup>
							</mml:mrow>
						</mml:math> from the central decoder has less distortion than that from each of the side decoders, 
						<mml:math altimg="si27.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msubsup>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>k</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msubsup>
							</mml:mrow>
						</mml:math> or 
						<mml:math altimg="si28.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msubsup>
									<mml:mrow>
										<mml:mover accent="true">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="true">^</mml:mo>
											</mml:mrow>
										</mml:mover>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>k</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>2</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msubsup>
							</mml:mrow>
						</mml:math>. In this paper, we follow the MDSQ in 
						<ce:cross-ref refid="b0230">[46]</ce:cross-ref> and MDVQ algorithm in 
						<ce:cross-ref refid="b0050">[10]</ce:cross-ref>, and devise a robust multi-watermarking algorithm suitable for both error resilient transmission and ownership protection.
					</ce:para>
				</ce:section>
				<ce:section id="s0025" view="all">
					<ce:label>5</ce:label>
					<ce:section-title>The watermarking algorithm for embedding two watermarks</ce:section-title>
					<ce:para id="p0130" view="all">We propose our watermarking algorithm for embedding two watermarks with VQ and MDC. Embedding more than one watermark has been an interesting topic in the literature. The structure is demonstrated in 
						<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>
						<ce:float-anchor refid="f0030"/>. Our goals are twofold. The first is to contribute to the error-resilience for the transmission of a watermarked image. Our second goal is to provide ownership protection capability with watermarking.
					</ce:para>
					<ce:para id="p0135" view="all">Let the input image be 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold> with a size 
						<ce:italic>M</ce:italic>
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>
						<ce:italic>N</ce:italic>. We perform the VQ operation first to train the codebook for 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>. The codebook has a size 
						<ce:italic>L</ce:italic>. The codebook 
						<ce:bold>
							<ce:italic>C</ce:italic>
						</ce:bold>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>{
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">0</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>…
						<ce:hsp sp="0.12"/>,
						<ce:hsp sp="0.12"/>
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>−1
						</ce:inf>} is obtained. Each index therein is represented by a ⌈log
						<ce:inf loc="post">2</ce:inf>
						<ce:italic>L</ce:italic>⌉-bit binary string, where ⌈•⌉ means a ceiling function. In operating the VQ procedure, 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold> is divided into non-overlapping blocks 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf> with size 
						<mml:math altimg="si29.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mfrac>
									<mml:mrow>
										<mml:mi>M</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi>M</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:mfrac>
								<mml:mo>×</mml:mo>
								<mml:mfrac>
									<mml:mrow>
										<mml:mi>N</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi>N</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:mfrac>
								<mml:mtext>,</mml:mtext>
								<mml:mn>0</mml:mn>
								<mml:mo>⩽</mml:mo>
								<mml:mi>k</mml:mi>
								<mml:mo>⩽</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>M</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>W</mml:mi>
									</mml:mrow>
								</mml:msub>
								<mml:mo>·</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>N</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>W</mml:mi>
									</mml:mrow>
								</mml:msub>
								<mml:mo>-</mml:mo>
								<mml:mn>1</mml:mn>
							</mml:mrow>
						</mml:math>, then each 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf> finds its nearest codeword 
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf> in the codebook 
						<ce:bold>
							<ce:italic>C</ce:italic>
						</ce:bold>, and the index 
						<ce:italic>i</ce:italic> is assigned to 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf>. The steps above follow the conventional VQ procedures.
					</ce:para>
					<ce:para id="p0140" view="all">Let the watermarks for embedding be 
						<mml:math altimg="si30.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msub>
									<mml:mrow>
										<mml:mi mathvariant="bold-italic">W</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mo>=</mml:mo>
								<mml:mo stretchy="false">{</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>W</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>1</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mtext>,</mml:mtext>
								<mml:msub>
									<mml:mrow>
										<mml:mi>W</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>1</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mtext>,</mml:mtext>
								<mml:mo>…</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>W</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>1</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>M</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>N</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>-</mml:mo>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mo stretchy="false">}</mml:mo>
							</mml:mrow>
						</mml:math> and 
						<mml:math altimg="si31.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msub>
									<mml:mrow>
										<mml:mi mathvariant="bold-italic">W</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>2</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mo>=</mml:mo>
								<mml:mo stretchy="false">{</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>W</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>2</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mtext>,</mml:mtext>
								<mml:msub>
									<mml:mrow>
										<mml:mi>W</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>2</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mtext>,</mml:mtext>
								<mml:mo>…</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>W</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>2</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>M</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>N</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>-</mml:mo>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msub>
								<mml:mo stretchy="false">}</mml:mo>
							</mml:mrow>
						</mml:math>, both having sizes 
						<ce:italic>M</ce:italic>
						<ce:inf loc="post">
							<ce:italic>W</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>
						<ce:italic>N</ce:italic>
						<ce:inf loc="post">
							<ce:italic>W</ce:italic>
						</ce:inf>. Each element in 
						<ce:bold>
							<ce:italic>W</ce:italic>
						</ce:bold>
						<ce:inf loc="post">1</ce:inf> and 
						<ce:bold>
							<ce:italic>W</ce:italic>
						</ce:bold>
						<ce:inf loc="post">2</ce:inf> represents one watermark bit to be embedded into 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf>. Embedding of the two watermarks will now be described in Section 
						<ce:cross-ref refid="s0030">5.1</ce:cross-ref> and Section 
						<ce:cross-ref refid="s0035">5.2</ce:cross-ref>.
					</ce:para>
					<ce:section id="s0030" view="all">
						<ce:label>5.1</ce:label>
						<ce:section-title>Embedding the first watermark</ce:section-title>
						<ce:para id="p0145" view="all">When embedding the first watermark 
							<ce:bold>
								<ce:italic>W</ce:italic>
							</ce:bold>
							<ce:inf loc="post">1</ce:inf>, we split 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> into two sub-codebooks 
							<mml:math altimg="si32.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msup>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mfenced open="{" close="}">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>0</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
												<mml:mtext>,</mml:mtext>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
												<mml:mtext>,</mml:mtext>
												<mml:mo>…</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mfrac>
															<mml:mrow>
																<mml:mi>L</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mn>2</mml:mn>
															</mml:mrow>
														</mml:mfrac>
														<mml:mo>-</mml:mo>
														<mml:mn>1</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:mfenced>
									</mml:mrow>
								</mml:mrow>
							</mml:math> and 
							<mml:math altimg="si33.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>″</mml:mo>
										</mml:mrow>
									</mml:msup>
									<mml:mo>=</mml:mo>
									<mml:mrow>
										<mml:mfenced open="{" close="}">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>0</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>″</mml:mo>
													</mml:mrow>
												</mml:msubsup>
												<mml:mtext>,</mml:mtext>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>″</mml:mo>
													</mml:mrow>
												</mml:msubsup>
												<mml:mtext>,</mml:mtext>
												<mml:mo>…</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mfrac>
															<mml:mrow>
																<mml:mi>L</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mn>2</mml:mn>
															</mml:mrow>
														</mml:mfrac>
														<mml:mo>-</mml:mo>
														<mml:mn>1</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>″</mml:mo>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:mfenced>
									</mml:mrow>
								</mml:mrow>
							</mml:math>. We denote this in the “codeword selection” portion in 
							<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>. We see that 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>′
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>″
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> and 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>′
							<ce:hsp sp="0.25"/>⋂
							<ce:hsp sp="0.25"/>
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>″
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>∅. We employ tabu search to split 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> into 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>′ and 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>″ and will search for the tradeoff between watermark imperceptibility and watermark robustness using a properly selected fitness function, as described in Section 
							<ce:cross-ref refid="s0060">8</ce:cross-ref>. For one index in 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>′, there is a one-to-one corresponding counterpart, with the same subscript, in 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>″. For example, let 
							<mml:math altimg="si34.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>c</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>t</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> denote the index for the current block 
							<mml:math altimg="si35.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">X</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>k</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:mi>t</mml:mi>
									<mml:mo>∈</mml:mo>
									<mml:mrow>
										<mml:mfenced open="[" close="]">
											<mml:mrow>
												<mml:mn>0</mml:mn>
												<mml:mtext>,</mml:mtext>
												<mml:mfrac>
													<mml:mrow>
														<mml:mi>L</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:mfrac>
												<mml:mo>-</mml:mo>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:mfenced>
									</mml:mrow>
								</mml:mrow>
							</mml:math>. When embedding the first watermark, the output index 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">
								<ce:italic>S</ce:italic>
							</ce:inf>, which denotes the index containing 
							<ce:bold>
								<ce:italic>Single</ce:italic>
							</ce:bold> watermark for representing 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf>, is generated according to the value of the watermark bit 
							<ce:italic>W</ce:italic>
							<ce:inf loc="post">1,
								<ce:italic>k</ce:italic>
							</ce:inf>:
							<ce:display>
								<ce:formula id="e0025">
									<ce:label>(5)</ce:label>
									<mml:math altimg="si36.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>S</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="{" close="">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="left">
																<mml:msubsup>
																	<mml:mrow>
																		<mml:mi>c</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>t</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mo>′</mml:mo>
																	</mml:mrow>
																</mml:msubsup>
																<mml:mtext>,</mml:mtext>
															</mml:mtd>
															<mml:mtd columnalign="left">
																<mml:mtext>if</mml:mtext>
																<mml:mspace width="0.35em"/>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>W</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mn>1</mml:mn>
																		<mml:mtext>,</mml:mtext>
																		<mml:mi>k</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mo>=</mml:mo>
																<mml:mn>0</mml:mn>
																<mml:mtext>,</mml:mtext>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="left">
																<mml:msubsup>
																	<mml:mrow>
																		<mml:mi>c</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>t</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mo>″</mml:mo>
																	</mml:mrow>
																</mml:msubsup>
																<mml:mtext>,</mml:mtext>
															</mml:mtd>
															<mml:mtd columnalign="left">
																<mml:mtext>if</mml:mtext>
																<mml:mspace width="0.35em"/>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>W</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mn>1</mml:mn>
																		<mml:mtext>,</mml:mtext>
																		<mml:mi>k</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mo>=</mml:mo>
																<mml:mn>1</mml:mn>
																<mml:mtext>,</mml:mtext>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mspace width="1em"/>
										<mml:mi>t</mml:mi>
										<mml:mo>∈</mml:mo>
										<mml:mrow>
											<mml:mfenced open="[" close="]">
												<mml:mrow>
													<mml:mn>0</mml:mn>
													<mml:mtext>,</mml:mtext>
													<mml:mfrac>
														<mml:mrow>
															<mml:mi>L</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mn>2</mml:mn>
														</mml:mrow>
													</mml:mfrac>
													<mml:mo>-</mml:mo>
													<mml:mn>1</mml:mn>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="1em"/>
										<mml:mi>k</mml:mi>
										<mml:mo>∈</mml:mo>
										<mml:mo stretchy="false">[</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>M</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>N</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>-</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">]</mml:mo>
										<mml:mtext>.</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>Next, 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">
								<ce:italic>S</ce:italic>
							</ce:inf> is fed into the MD encoder in 
							<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref> to embed the second watermark.
						</ce:para>
					</ce:section>
					<ce:section id="s0035" view="all">
						<ce:label>5.2</ce:label>
						<ce:section-title>Embedding the second watermark</ce:section-title>
						<ce:para id="p0150" view="all">Embedding the second watermark is a modification from our previous work in 
							<ce:cross-ref refid="b0160">[32]</ce:cross-ref>. This is a two-step process. First, we shift the watermarked index 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">
								<ce:italic>S</ce:italic>
							</ce:inf> to the left by one bit. Second, we tag the watermark bit 
							<ce:italic>W</ce:italic>
							<ce:inf loc="post">2,
								<ce:italic>k</ce:italic>
							</ce:inf> and move it to the end of the shifted index. That is,
							<ce:display>
								<ce:formula id="e0030">
									<ce:label>(6)</ce:label>
									<mml:math altimg="si37.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>B</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>S</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>&lt;</mml:mo>
										<mml:mo>&lt;</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
												<mml:mtext>,</mml:mtext>
												<mml:mi>k</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="1em"/>
										<mml:mi>k</mml:mi>
										<mml:mo>∈</mml:mo>
										<mml:mo stretchy="false">[</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>M</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>N</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>-</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">]</mml:mo>
										<mml:mtext>,</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>where 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">
								<ce:italic>B</ce:italic>
							</ce:inf> denotes the index containing 
							<ce:bold>
								<ce:italic>Both</ce:italic>
							</ce:bold> watermarks. Next, we make use of the MDSQ algorithms in 
							<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(b) for index assignment. The index assignments in 
							<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref> are 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">1</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>l</ce:italic>
							<ce:inf loc="post">1</ce:inf>(
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">
								<ce:italic>B</ce:italic>
							</ce:inf>) and 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">2</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>l</ce:italic>
							<ce:inf loc="post">2</ce:inf>(
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">
								<ce:italic>B</ce:italic>
							</ce:inf>). They map the quantizer output index 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">
								<ce:italic>B</ce:italic>
							</ce:inf> to the two descriptions 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">1</ce:inf> and 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">2</ce:inf>.
						</ce:para>
						<ce:para id="p0155" view="all">After completing the embedding of 
							<ce:italic>W</ce:italic>
							<ce:inf loc="post">1,
								<ce:italic>k</ce:italic>
							</ce:inf> and 
							<ce:italic>W</ce:italic>
							<ce:inf loc="post">2,
								<ce:italic>k</ce:italic>
							</ce:inf> in 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf>, 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">1</ce:inf> and 
							<ce:italic>i</ce:italic>
							<ce:inf loc="post">2</ce:inf> are transmitted over two memoryless and mutually independent channels with erasure probabilities 
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">1</ce:inf> for Channel 1, and 
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">2</ce:inf> for Channel 2, respectively. This procedure is completed when all of the blocks 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf>, 
							<ce:italic>k</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>[0,
							<ce:hsp sp="0.12"/>
							<ce:italic>M</ce:italic>
							<ce:inf loc="post">
								<ce:italic>W</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>N</ce:italic>
							<ce:inf loc="post">
								<ce:italic>W</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>−
							<ce:hsp sp="0.25"/>1], in the original image 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold> are processed and the resulting indices are transmitted.
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0040" view="all">
					<ce:label>6</ce:label>
					<ce:section-title>The watermarking algorithm for extracting two watermarks</ce:section-title>
					<ce:para id="p0160" view="all">In this section, we describe the corresponding schemes to extract the two embedded watermarks. This is an inverse procedure to the embedding process. We first extract the second embedded watermark and then extract the first embedded one.</ce:para>
					<ce:section id="s0045" view="all">
						<ce:label>6.1</ce:label>
						<ce:section-title>Extracting the second watermark and obtaining the watermarked reconstruction containing 
							<ce:bold>
								<ce:italic>W</ce:italic>
							</ce:bold>
							<ce:inf loc="post">1</ce:inf>
						</ce:section-title>
						<ce:para id="p0165" view="all">At the decoder side in 
							<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>, the first step is to determine the outcome 
							<mml:math altimg="si38.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>B</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> from the received indices 
							<mml:math altimg="si39.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> and 
							<mml:math altimg="si40.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> with the MDSQ decoder by doing the inverse of the index assignment process, 
							<ce:italic>l</ce:italic>
							<ce:sup loc="post">−1</ce:sup>. Then, 
							<mml:math altimg="si41.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>B</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> is shifted to the right by one bit to smooth away the effects of watermark embedding,
							<ce:display>
								<ce:formula id="e0035">
									<ce:label>(7)</ce:label>
									<mml:math altimg="si42.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>S</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>B</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>&gt;</mml:mo>
										<mml:mo>&gt;</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>.</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>Next, the decoder performs a table look-up process on 
							<mml:math altimg="si43.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>S</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> to obtain the codeword 
							<mml:math altimg="si44.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mover accent="true">
												<mml:mrow>
													<mml:mi>c</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mo>˜</mml:mo>
												</mml:mrow>
											</mml:mover>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:mn>0</mml:mn>
									<mml:mo>⩽</mml:mo>
									<mml:mi>i</mml:mi>
									<mml:mo>⩽</mml:mo>
									<mml:mi>L</mml:mi>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
								</mml:mrow>
							</mml:math>. We then find the block 
							<mml:math altimg="si45.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">X</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> that contains the watermark bit 
							<ce:italic>W</ce:italic>
							<ce:inf loc="post">1,
								<ce:italic>k</ce:italic>
							</ce:inf>. By gathering all of the blocks 
							<mml:math altimg="si46.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">X</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>, 0
							<ce:hsp sp="0.25"/>⩽
							<ce:hsp sp="0.25"/>
							<ce:italic>k</ce:italic>
							<ce:hsp sp="0.25"/>⩽
							<ce:hsp sp="0.25"/>
							<ce:italic>M</ce:italic>
							<ce:inf loc="post">
								<ce:italic>W</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>N</ce:italic>
							<ce:inf loc="post">
								<ce:italic>W</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>−
							<ce:hsp sp="0.25"/>1, we obtain the watermarked reconstruction 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>′, which contains the watermark 
							<ce:bold>
								<ce:italic>W</ce:italic>
							</ce:bold>
							<ce:inf loc="post">1</ce:inf>.
						</ce:para>
						<ce:para id="p0170" view="all">When extracting 
							<ce:bold>
								<ce:italic>W</ce:italic>
							</ce:bold>
							<ce:inf loc="post">2</ce:inf>, we perform the estimation using the received indices to determine the value of the watermark bits by using
							<ce:display>
								<ce:formula id="e0040">
									<ce:label>(8)</ce:label>
									<mml:math altimg="si47.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
												<mml:mtext>,</mml:mtext>
												<mml:mi>k</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>B</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
										<mml:mspace width="0.35em"/>
										<mml:mi mathvariant="normal">mod</mml:mi>
										<mml:mspace width="0.35em"/>
										<mml:mn>2</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="1em"/>
										<mml:mi>k</mml:mi>
										<mml:mo>∈</mml:mo>
										<mml:mo stretchy="false">[</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>M</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>N</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>-</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">]</mml:mo>
										<mml:mtext>,</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>where “mod” denotes the modulus operation. The concept for extracting 
							<mml:math altimg="si48.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>W</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
											<mml:mtext>,</mml:mtext>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> is straightforward. At the receiver, with the descriptions received, the index 
							<mml:math altimg="si49.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>B</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> could be estimated with MDC. Next, by performing the inverse operation to the embedding procedure 
							<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>, the last bit in the index 
							<mml:math altimg="si50.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>B</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> is retrieved, which is the operation described in Eq. 
							<ce:cross-ref refid="e0040">(8)</ce:cross-ref>. Because the embedding of the second watermark is carried out by tagging the watermark bit into the index in Eq. 
							<ce:cross-ref refid="e0030">(6)</ce:cross-ref>, we can perform the reverse operation to obtain the extracted watermark bit 
							<mml:math altimg="si51.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>W</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
											<mml:mtext>,</mml:mtext>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>.
						</ce:para>
						<ce:para id="p0175" view="all">
							<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>
							<ce:float-anchor refid="f0035"/> is a demonstration of how 
							<mml:math altimg="si52.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>W</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
											<mml:mtext>,</mml:mtext>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> is extracted. By calculating the conditional probabilities with two descriptions in MDC, one of the following conditions will be satisfied.
							<ce:list id="l0020">
								<ce:list-item id="o0060">
									<ce:label>(1)</ce:label>
									<ce:para id="p0410" view="all">If both descriptions for one block 
										<ce:bold>
											<ce:italic>X</ce:italic>
										</ce:bold>
										<ce:inf loc="post">
											<ce:italic>k</ce:italic>
										</ce:inf> are received, the resulting index decoded using MDSQ can then be determined uniquely as shown in 
										<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>. By visualizing the intersection between the row of the received 
										<mml:math altimg="si53.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mover accent="true">
															<mml:mrow>
																<mml:mi>i</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mo>˜</mml:mo>
															</mml:mrow>
														</mml:mover>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:math>, and the column of the received 
										<mml:math altimg="si54.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mover accent="true">
															<mml:mrow>
																<mml:mi>i</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mo>˜</mml:mo>
															</mml:mrow>
														</mml:mover>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:math>, the estimated watermark bit 
										<mml:math altimg="si55.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>W</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
														<mml:mtext>,</mml:mtext>
														<mml:mi>k</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> is extracted by removing the last bit from 
										<mml:math altimg="si56.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>B</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> using Eq. 
										<ce:cross-ref refid="e0040">(8)</ce:cross-ref>.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0065">
									<ce:label>(2)</ce:label>
									<ce:para id="p0415" view="all">Because of the error concealment capability for index assignment in MDSQ, when only one description is received, the block can be partially reconstructed. The watermark bit must be determined from several possible indices assigned in the MDSQ row or column matrix 
										<ce:cross-ref refid="b0230">[46]</ce:cross-ref>.
										<ce:list id="l0025">
											<ce:list-item id="o0070">
												<ce:label>(a)</ce:label>
												<ce:para id="p0420" view="all">If Channel 1 breaks down, then 
													<mml:math altimg="si57.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mover accent="true">
																		<mml:mrow>
																			<mml:mi>i</mml:mi>
																		</mml:mrow>
																		<mml:mrow>
																			<mml:mo>˜</mml:mo>
																		</mml:mrow>
																	</mml:mover>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:math> will be received. As illustrated in 
													<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>, we choose the column containing 
													<mml:math altimg="si58.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mover accent="true">
																		<mml:mrow>
																			<mml:mi>i</mml:mi>
																		</mml:mrow>
																		<mml:mrow>
																			<mml:mo>˜</mml:mo>
																		</mml:mrow>
																	</mml:mover>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:math> and infer that the transmitted description should be one of the several possible indices in the column. We use a majority vote to estimate the watermark bit 
													<mml:math altimg="si59.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi>W</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																	<mml:mtext>,</mml:mtext>
																	<mml:mi>k</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mo>′</mml:mo>
																</mml:mrow>
															</mml:msubsup>
														</mml:mrow>
													</mml:math> by checking whether the subscripts of the possible indices are odd or even. If there are more odd indices, we set 
													<mml:math altimg="si60.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi>W</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																	<mml:mtext>,</mml:mtext>
																	<mml:mi>k</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mo>′</mml:mo>
																</mml:mrow>
															</mml:msubsup>
															<mml:mo>=</mml:mo>
															<mml:mn>1</mml:mn>
														</mml:mrow>
													</mml:math>. Otherwise, we set 
													<mml:math altimg="si61.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi>W</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																	<mml:mtext>,</mml:mtext>
																	<mml:mi>k</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mo>′</mml:mo>
																</mml:mrow>
															</mml:msubsup>
															<mml:mo>=</mml:mo>
															<mml:mn>0</mml:mn>
														</mml:mrow>
													</mml:math> with the modulus operation in Eq. 
													<ce:cross-ref refid="e0040">(8)</ce:cross-ref>. After checking, if there are equal numbers of 0’s and 1’s in the MDSQ matrix 
													<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>, we randomly assign the watermark bit. Finally, we calculate the conditional expectation from the possible indices, and produce the reconstructed block 
													<mml:math altimg="si62.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi mathvariant="bold-italic">X</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>k</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mo>′</mml:mo>
																</mml:mrow>
															</mml:msubsup>
														</mml:mrow>
													</mml:math>.
												</ce:para>
											</ce:list-item>
											<ce:list-item id="o0075">
												<ce:label>(b)</ce:label>
												<ce:para id="p0425" view="all">If Channel 2 breaks down, then 
													<mml:math altimg="si63.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mover accent="true">
																		<mml:mrow>
																			<mml:mi>i</mml:mi>
																		</mml:mrow>
																		<mml:mrow>
																			<mml:mo>˜</mml:mo>
																		</mml:mrow>
																	</mml:mover>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:math> will be received. By visualizing 
													<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>, we choose the row containing 
													<mml:math altimg="si64.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mover accent="true">
																		<mml:mrow>
																			<mml:mi>i</mml:mi>
																		</mml:mrow>
																		<mml:mrow>
																			<mml:mo>˜</mml:mo>
																		</mml:mrow>
																	</mml:mover>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:math> and infer that the transmitted description should be one of the several possible indices on the row. With the same procedures in the previous case, we can obtain the extracted watermark bit 
													<mml:math altimg="si65.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi>W</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																	<mml:mtext>,</mml:mtext>
																	<mml:mi>k</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mo>′</mml:mo>
																</mml:mrow>
															</mml:msubsup>
														</mml:mrow>
													</mml:math> and the reconstructed block 
													<mml:math altimg="si66.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi mathvariant="bold-italic">X</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>k</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mo>′</mml:mo>
																</mml:mrow>
															</mml:msubsup>
														</mml:mrow>
													</mml:math>.
												</ce:para>
											</ce:list-item>
										</ce:list>
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0080">
									<ce:label>(3)</ce:label>
									<ce:para id="p0430" view="all">If no description is received, the value of the watermark bit 
										<mml:math altimg="si67.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>W</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
														<mml:mtext>,</mml:mtext>
														<mml:mi>k</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> is randomly assigned. With no received information, the block 
										<mml:math altimg="si68.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="bold-italic">X</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>k</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> cannot be reconstructed, and the luminance of every pixel in that block is set to 128, which is the average value of the 8-bit per pixel grey level images.
									</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
						<ce:para id="p0180" view="all">By gathering all of the extracted watermark bits 
							<mml:math altimg="si69.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>W</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
											<mml:mtext>,</mml:mtext>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>, we obtain the extracted watermark 
							<mml:math altimg="si70.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">W</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>. By gathering all of the reconstructed blocks 
							<mml:math altimg="si71.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">X</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>, we obtain the reconstructed image 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>′, which contains the first watermark. We proceed with watermark extraction as shown in Section 
							<ce:cross-ref refid="s0050">6.2</ce:cross-ref> to extract the first watermark embedded from the received descriptions.
						</ce:para>
					</ce:section>
					<ce:section id="s0050" view="all">
						<ce:label>6.2</ce:label>
						<ce:section-title>Extracting the first watermark</ce:section-title>
						<ce:para id="p0185" view="all">After obtaining the codeword 
							<mml:math altimg="si72.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>S</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> in Section 
							<ce:cross-ref refid="s0045">6.1</ce:cross-ref>, we are prepared to extract 
							<ce:bold>
								<ce:italic>W</ce:italic>
							</ce:bold>
							<ce:inf loc="post">1</ce:inf>. Assuming that 
							<mml:math altimg="si73.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>S</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
									<mml:mo>=</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mover accent="true">
												<mml:mrow>
													<mml:mi>c</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mo>˜</mml:mo>
												</mml:mrow>
											</mml:mover>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math>, we examine whether the codeword 
							<mml:math altimg="si74.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mover accent="true">
												<mml:mrow>
													<mml:mi>c</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mo>˜</mml:mo>
												</mml:mrow>
											</mml:mover>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> belongs to the sub-codebook 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>′ or 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>″, and then extract the watermark bit 
							<mml:math altimg="si75.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>W</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
											<mml:mtext>,</mml:mtext>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>. This can be estimated with Eq. 
							<ce:cross-ref refid="e0045">(9)</ce:cross-ref>, which is an inverse operation of Eq. 
							<ce:cross-ref refid="e0025">(5)</ce:cross-ref>:
							<ce:display>
								<ce:formula id="e0045">
									<ce:label>(9)</ce:label>
									<mml:math altimg="si76.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
												<mml:mtext>,</mml:mtext>
												<mml:mi>k</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="{" close="">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="left">
																<mml:mn>0</mml:mn>
																<mml:mtext>,</mml:mtext>
															</mml:mtd>
															<mml:mtd columnalign="left">
																<mml:mtext>if</mml:mtext>
																<mml:mspace width="0.35em"/>
																<mml:msub>
																	<mml:mrow>
																		<mml:mover accent="true">
																			<mml:mrow>
																				<mml:mi>c</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mo>˜</mml:mo>
																			</mml:mrow>
																		</mml:mover>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mo>∈</mml:mo>
																<mml:msup>
																	<mml:mrow>
																		<mml:mi mathvariant="bold-italic">C</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mo>′</mml:mo>
																	</mml:mrow>
																</mml:msup>
																<mml:mtext>,</mml:mtext>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="left">
																<mml:mn>1</mml:mn>
																<mml:mtext>,</mml:mtext>
															</mml:mtd>
															<mml:mtd columnalign="left">
																<mml:mtext>if</mml:mtext>
																<mml:mspace width="0.35em"/>
																<mml:msub>
																	<mml:mrow>
																		<mml:mover accent="true">
																			<mml:mrow>
																				<mml:mi>c</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mo>˜</mml:mo>
																			</mml:mrow>
																		</mml:mover>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mo>∈</mml:mo>
																<mml:msup>
																	<mml:mrow>
																		<mml:mi mathvariant="bold-italic">C</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mo>″</mml:mo>
																	</mml:mrow>
																</mml:msup>
																<mml:mtext>,</mml:mtext>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mspace width="1em"/>
										<mml:mi>i</mml:mi>
										<mml:mo>∈</mml:mo>
										<mml:mo stretchy="false">[</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mi>L</mml:mi>
										<mml:mo>-</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">]</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="1em"/>
										<mml:mi>k</mml:mi>
										<mml:mo>∈</mml:mo>
										<mml:mo stretchy="false">[</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>M</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>N</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>W</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>-</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">]</mml:mo>
										<mml:mtext>.</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>By gathering all of the extracted watermark bits 
							<mml:math altimg="si77.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>W</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
											<mml:mtext>,</mml:mtext>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>, we obtain an estimate of the first embedded watermark 
							<mml:math altimg="si78.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">W</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>.
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0055" view="all">
					<ce:label>7</ce:label>
					<ce:section-title>An example for watermarking in Section 
						<ce:cross-ref refid="s0025">5</ce:cross-ref> and Section 
						<ce:cross-ref refid="s0040">6</ce:cross-ref>
					</ce:section-title>
					<ce:para id="p0190" view="all">
						<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref> is the example that follows 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(b). Here the codebook size is 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>8, and each codeword is 3-bit in length. Consequently, when using the watermarking scheme in Eq. 
						<ce:cross-ref refid="e0030">(6)</ce:cross-ref>, 
						<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref> is a direct extension of 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>(b). This is because each watermarked codeword is 4 bits in length. By following conventional VQ techniques, the codebook with a size of 2
						<ce:sup loc="post">4</ce:sup>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>2
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>16 is trained in advance to deal with watermark embedding. From another perspective, for watermarking purposes, the effective size of the codebook for reconstructing the compressed image is halved. The watermarked image quality with MDC should be somewhat degraded.
					</ce:para>
					<ce:para id="p0195" view="all">In this example, the original image 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold> employed has a size of 512
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>512, and the two watermarks, 
						<ce:bold>
							<ce:italic>W</ce:italic>
						</ce:bold>
						<ce:inf loc="post">1</ce:inf> and 
						<ce:bold>
							<ce:italic>W</ce:italic>
						</ce:bold>
						<ce:inf loc="post">2</ce:inf> both have sizes 128
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>128. With VQ encoding, the original image is divided into 4
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>4 blocks 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf>, 
						<mml:math altimg="si79.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mi>k</mml:mi>
								<mml:mo>∈</mml:mo>
								<mml:mrow>
									<mml:mfenced open="[" close="]">
										<mml:mrow>
											<mml:mn>0</mml:mn>
											<mml:mtext>,</mml:mtext>
											<mml:mfrac>
												<mml:mrow>
													<mml:mn>512</mml:mn>
													<mml:mo>×</mml:mo>
													<mml:mn>512</mml:mn>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>4</mml:mn>
													<mml:mo>×</mml:mo>
													<mml:mn>4</mml:mn>
												</mml:mrow>
											</mml:mfrac>
											<mml:mo>-</mml:mo>
											<mml:mn>1</mml:mn>
										</mml:mrow>
									</mml:mfenced>
								</mml:mrow>
							</mml:mrow>
						</mml:math>, and each block is represented by one codeword 
						<ce:italic>c</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf>, where 
						<ce:italic>i</ce:italic>
						<ce:hsp sp="0.25"/>∈
						<ce:hsp sp="0.25"/>[0,
						<ce:hsp sp="0.12"/>
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>−
						<ce:hsp sp="0.25"/>1]. For watermarking, two bits can be embedded into one block, one from 
						<ce:bold>
							<ce:italic>W</ce:italic>
						</ce:bold>
						<ce:inf loc="post">1</ce:inf> and the other from 
						<ce:bold>
							<ce:italic>W</ce:italic>
						</ce:bold>
						<ce:inf loc="post">2</ce:inf>.
					</ce:para>
					<ce:para id="p0200" view="all">Without loss of generality, we assume that 
						<ce:italic>W</ce:italic>
						<ce:inf loc="post">1,
							<ce:italic>k</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0 and 
						<ce:italic>W</ce:italic>
						<ce:inf loc="post">2,
							<ce:italic>k</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1 are the two watermark bits to be embedded into 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>
						<ce:inf loc="post">
							<ce:italic>k</ce:italic>
						</ce:inf>. With the algorithm given in Section 
						<ce:cross-ref refid="s0030">5.1</ce:cross-ref> and Eq. 
						<ce:cross-ref refid="e0025">(5)</ce:cross-ref>, and after searching for the nearest codeword in 
						<ce:bold>
							<ce:italic>C</ce:italic>
						</ce:bold>′, we conclude that the resulting codeword containing the first watermark is 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">
							<ce:italic>S</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>101. According to Eq. 
						<ce:cross-ref refid="e0030">(6)</ce:cross-ref>, we embed the second watermark and obtain 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">
							<ce:italic>B</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1011. Because the binary form of 1011 has a decimal form of 19, we conclude that 
						<ce:italic>j</ce:italic>
						<ce:inf loc="post">19</ce:inf> is the codeword to be transmitted in 
						<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>. Referring to 
						<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>, the two descriptions for transmission are 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">1</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0110 and 
						<ce:italic>i</ce:italic>
						<ce:inf loc="post">2</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0111.
					</ce:para>
					<ce:para id="p0205" view="all">To extract the watermark using both descriptions, or 
						<ce:italic>P</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>2 in 
						<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref>, there are four possible cases.
						<ce:list id="l0030">
							<ce:list-item id="o0085">
								<ce:label>(1)</ce:label>
								<ce:para id="p0435" view="all">If both descriptions are received, then 
									<ce:italic>i</ce:italic>
									<ce:inf loc="post">1</ce:inf>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>0110 and 
									<ce:italic>i</ce:italic>
									<ce:inf loc="post">2</ce:inf>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>0111 can be used to extract the watermark bit 
									<ce:italic>W</ce:italic>
									<ce:inf loc="post">2,
										<ce:italic>k</ce:italic>
									</ce:inf> and reconstruct the image. By performing the inverse operation of index assignment 
									<ce:italic>l</ce:italic>
									<ce:sup loc="post">−1</ce:sup> in Eq. 
									<ce:cross-ref refid="e0005">(1)</ce:cross-ref> and computing the conditional probability, we can determine exactly that the codeword 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">19</ce:inf> is transmitted with a probability of 1.0, and thus, the watermark bit is 
									<ce:italic>W</ce:italic>
									<ce:inf loc="post">2,
										<ce:italic>k</ce:italic>
									</ce:inf>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>1. In reconstructing the block from the received descriptions, we use the look-up table, and determine 
									<mml:math altimg="si80.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msubsup>
												<mml:mrow>
													<mml:mover accent="true">
														<mml:mrow>
															<mml:mi mathvariant="bold-italic">X</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mo stretchy="true">^</mml:mo>
														</mml:mrow>
													</mml:mover>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>k</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mn>0</mml:mn>
													<mml:mo stretchy="false">)</mml:mo>
												</mml:mrow>
											</mml:msubsup>
											<mml:mo>=</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>19</mml:mn>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:math>. We employ the spatial domain representations of 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">19</ce:inf> to represent the reconstructed block 
									<mml:math altimg="si81.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msubsup>
												<mml:mrow>
													<mml:mi mathvariant="bold-italic">X</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>k</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mo>′</mml:mo>
												</mml:mrow>
											</mml:msubsup>
										</mml:mrow>
									</mml:math>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0090">
								<ce:label>(2)</ce:label>
								<ce:para id="p0440" view="all">If Channel 1 breaks down, then only 
									<ce:italic>i</ce:italic>
									<ce:inf loc="post">2</ce:inf>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>0111 is received. By performing the inverse operation of the index assignment 
									<ce:italic>l</ce:italic>
									<ce:sup loc="post">−1</ce:sup>, we find that 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">19</ce:inf>, 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">21</ce:inf>, and 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">23</ce:inf> are the three possible candidates transmitted. Because 19, 21, and 23 are odd numbers, and by using a majority vote, the embedded bit can be estimated as 
									<ce:italic>W</ce:italic>
									<ce:inf loc="post">2,
										<ce:italic>k</ce:italic>
									</ce:inf>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>1. In reconstructing the received image, we need to calculate the conditional probability using the given conditions:
									<ce:display>
										<ce:formula id="e0050">
											<ce:label>(10)</ce:label>
											<mml:math altimg="si82.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
												<mml:mi>p</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>t</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">|</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:msub>
												<mml:mo>=</mml:mo>
												<mml:mn>0111</mml:mn>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>=</mml:mo>
												<mml:mrow>
													<mml:mfenced open="{" close="">
														<mml:mrow>
															<mml:mtable>
																<mml:mtr>
																	<mml:mtd columnalign="left">
																		<mml:mfrac>
																			<mml:mrow>
																				<mml:mn>1</mml:mn>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mn>2</mml:mn>
																				<mml:mi>m</mml:mi>
																				<mml:mo>+</mml:mo>
																				<mml:mn>1</mml:mn>
																			</mml:mrow>
																		</mml:mfrac>
																		<mml:mtext>,</mml:mtext>
																	</mml:mtd>
																	<mml:mtd columnalign="left">
																		<mml:mtext>if</mml:mtext>
																		<mml:mspace width="0.35em"/>
																		<mml:mi>t</mml:mi>
																		<mml:mo>=</mml:mo>
																		<mml:mn>19</mml:mn>
																		<mml:mspace width="0.35em"/>
																		<mml:mtext>or</mml:mtext>
																		<mml:mspace width="0.35em"/>
																		<mml:mn>21</mml:mn>
																		<mml:mspace width="0.35em"/>
																		<mml:mtext>or</mml:mtext>
																		<mml:mspace width="0.35em"/>
																		<mml:mn>23</mml:mn>
																		<mml:mtext>,</mml:mtext>
																	</mml:mtd>
																</mml:mtr>
																<mml:mtr>
																	<mml:mtd columnalign="left">
																		<mml:mn>0</mml:mn>
																		<mml:mtext>,</mml:mtext>
																	</mml:mtd>
																	<mml:mtd columnalign="left">
																		<mml:mtext>otherwise.</mml:mtext>
																	</mml:mtd>
																</mml:mtr>
															</mml:mtable>
														</mml:mrow>
													</mml:mfenced>
												</mml:mrow>
											</mml:math>
										</ce:formula>
									</ce:display>where 
									<ce:italic>m</ce:italic> denotes the spread. Here, we set 
									<ce:italic>m</ce:italic>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>1. Thus, with Eq. 
									<ce:cross-ref refid="e0050">(10)</ce:cross-ref>, the reconstructed vector is the conditional expectation, represented by 
									<mml:math altimg="si83.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msubsup>
												<mml:mrow>
													<mml:mover accent="true">
														<mml:mrow>
															<mml:mi mathvariant="bold-italic">X</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mo stretchy="true">^</mml:mo>
														</mml:mrow>
													</mml:mover>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>k</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mn>2</mml:mn>
													<mml:mo stretchy="false">)</mml:mo>
												</mml:mrow>
											</mml:msubsup>
											<mml:mo>=</mml:mo>
											<mml:mfrac>
												<mml:mrow>
													<mml:mn>1</mml:mn>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>3</mml:mn>
												</mml:mrow>
											</mml:mfrac>
											<mml:mo stretchy="false">(</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>19</mml:mn>
												</mml:mrow>
											</mml:msub>
											<mml:mo>+</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>21</mml:mn>
												</mml:mrow>
											</mml:msub>
											<mml:mo>+</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>23</mml:mn>
												</mml:mrow>
											</mml:msub>
											<mml:mo stretchy="false">)</mml:mo>
											<mml:mtext>.</mml:mtext>
										</mml:mrow>
									</mml:math> We use the spatial domain representations of 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">19</ce:inf>, 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">21</ce:inf>, and 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">23</ce:inf> to calculate their average to complete the reconstruction of 
									<mml:math altimg="si84.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msup>
												<mml:mrow>
													<mml:mover accent="true">
														<mml:mrow>
															<mml:mi mathvariant="bold-italic">X</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mo stretchy="true">^</mml:mo>
														</mml:mrow>
													</mml:mover>
												</mml:mrow>
												<mml:mrow>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mn>2</mml:mn>
													<mml:mo stretchy="false">)</mml:mo>
												</mml:mrow>
											</mml:msup>
										</mml:mrow>
									</mml:math>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0095">
								<ce:label>(3)</ce:label>
								<ce:para id="p0445" view="all">If Channel 2 breaks down, then only 
									<ce:italic>i</ce:italic>
									<ce:inf loc="post">1</ce:inf>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>0110 is received. By computing the inverse operation of index assignment, we find that 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">17</ce:inf>, 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">18</ce:inf>, and 
									<ce:italic>j</ce:italic>
									<ce:inf loc="post">19</ce:inf> are the three possible candidates transmitted. Using a majority vote, the embedded bit can be estimated to be 
									<ce:italic>W</ce:italic>
									<ce:inf loc="post">2,
										<ce:italic>k</ce:italic>
									</ce:inf>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>1. In some situations where there are two candidates, we use random selection to determine the watermark bit. In reconstructing the received image, we need to calculate the conditional probability at the given conditions:
									<ce:display>
										<ce:formula id="e0055">
											<ce:label>(11)</ce:label>
											<mml:math altimg="si85.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
												<mml:mi>p</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>t</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">|</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msub>
												<mml:mo>=</mml:mo>
												<mml:mn>0110</mml:mn>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>=</mml:mo>
												<mml:mrow>
													<mml:mfenced open="{" close="">
														<mml:mrow>
															<mml:mtable>
																<mml:mtr>
																	<mml:mtd columnalign="left">
																		<mml:mfrac>
																			<mml:mrow>
																				<mml:mn>1</mml:mn>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mn>2</mml:mn>
																				<mml:mi>m</mml:mi>
																				<mml:mo>+</mml:mo>
																				<mml:mn>1</mml:mn>
																			</mml:mrow>
																		</mml:mfrac>
																		<mml:mtext>,</mml:mtext>
																	</mml:mtd>
																	<mml:mtd columnalign="left">
																		<mml:mtext>if</mml:mtext>
																		<mml:mspace width="0.35em"/>
																		<mml:mi>t</mml:mi>
																		<mml:mo>=</mml:mo>
																		<mml:mn>17</mml:mn>
																		<mml:mspace width="0.35em"/>
																		<mml:mtext>or</mml:mtext>
																		<mml:mspace width="0.35em"/>
																		<mml:mn>18</mml:mn>
																		<mml:mspace width="0.35em"/>
																		<mml:mtext>or</mml:mtext>
																		<mml:mspace width="0.35em"/>
																		<mml:mn>19</mml:mn>
																		<mml:mtext>,</mml:mtext>
																	</mml:mtd>
																</mml:mtr>
																<mml:mtr>
																	<mml:mtd columnalign="left">
																		<mml:mn>0</mml:mn>
																		<mml:mtext>,</mml:mtext>
																	</mml:mtd>
																	<mml:mtd columnalign="left">
																		<mml:mtext>otherwise.</mml:mtext>
																	</mml:mtd>
																</mml:mtr>
															</mml:mtable>
														</mml:mrow>
													</mml:mfenced>
												</mml:mrow>
											</mml:math>
										</ce:formula>
									</ce:display>Again, 
									<ce:italic>m</ce:italic> denotes the spread, and we set 
									<ce:italic>m</ce:italic>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>1 here. Thus, with Eq. 
									<ce:cross-ref refid="e0055">(11)</ce:cross-ref>, the reconstructed vector is the conditional expectation represented by 
									<mml:math altimg="si86.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msubsup>
												<mml:mrow>
													<mml:mover accent="true">
														<mml:mrow>
															<mml:mi mathvariant="bold-italic">X</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mo stretchy="true">^</mml:mo>
														</mml:mrow>
													</mml:mover>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>k</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mn>1</mml:mn>
													<mml:mo stretchy="false">)</mml:mo>
												</mml:mrow>
											</mml:msubsup>
											<mml:mo>=</mml:mo>
											<mml:mfrac>
												<mml:mrow>
													<mml:mn>1</mml:mn>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>3</mml:mn>
												</mml:mrow>
											</mml:mfrac>
											<mml:mo stretchy="false">(</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>17</mml:mn>
												</mml:mrow>
											</mml:msub>
											<mml:mo>+</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>18</mml:mn>
												</mml:mrow>
											</mml:msub>
											<mml:mo>+</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mn>19</mml:mn>
												</mml:mrow>
											</mml:msub>
											<mml:mo stretchy="false">)</mml:mo>
										</mml:mrow>
									</mml:math>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0100">
								<ce:label>(4)</ce:label>
								<ce:para id="p0450" view="all">If both channels break down, no description is received. We randomly choose ‘0’ or ‘1’ to represent the extracted watermark bit 
									<ce:italic>W</ce:italic>
									<ce:inf loc="post">2,
										<ce:italic>k</ce:italic>
									</ce:inf>. In addition, because no description is received, nothing can be reconstructed, and therefore, we set the luminance of every pixel in that block to 128 for the 8-bit per pixel grey level images.
								</ce:para>
							</ce:list-item>
						</ce:list>
					</ce:para>
				</ce:section>
				<ce:section id="s0060" view="all">
					<ce:label>8</ce:label>
					<ce:section-title>Optimization with tabu search</ce:section-title>
					<ce:section id="s0065" view="all">
						<ce:label>8.1</ce:label>
						<ce:section-title>Tabu search fundamentals</ce:section-title>
						<ce:para id="p0210" view="all">Tabu search is a meta-heuristic approach, characterized by the use of a flexible memory. It is able to escape local minima and to search areas beyond a local minimum 
							<ce:cross-refs refid="b0045 b0070">[9,14]</ce:cross-refs>.
						</ce:para>
						<ce:para id="p0215" view="all">Tabu search overcomes the local optima problem by using an evaluation function, or a fitness function, that chooses the highest evaluation solution at each iteration. The building blocks of tabu search are stated as follows:
							<ce:list id="l0035">
								<ce:list-item id="o0105">
									<ce:label>
										<ce:bold>
											<ce:italic>Forbidding strategy:</ce:italic>
										</ce:bold>
									</ce:label>
									<ce:para id="p0455" view="all">This strategy is employed to avoid cycling problems by classifying certain moves as forbidden, or 
										<ce:italic>tabu</ce:italic>. To prevent the cycling problem, it is sufficient to check whether a solution has been previously visited. Alternatively, this can be approximated by whether the solution has been visited during the last 
										<ce:italic>T</ce:italic>
										<ce:inf loc="post">
											<ce:italic>S</ce:italic>
										</ce:inf> iterations. 
										<ce:italic>T</ce:italic>
										<ce:inf loc="post">
											<ce:italic>S</ce:italic>
										</ce:inf> is normally named the 
										<ce:italic>tabu list length</ce:italic> or 
										<ce:italic>tabu list size</ce:italic>. With the help of an appropriate value of 
										<ce:italic>T</ce:italic>
										<ce:inf loc="post">
											<ce:italic>S</ce:italic>
										</ce:inf>, the likelihood of cycling effectively vanishes.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0110">
									<ce:label>
										<ce:bold>
											<ce:italic>Aspiration criteria and tabu restrictions:</ce:italic>
										</ce:bold>
									</ce:label>
									<ce:para id="p0460" view="all">An aspiration criterion is applied to make a tabu solution that is not a forbidden state. Each solution must be of sufficient quality and able to prevent cycling. A solution is acceptable if the tabu restrictions are satisfied. However, a tabu solution is also assumed acceptable if an aspiration criterion applies, regardless of the tabu status. We also make use of tabu restrictions to avoid repetitions but not reversals. A tabu restriction is typically activated only when its attributes occur within a limited number of iterations prior to the present iteration, or if they have occurred with a certain frequency over a larger number of iterations. The appropriate use of aspiration criteria can significantly improve the performance of a tabu search.</ce:para>
								</ce:list-item>
								<ce:list-item id="o0115">
									<ce:label>
										<ce:bold>
											<ce:italic>Freeing strategy:</ce:italic>
										</ce:bold>
									</ce:label>
									<ce:para id="p0465" view="all">The freeing strategy is used to decide which solutions can be removed from the tabu list. This strategy removes tabu restrictions of the solutions so that they can be reconsidered during future steps of the search. The attributes of a tabu solution remain on the tabu list for a duration of 
										<ce:italic>T</ce:italic>
										<ce:inf loc="post">
											<ce:italic>S</ce:italic>
										</ce:inf> iterations.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0120">
									<ce:label>
										<ce:bold>
											<ce:italic>Intermediate and long-term learning strategies:</ce:italic>
										</ce:bold>
									</ce:label>
									<ce:para id="p0470" view="all">These strategies are implemented with intermediate and long-term memory functions. Their operations are to record good features of a selected number of moves generated during the execution of the algorithm.</ce:para>
								</ce:list-item>
								<ce:list-item id="o0125">
									<ce:label>
										<ce:bold>
											<ce:italic>Short-term strategy or overall strategy:</ce:italic>
										</ce:bold>
									</ce:label>
									<ce:para id="p0475" view="all">This strategy manages the interplay between the different strategies listed above. A candidate list is a sub-list of the possible moves which are generally problem dependent.</ce:para>
								</ce:list-item>
								<ce:list-item id="o0130">
									<ce:label>
										<ce:bold>
											<ce:italic>The best-solution strategy:</ce:italic>
										</ce:bold>
									</ce:label>
									<ce:para id="p0480" view="all">This strategy selects an admissible solution from the current solutions if it yields the greatest improvement or the least distortion in the cost function, provided that the tabu restrictions and aspiration criteria are satisfied.</ce:para>
								</ce:list-item>
								<ce:list-item id="o0135">
									<ce:label>
										<ce:bold>
											<ce:italic>Termination:</ce:italic>
										</ce:bold>
									</ce:label>
									<ce:para id="p0485" view="all">A stopping criterion terminates the tabu search procedure either after a specified number of iterations, or if the currently best solution has not improved for a given number of iterations.</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
						<ce:para id="p0220" view="all">Using the background information presented in this section, we are able to apply the tabu search algorithm to digital watermarking to obtain an optimized outcome between watermark imperceptibility and watermark robustness.</ce:para>
					</ce:section>
					<ce:section id="s0070" view="all">
						<ce:label>8.2</ce:label>
						<ce:section-title>Watermarking with tabu search</ce:section-title>
						<ce:para id="p0225" view="all">In Section 
							<ce:cross-ref refid="s0030">5.1</ce:cross-ref>, the main problem when embedding the first watermark is how to split the codebook 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> into two sub-codebooks 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>′ and 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>″. The result for splitting 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> will not only influence the watermark imperceptibility and the robustness of the first watermark, but it will also affect the robustness of the second watermark. All of the problems can be optimized using tabu search 
							<ce:cross-ref refid="b0045">[9]</ce:cross-ref> by offering the properly chosen fitness function. Using the fundamentals of tabu search described in Section 
							<ce:cross-ref refid="s0065">8.1</ce:cross-ref>, and the watermarking requirements described in Section 
							<ce:cross-ref refid="s0005">1</ce:cross-ref>, we can consider both the imperceptibility of the watermarked image, represented by Peak Signal-to-Noise Ratio (PSNR), and the robustness of the extracted watermarks, represented by Bit Correct Rates (BCR), for optimization. The fitness function with this system is:
							<ce:display>
								<ce:formula id="e0060">
									<ce:label>(12)</ce:label>
									<mml:math altimg="si87.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi>f</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mtext>PSNR</mml:mtext>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>λ</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mtext>BCR</mml:mtext>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
												<mml:mtext>,</mml:mtext>
												<mml:mi>i</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>λ</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mtext>BCR</mml:mtext>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
												<mml:mtext>,</mml:mtext>
												<mml:mi>i</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>where, 
							<ce:italic>f</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf> denotes the fitness score in the 
							<ce:italic>i</ce:italic>th iteration, PSNR
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>,BCR
							<ce:inf loc="post">1,
								<ce:italic>i</ce:italic>
							</ce:inf> and BCR
							<ce:inf loc="post">2,
								<ce:italic>i</ce:italic>
							</ce:inf> denote Peak Signal-to-Noise Ratio (PSNR) of the watermarked image, and Bit Correct Rates (BCR) of the two extracted watermarks, respectively. Objectively, higher PSNR values lead to better imperceptibility, and higher BCR values lead to better robustness. Thus, the goal for optimization is to maximize the fitness score 
							<ce:italic>f</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>.
						</ce:para>
						<ce:para id="p0230" view="all">Because the PSNR values are generally many times larger than the BCR values, we include 
							<ce:italic>λ</ce:italic>
							<ce:inf loc="post">1</ce:inf> and 
							<ce:italic>λ</ce:italic>
							<ce:inf loc="post">2</ce:inf> to represent the weighting factors to balance the effects of PSNR and BCR. The objective is to maximize 
							<ce:italic>f</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf> in our watermarking system. The PSNR in the 
							<ce:italic>i</ce:italic>th iteration between the original and watermarked images can be represented by
							<ce:display>
								<ce:formula id="e0065">
									<ce:label>(13)</ce:label>
									<mml:math altimg="si88.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mtext>PSNR</mml:mtext>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mn>10</mml:mn>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="normal">log</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>10</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mrow>
											<mml:mfenced open="(" close=")">
												<mml:mrow>
													<mml:mfrac>
														<mml:mrow>
															<mml:msup>
																<mml:mrow>
																	<mml:mn>255</mml:mn>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																</mml:mrow>
															</mml:msup>
														</mml:mrow>
														<mml:mrow>
															<mml:mfrac>
																<mml:mrow>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>M</mml:mi>
																	<mml:mo>·</mml:mo>
																	<mml:mi>N</mml:mi>
																</mml:mrow>
															</mml:mfrac>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mo>∑</mml:mo>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>m</mml:mi>
																	<mml:mo>=</mml:mo>
																	<mml:mn>0</mml:mn>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>M</mml:mi>
																	<mml:mo>-</mml:mo>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
															</mml:msubsup>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mo>∑</mml:mo>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>n</mml:mi>
																	<mml:mo>=</mml:mo>
																	<mml:mn>0</mml:mn>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>N</mml:mi>
																	<mml:mo>-</mml:mo>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
															</mml:msubsup>
															<mml:msup>
																<mml:mrow>
																	<mml:mfenced open="(" close=")">
																		<mml:mrow>
																			<mml:mi>X</mml:mi>
																			<mml:mo stretchy="false">(</mml:mo>
																			<mml:mi>m</mml:mi>
																			<mml:mtext>,</mml:mtext>
																			<mml:mi>n</mml:mi>
																			<mml:mo stretchy="false">)</mml:mo>
																			<mml:mo>-</mml:mo>
																			<mml:msubsup>
																				<mml:mrow>
																					<mml:mi>X</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>i</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mo>′</mml:mo>
																				</mml:mrow>
																			</mml:msubsup>
																			<mml:mo stretchy="false">(</mml:mo>
																			<mml:mi>m</mml:mi>
																			<mml:mtext>,</mml:mtext>
																			<mml:mi>n</mml:mi>
																			<mml:mo stretchy="false">)</mml:mo>
																		</mml:mrow>
																	</mml:mfenced>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																</mml:mrow>
															</mml:msup>
														</mml:mrow>
													</mml:mfrac>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mtext>,</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>where 
							<ce:italic>X</ce:italic>(
							<ce:italic>m</ce:italic>,
							<ce:hsp sp="0.12"/>
							<ce:italic>n</ce:italic>) and 
							<mml:math altimg="si89.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>X</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>m</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>n</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
								</mml:mrow>
							</mml:math> denote the pixel values at position (
							<ce:italic>m</ce:italic>,
							<ce:hsp sp="0.12"/>
							<ce:italic>n</ce:italic>) of the original image 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold> and the watermarked image 
							<mml:math altimg="si90.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">X</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> in the 
							<ce:italic>i</ce:italic>th iteration, where 
							<ce:italic>M</ce:italic>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>N</ce:italic> denotes the image size. The BCR between the embedded and extracted watermarks can be defined by
							<ce:display>
								<ce:formula id="e0070">
									<ce:label>(14)</ce:label>
									<mml:math altimg="si91.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mtext>BCR</mml:mtext>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="(" close=")">
												<mml:mrow>
													<mml:mfrac>
														<mml:mrow>
															<mml:mn>1</mml:mn>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>M</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>W</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>·</mml:mo>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>N</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>W</mml:mi>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:mfrac>
													<mml:munderover>
														<mml:mrow>
															<mml:mo>∑</mml:mo>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>b</mml:mi>
															<mml:mo>=</mml:mo>
															<mml:mn>0</mml:mn>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>M</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>W</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>·</mml:mo>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>N</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>W</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>-</mml:mo>
															<mml:mn>1</mml:mn>
														</mml:mrow>
													</mml:munderover>
													<mml:mover accent="true">
														<mml:mrow>
															<mml:mrow>
																<mml:mfenced open="(" close=")">
																	<mml:mrow>
																		<mml:msub>
																			<mml:mrow>
																				<mml:mi>w</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mi>b</mml:mi>
																				<mml:mtext>,</mml:mtext>
																				<mml:mi>i</mml:mi>
																			</mml:mrow>
																		</mml:msub>
																		<mml:mi>⊕</mml:mi>
																		<mml:msubsup>
																			<mml:mrow>
																				<mml:mi>w</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mi>b</mml:mi>
																				<mml:mtext>,</mml:mtext>
																				<mml:mi>i</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mo>′</mml:mo>
																			</mml:mrow>
																		</mml:msubsup>
																	</mml:mrow>
																</mml:mfenced>
															</mml:mrow>
														</mml:mrow>
														<mml:mrow>
															<mml:mo stretchy="true">¯</mml:mo>
														</mml:mrow>
													</mml:mover>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mo>·</mml:mo>
										<mml:mn>100</mml:mn>
										<mml:mo>%</mml:mo>
										<mml:mtext>,</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>where 
							<ce:italic>w</ce:italic>
							<ce:inf loc="post">
								<ce:italic>b</ce:italic>,
								<ce:italic>i</ce:italic>
							</ce:inf> and 
							<mml:math altimg="si92.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi>w</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>b</mml:mi>
											<mml:mtext>,</mml:mtext>
											<mml:mi>i</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> represent the embedded watermark bit and the extracted one in the 
							<ce:italic>i</ce:italic>th iteration, 
							<ce:italic>M</ce:italic>
							<ce:inf loc="post">
								<ce:italic>W</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>N</ce:italic>
							<ce:inf loc="post">
								<ce:italic>W</ce:italic>
							</ce:inf> denotes the watermark size, ⊕ indicates the “exclusive-or operation,” and the line above the exclusive-or operation means the “not” operation in logic design.
						</ce:para>
						<ce:para id="p0235" view="all">Given the preliminaries in Section 
							<ce:cross-ref refid="s0005">1</ce:cross-ref>, we fix the watermark capacity so that both the watermark imperceptibility and watermark robustness improve after tabu search optimization. The parameters employed in the tabu search are:
							<ce:list id="l0005">
								<ce:list-item id="o0005">
									<ce:label>•</ce:label>
									<ce:para id="p0355" view="all">there are 20 candidate solutions trained for each iteration;</ce:para>
								</ce:list-item>
								<ce:list-item id="o0010">
									<ce:label>•</ce:label>
									<ce:para id="p0360" view="all">the tabu list length 
										<ce:italic>T</ce:italic>
										<ce:inf loc="post">
											<ce:italic>S</ce:italic>
										</ce:inf> is set to 10;
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0015">
									<ce:label>•</ce:label>
									<ce:para id="p0365" view="all">the weighting factors are set to 
										<ce:italic>λ</ce:italic>
										<ce:inf loc="post">1</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>
										<ce:italic>λ</ce:italic>
										<ce:inf loc="post">2</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>10;
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0020">
									<ce:label>•</ce:label>
									<ce:para id="p0370" view="all">the aspiration value is set to 40, with PSNR
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>⩾
										<ce:hsp sp="0.25"/>26, BCR
										<ce:inf loc="post">1,
											<ce:italic>i</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>⩾
										<ce:hsp sp="0.25"/>0.7, and BCR
										<ce:inf loc="post">2,
											<ce:italic>i</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>⩾
										<ce:hsp sp="0.25"/>0.7 in Eq. 
										<ce:cross-ref refid="e0060">(12)</ce:cross-ref>;
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0025">
									<ce:label>•</ce:label>
									<ce:para id="p0375" view="all">watermark embedding and extraction are performed in every training iteration to obtain the updated PSNR
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>+1
										</ce:inf>, BCR
										<ce:inf loc="post">1,
											<ce:italic>i</ce:italic>+1
										</ce:inf>, and BCR
										<ce:inf loc="post">2,
											<ce:italic>i</ce:italic>+1
										</ce:inf> for the next iteration;
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0030">
									<ce:label>•</ce:label>
									<ce:para id="p0380" view="all">the number of total training iterations is set to 100.</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
						<ce:para id="p0240" view="all">The above parameters are chosen carefully. In this paper, we choose 20 candidates for training with tabu search. After considering the computation time, the memory consumption, and the convergence rate in tabu search, we choose 20 candidates for each training iteration based on the fitness function. If we choose too many candidates, the computation time per iteration will increase and memory allocation might become a problem. In contrast, if we choose too few candidates, the output result might only be a locally optimal one, which is a problem generally encountered in optimization. We have found 20 candidates to be a reasonable number for training with tabu search.</ce:para>
						<ce:para id="p0245" view="all">Moreover, we set the tabu list length 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>S</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>10 by considering the tradeoff between the computation time and the convergence rate in the optimization process. We also discovered that PSNR values are many times larger than the BCR values. To compensate for this, we use the weighting factors, 
							<ce:italic>λ</ce:italic>
							<ce:inf loc="post">1</ce:inf> and 
							<ce:italic>λ</ce:italic>
							<ce:inf loc="post">2</ce:inf>, which need to be included in Eq. 
							<ce:cross-ref refid="e0060">(12)</ce:cross-ref>, the fitness function, to weight the effects from the PSNR, representing the image quality, and the BCR, representing the watermark robustness.
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0075" view="all">
					<ce:label>9</ce:label>
					<ce:section-title>Other related watermarking algorithms</ce:section-title>
					<ce:para id="p0250" view="all">To demonstrate the effectiveness of the proposed algorithm, we compare two VQ-based watermarking algorithms reported in the literature. After searching major databases, we found that VQ-based watermarking constitutes about 2% of the total paper counts among all watermarking-related papers since the mid-1990s. The two papers here were carefully chosen for comparison with our proposed algorithm. The two watermarking algorithms are described as follows.</ce:para>
					<ce:section id="s0080" view="all">
						<ce:label>9.1</ce:label>
						<ce:section-title>Review of watermarking algorithm in 
							<ce:cross-ref refid="b0135">[27]</ce:cross-ref>
						</ce:section-title>
						<ce:para id="p0255" view="all">The algorithm in 
							<ce:cross-ref refid="b0135">[27]</ce:cross-ref> is one of the pioneering VQ-based watermarking methods proposed in literature. The authors trained the codebook 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> with a size of 
							<ce:italic>L</ce:italic> in advance. Then, 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> is partitioned into 
							<ce:italic>N</ce:italic> groups, {
							<ce:bold>
								<ce:italic>G</ce:italic>
							</ce:bold>
							<ce:inf loc="post">0</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:bold>
								<ce:italic>G</ce:italic>
							</ce:bold>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:bold>
								<ce:italic>G</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>N</ce:italic>−1
							</ce:inf>}, where
							<ce:list id="l0040">
								<ce:list-item id="o0140">
									<ce:label>(1)</ce:label>
									<ce:para id="p0490" view="all">
										<mml:math altimg="si93.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">C</mml:mi>
												<mml:mo>=</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mo>⋃</mml:mo>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
														<mml:mo>=</mml:mo>
														<mml:mn>0</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>N</mml:mi>
														<mml:mo>-</mml:mo>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msubsup>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="bold-italic">G</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:math>;
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0145">
									<ce:label>(2)</ce:label>
									<ce:para id="p0495" view="all">
										<mml:math altimg="si94.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>⋂</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
														<mml:mo>=</mml:mo>
														<mml:mn>0</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>N</mml:mi>
														<mml:mo>-</mml:mo>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msubsup>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="bold-italic">G</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo>=</mml:mo>
												<mml:mo>∅</mml:mo>
											</mml:mrow>
										</mml:math>;
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0150">
									<ce:label>(3)</ce:label>
									<ce:para id="p0500" view="all">
										<mml:math altimg="si95.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="bold-italic">G</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo>=</mml:mo>
												<mml:mo stretchy="false">{</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="bold-italic">c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>0</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
												</mml:msubsup>
												<mml:mtext>,</mml:mtext>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="bold-italic">c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
												</mml:msubsup>
												<mml:mo stretchy="false">}</mml:mo>
												<mml:mtext>,</mml:mtext>
												<mml:mi>i</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mo stretchy="false">[</mml:mo>
												<mml:mn>0</mml:mn>
												<mml:mtext>,</mml:mtext>
												<mml:mi>N</mml:mi>
												<mml:mo>-</mml:mo>
												<mml:mn>1</mml:mn>
												<mml:mo stretchy="false">]</mml:mo>
											</mml:mrow>
										</mml:math>.
									</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
						<ce:para id="p0260" view="all">For a given input vector 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf>, we assume that the codeword 
							<mml:math altimg="si96.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">c</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>t</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>p</mml:mi>
										</mml:mrow>
									</mml:msubsup>
									<mml:mo>∈</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">G</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>p</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:mi>p</mml:mi>
									<mml:mo>∈</mml:mo>
									<mml:mo stretchy="false">[</mml:mo>
									<mml:mn>0</mml:mn>
									<mml:mtext>,</mml:mtext>
									<mml:mi>N</mml:mi>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo stretchy="false">]</mml:mo>
									<mml:mtext>,</mml:mtext>
									<mml:mi>t</mml:mi>
									<mml:mo>∈</mml:mo>
									<mml:mo stretchy="false">{</mml:mo>
									<mml:mn>0</mml:mn>
									<mml:mtext>,</mml:mtext>
									<mml:mn>1</mml:mn>
									<mml:mo stretchy="false">}</mml:mo>
								</mml:mrow>
							</mml:math>, is the nearest codeword. To embed the corresponding watermark bit 
							<ce:italic>w</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>{0,
							<ce:hsp sp="0.12"/>1} in 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf>, the 
							<ce:italic>j</ce:italic>th codeword of 
							<ce:bold>
								<ce:italic>G</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>p</ce:italic>
							</ce:inf> is the output as the watermarked vector 
							<mml:math altimg="si97.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="bold-italic">X</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>k</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>:
							<ce:display>
								<ce:formula id="e0075">
									<ce:label>(15)</ce:label>
									<mml:math altimg="si98.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mi>j</mml:mi>
										<mml:mo>=</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>t</mml:mi>
										<mml:mo>+</mml:mo>
										<mml:mi>w</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mi mathvariant="normal">mod</mml:mi>
										<mml:mo stretchy="false">‖</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">G</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>p</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">‖</mml:mo>
										<mml:mtext>,</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>
							<ce:display>
								<ce:formula id="e0080">
									<ce:label>(16)</ce:label>
									<mml:math altimg="si99.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">X</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>k</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="bold-italic">c</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>j</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>p</mml:mi>
											</mml:mrow>
										</mml:msubsup>
										<mml:mtext>,</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>where 
							<ce:italic>j</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>[0,
							<ce:hsp sp="0.12"/>∥
							<ce:bold>
								<ce:italic>G</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>p</ce:italic>
							</ce:inf>∥], and ∥
							<ce:bold>
								<ce:italic>G</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>p</ce:italic>
							</ce:inf>∥ denotes the number of codewords contained in group 
							<ce:bold>
								<ce:italic>G</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>p</ce:italic>
							</ce:inf>, and “mod” means the modulus operation. For embedding only one bit into each vector, ∥
							<ce:bold>
								<ce:italic>G</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>p</ce:italic>
							</ce:inf>∥
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>2.
						</ce:para>
						<ce:para id="p0265" view="all">After all of the watermark bits have been embedded into the corresponding vectors, the output vectors are pieced together to form the watermarked image, 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>′. In addition, due to the embedding strategy employed, this method requires the original cover image to be presented during extraction, or else the hidden information cannot be obtained. This is a fatal disadvantage for the practical application of this algorithm.
						</ce:para>
					</ce:section>
					<ce:section id="s0085" view="all">
						<ce:label>9.2</ce:label>
						<ce:section-title>Review of watermarking algorithm in 
							<ce:cross-ref refid="b0180">[36]</ce:cross-ref>
						</ce:section-title>
						<ce:para id="p0270" view="all">The algorithm described in this sub-section is an improvement on some existing schemes for VQ-based watermarking reported in the literature 
							<ce:cross-ref refid="b0090">[18]</ce:cross-ref>. The trained codebook has a size of 
							<ce:italic>L</ce:italic>, which is an even number. Then, 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>{
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">0</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>−1
							</ce:inf>} is employed for vector quantization. In 
							<ce:cross-ref refid="b0180">[36]</ce:cross-ref>, the authors propose a method to partition the codebook according to the watermarking bits ‘0’ or ‘1’ to be embedded. They divide 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> into the odd-indexed and even-indexed sub-codebooks 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>o</ce:italic>
							</ce:inf> and 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>e</ce:italic>
							</ce:inf>, with 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>o</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>{
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">3</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">5</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>−1
							</ce:inf>} and 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>e</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>{
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">0</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">2</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">4</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>−2
							</ce:inf>}. Thus, 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>o</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∪
							<ce:hsp sp="0.25"/>
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>e</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold> and 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>o</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∩
							<ce:hsp sp="0.25"/>
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>e</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>∅.
						</ce:para>
						<ce:para id="p0275" view="all">To embed the watermark, if the codeword for the current block is 
							<ce:italic>c</ce:italic>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf>, 
							<ce:italic>k</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>[0,
							<ce:hsp sp="0.12"/>
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>−
							<ce:hsp sp="0.25"/>1], and if the watermark bit is ‘0’, 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>e</ce:italic>
							</ce:inf> is adopted for watermark embedding because 0 is an even number, and the nearest codeword in 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>e</ce:italic>
							</ce:inf> is found to replace the original codeword. If the watermark bit is ‘1’, 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>o</ce:italic>
							</ce:inf> is used, and the same scheme is applied for embedding watermark bit ‘1’. Finally, with the codewords in 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>o</ce:italic>
							</ce:inf> and 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>e</ce:italic>
							</ce:inf>, the watermarked image 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>′ is reconstructed.
						</ce:para>
						<ce:para id="p0280" view="all">To extract the watermark, the codebook plays an essential role. Suppose that the watermarked image 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>′ is transmitted over the packet loss channel, and the received image is denoted by 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>″. On the receiver side, the same sub-codebooks 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>o</ce:italic>
							</ce:inf> and 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>e</ce:italic>
							</ce:inf> are employed to extract the watermark. The authors use table look-up to find the VQ indices of the received image 
							<ce:bold>
								<ce:italic>X</ce:italic>
							</ce:bold>″. For every block in the vector quantization, if the index belongs to 
							<ce:bold>
								<ce:italic>C</ce:italic>
							</ce:bold>
							<ce:inf loc="post">
								<ce:italic>o</ce:italic>
							</ce:inf>, then the extracted watermark bit is determined to be ‘0’; if not, the bit is ‘1’. By gathering all of the extracted watermark bits, the extracted watermark 
							<ce:bold>
								<ce:italic>W</ce:italic>
							</ce:bold>′ can be reconstructed.
						</ce:para>
					</ce:section>
					<ce:section id="s0090" view="all">
						<ce:label>9.3</ce:label>
						<ce:section-title>Comparisons between our algorithm and those in Sections 
							<ce:cross-refs refid="s0080 s0085">9.1 and 9.2</ce:cross-refs>
						</ce:section-title>
						<ce:para id="p0285" view="all">As we stated in Section 
							<ce:cross-ref refid="s0005">1</ce:cross-ref>, imperceptibility, robustness, and capacity are the three important requirements in designing a watermarking algorithm. We quantitatively compare our algorithm to those presented above, based on the three requirements. Our results indicate that our algorithm outperforms the two algorithms reported in the literature 
							<ce:cross-refs refid="b0135 b0180">[27,36]</ce:cross-refs>.
						</ce:para>
						<ce:para id="p0290" view="all">First, we compare the watermark capacity. The main difference between our algorithm and those in 
							<ce:cross-refs refid="b0135 b0180">[27,36]</ce:cross-refs> is that our algorithm can embed two binary watermarks, each with a watermark capacity of 128
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>128
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>16384 bits, or 128
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>128
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>2
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>32768 bits in total. Only one binary watermark (having size 128
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>128
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>16384 bits) can be embedded by using either 
							<ce:cross-ref refid="b0135">[27]</ce:cross-ref> or 
							<ce:cross-ref refid="b0180">[36]</ce:cross-ref>. Consequently, we can embed twice the number of bits, or twice the capacity.
						</ce:para>
						<ce:para id="p0295" view="all">Next, we compare the robustness and imperceptibility criteria between our algorithm and those in 
							<ce:cross-refs refid="b0135 b0180">[27,36]</ce:cross-refs>. These can be compared objectively with the results presented in Section 
							<ce:cross-ref refid="s0095">10</ce:cross-ref>. For the robustness metric, the Hamming distance (HD) is employed in 
							<ce:cross-ref refid="b0135">[27]</ce:cross-ref>, and the normalized cross-correlation (NC) is used in 
							<ce:cross-ref refid="b0180">[36]</ce:cross-ref>, respectively. For the imperceptibility metric, both papers employ the Peak Signal-to-Noise Ratio (PSNR) for making comparisons. Better robustness is indicated by either smaller HD or larger NC values. Better imperceptibility is indicated by larger PSNR values. Because the robustness metrics differ among our paper and those in 
							<ce:cross-refs refid="b0135 b0180">[27,36]</ce:cross-refs>, we determine to use the commonly employed Bit Correct Rates (BCR) for making comparisons in Section 
							<ce:cross-ref refid="s0095">10</ce:cross-ref>. Readers are encouraged to refer to Section 
							<ce:cross-ref refid="s0095">10</ce:cross-ref> for detailed comparisons. From the results presented in 
							<ce:cross-refs refid="t0005 t0010 t0015 t0020">Table 1 through Table 4</ce:cross-refs>
							<ce:float-anchor refid="t0005"/>
							<ce:float-anchor refid="t0010"/>
							<ce:float-anchor refid="t0015"/>
							<ce:float-anchor refid="t0020"/> in Section 
							<ce:cross-ref refid="s0095">10</ce:cross-ref>, it is evident that our algorithm has better performance.
						</ce:para>
						<ce:para id="p0300" view="all">To summarize, by comparing quantitative measures of the three requirements for a watermarking algorithm, we conclude that our algorithm yields better results than those in 
							<ce:cross-refs refid="b0135 b0180">[27,36]</ce:cross-refs>. We attribute this performance to the innovations in our algorithm design compared to existing published algorithms.
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0095" view="all">
					<ce:label>10</ce:label>
					<ce:section-title>Simulation results</ce:section-title>
					<ce:para id="p0305" view="all">In our simulations, we use the test image, 
						<ce:monospace>Lena</ce:monospace>, with size 512
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>512, as the original source. We have embedded a watermark with size 128
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>128, shown in 
						<ce:cross-ref refid="f0040">Fig. 8</ce:cross-ref>
						<ce:float-anchor refid="f0040"/>. The original source is divided into 4
						<ce:hsp sp="0.25"/>×
						<ce:hsp sp="0.25"/>4 blocks for VQ compression, which also meets the number of bits required for watermark embedding. The codebook sizes are 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>512 and 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1024, and indices therein are represented by 9-bit or 10-bit strings, respectively.
					</ce:para>
					<ce:para id="p0310" view="all">Two quantities are considered to evaluate our proposed algorithm. We employ the watermarked image quality as the first metric for evaluation. The watermarked image quality, measured by the Peak Signal-to-Noise Ratio (PSNR) between the watermarked image 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>′ and the original 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold> can be calculated by using Eq. 
						<ce:cross-ref refid="e0065">(13)</ce:cross-ref>. 
						<ce:bold>
							<ce:italic>X</ce:italic>
						</ce:bold>′ is reconstructed from the received descriptions which are transmitted over two mutually independent, erasure channels. The second metric, the Bit Correct Rates (BCR), of the two extracted watermarks are employed to evaluate the robustness of the algorithm. They can be calculated with Eq. 
						<ce:cross-ref refid="e0070">(14)</ce:cross-ref>. Generally speaking, we aim for a high PSNR value, indicating that the watermarked image quality is preserved, and high BCR values in the extracted watermarks, indicating watermark robustness. We also make comparisons with other existing VQ-based watermarking schemes 
						<ce:cross-refs refid="b0135 b0180">[27,36]</ce:cross-refs> described in Section 
						<ce:cross-ref refid="s0075">9</ce:cross-ref>. Simulations show the practicality and usefulness of our method.
					</ce:para>
					<ce:para id="p0315" view="all">As depicted in 
						<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>, only the watermarked VQ codewords are transmitted over the noisy channels. Therefore, attacking schemes such as low-pass filtering, or those employed in the Stirmark benchmark 
						<ce:cross-ref refid="b0185">[37]</ce:cross-ref>, are not applicable to our scheme. Therefore, we only use the situations where the descriptions can be transmitted over mutually independent channels.
					</ce:para>
					<ce:para id="p0320" view="all">Simulations with different channel erasure probabilities are presented in 
						<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>
						<ce:float-anchor refid="f0045"/> and 
						<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>
						<ce:float-anchor refid="f0050"/> with a codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>512, and in 
						<ce:cross-ref refid="f0055">Fig. 11</ce:cross-ref>
						<ce:float-anchor refid="f0055"/> and 
						<ce:cross-ref refid="f0060">Fig. 12</ce:cross-ref>
						<ce:float-anchor refid="f0060"/> with a codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1024, respectively. We also use tables to make comparisons with the results obtained from other existing algorithms. In 
						<ce:cross-ref refid="t0005">Table 1</ce:cross-ref> and 
						<ce:cross-ref refid="t0010">Table 2</ce:cross-ref>, we present the watermarked PSNR values and the BCR values of the extracted watermarks with a codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>512. 
						<ce:cross-ref refid="t0015">Table 3</ce:cross-ref> and 
						<ce:cross-ref refid="t0020">Table 4</ce:cross-ref> show their counterparts with the codebook size of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>1024.
					</ce:para>
					<ce:para id="p0325" view="all">In 
						<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>, 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">1</ce:inf> and 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">2</ce:inf> denote the erasure probabilities with Channel 1 and Channel 2. 
						<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>(a) shows the extracted watermarks under error-free transmission. These are identical to the watermark embedded in 
						<ce:cross-ref refid="f0040">Fig. 8</ce:cross-ref>. In 
						<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>(b)–(d), they represent the results after transmission over lightly- to heavily-erased channels. The BCR values are still high and the extracted watermarks are recognizable even when 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">1</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">2</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0.5. In 
						<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>, we demonstrate the case when one of the channels experiences a total breakdown. When Channel 2 breaks down, the first watermark is recognizable in 
						<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>(a), while the second cannot be distinguished. When Channel 1 breaks down, as depicted in 
						<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>(b), we obtain similar results.
					</ce:para>
					<ce:para id="p0330" view="all">In 
						<ce:cross-ref refid="t0005">Table 1</ce:cross-ref> and 
						<ce:cross-ref refid="t0010">Table 2</ce:cross-ref>, the PSNR and BCR values under different erasure probabilities are indicated. Comparisons with the results in 
						<ce:cross-ref refid="b0135">[27]</ce:cross-ref> and 
						<ce:cross-ref refid="b0180">[36]</ce:cross-ref> are also made. The PSNR values in 
						<ce:cross-ref refid="t0005">Table 1</ce:cross-ref> show error-resilient capabilities with MDVQ under severely erased channels. The PSNR values with our algorithm outperform others in most cases. Under the error-free condition, the watermarked PSNR using our algorithm has the best performance. In addition, the BCR values shown in 
						<ce:cross-ref refid="t0010">Table 2</ce:cross-ref> are acceptable even with heavily erased channels, and the corresponding watermarks can all be subjectively recognized. In only one situation when one of the channels breaks down completely, is it not possible to recognize the second watermark. More importantly, using our algorithm, we can embed twice as much watermark capacity compared to the algorithms reported in 
						<ce:cross-ref refid="b0135">[27]</ce:cross-ref> and 
						<ce:cross-ref refid="b0180">[36]</ce:cross-ref>. Thus, while only one watermark can be extracted using the prior algorithms, the corresponding BCR values using our algorithm are better than those in 
						<ce:cross-ref refid="b0135">[27]</ce:cross-ref> and 
						<ce:cross-ref refid="b0180">[36]</ce:cross-ref>.
					</ce:para>
					<ce:para id="p0335" view="all">In 
						<ce:cross-ref refid="f0055">Fig. 11</ce:cross-ref>, similar comparisons can be made by following those given in 
						<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>. 
						<ce:cross-ref refid="f0055">Fig. 11</ce:cross-ref>(a) shows the extracted watermarks during error-free transmission. These are identical to those embedded in 
						<ce:cross-ref refid="f0040">Fig. 8</ce:cross-ref>. In 
						<ce:cross-ref refid="f0055">Fig. 11</ce:cross-ref>(b)–(d), they represent the results when transmitting over the lightly to heavily erased channels. The BCR values are still high and the extracted watermarks are recognizable even with 
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">1</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>
						<ce:italic>p</ce:italic>
						<ce:inf loc="post">2</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0.5. When comparing these results with 
						<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>(b)–(d), although the BCR values are a little inferior, all the extracted watermarks are recognizable. In 
						<ce:cross-ref refid="f0060">Fig. 12</ce:cross-ref>, when one of the channels fails, both of the first watermarks are recognizable, while the second watermarks can only be partially distinguished.
					</ce:para>
					<ce:para id="p0340" view="all">In 
						<ce:cross-ref refid="t0015">Table 3</ce:cross-ref> and 
						<ce:cross-ref refid="t0020">Table 4</ce:cross-ref>, PSNR and BCR values under different erasure probabilities are indicated. Comparisons with results from 
						<ce:cross-ref refid="b0135">[27]</ce:cross-ref> and 
						<ce:cross-ref refid="b0180">[36]</ce:cross-ref> are also made. The PSNR values in 
						<ce:cross-ref refid="t0015">Table 3</ce:cross-ref> show the error-resilient capabilities using MDVQ under severely erased channels. The PSNR values using our algorithm outperform others in most cases, and under the error-free condition, the watermarked PSNR using our algorithm performs best. In comparison with 
						<ce:cross-ref refid="t0005">Table 1</ce:cross-ref>, with a larger codebook size in 
						<ce:cross-ref refid="t0015">Table 3</ce:cross-ref>, we obtain better PSNR values. In addition, the BCR values in 
						<ce:cross-ref refid="t0010">Table 2</ce:cross-ref> are acceptable even with heavily erased channels. Again, with our algorithm, we can embed twice as much watermark capacity compared to those in 
						<ce:cross-ref refid="b0135">[27]</ce:cross-ref> and 
						<ce:cross-ref refid="b0180">[36]</ce:cross-ref>. Only one watermark can be extracted with existing algorithms, and the corresponding BCR values with our algorithm are better than 
						<ce:cross-ref refid="b0135">[27]</ce:cross-ref> and 
						<ce:cross-ref refid="b0180">[36]</ce:cross-ref>.
					</ce:para>
					<ce:para id="p0345" view="all">In summary, under a wide range of channel erasure probabilities, the results using our proposed algorithm demonstrate both the effective transmission of watermarked images, and the acceptable robustness of the extracted watermarks. Compared with the existing schemes, we have doubled the amount of watermark capacity embedded with our algorithm; our algorithm also performs better on imperceptibility and robustness measures.</ce:para>
				</ce:section>
				<ce:section id="s0100" view="all">
					<ce:label>11</ce:label>
					<ce:section-title>Conclusions</ce:section-title>
					<ce:para id="p0350" view="all">In this paper, we proposed an innovative scheme for VQ-based image multi-watermarking with multiple description coding (MDC), which is suitable for transmission over noisy channels. We modified the MDVQ and MDSQ index assignments for watermark embedding and extraction. By incorporating this with MDC, we obtained promising results. We also presented discussions and made comparisons between our algorithm and others previously published, and we point out the superiority of our algorithm. Simulation results indicate that our watermarking algorithm is more robust and more resilient with respect to combat with channel noise under both lightly and heavily erased channels. In addition, in comparison with existing VQ-based algorithms in the literature, our algorithm performed better than others in both the watermark imperceptibility, shown by PSNR, and the watermark robustness, shown by BCR. Therefore, our algorithm is not only innovative for research, but also suitable for practical implementation.</ce:para>
				</ce:section>
			</ce:sections>
			<ce:acknowledgment xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Acknowledgement</ce:section-title>
				<ce:para id="p0505" view="all">This work was supported by 
					<ce:grant-sponsor id="GS1" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">National Science Council (Taiwan, ROC)</ce:grant-sponsor> under Grant No. 
					<ce:grant-number refid="GS1">NSC 93-2219-E-009-006</ce:grant-number> and 
					<ce:grant-number refid="GS1">NSC 95-2221-E-390-034</ce:grant-number>. The authors would also like to give their gratitude to the Editor-in-Chief and anonymous reviewers for their valuable comments.
				</ce:para>
			</ce:acknowledgment>
		</ja:body>
		<ja:tail view="all">
			<ce:bibliography id="bi005" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>References</ce:section-title>
				<ce:bibliography-sec id="bs005">
					<ce:bib-reference id="b0005">
						<ce:label>[1]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Ak</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.</ce:given-name>
										<ce:surname>Kaya</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.</ce:given-name>
										<ce:surname>Onarlıogˇlu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.A.</ce:given-name>
										<ce:surname>Selçuk</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Efficient broadcast encryption with user profiles</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>6</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1060</sb:first-page>
									<sb:last-page>1072</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0010">
						<ce:label>[2]</ce:label>
						<ce:other-ref>
							<ce:textref>P. Artameeyanant, Tabu searching for watermarking robust against compression and cropping, in: SICE-ICASE International Joint Conference, 2006, pp. 4461–4463.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0015">
						<ce:label>[3]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Barni</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>F.</ce:given-name>
										<ce:surname>Bartolini</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>De Rosa</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Piva</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Capacity of full frame DCT image watermarks</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Image Process.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>9</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>8</sb:issue-nr>
									<sb:date>2000</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1450</sb:first-page>
									<sb:last-page>1455</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0020">
						<ce:label>[4]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.C.</ce:given-name>
										<ce:surname>Chang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.Y.</ce:given-name>
										<ce:surname>Pai</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.M.</ce:given-name>
										<ce:surname>Yeh</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.K.</ce:given-name>
										<ce:surname>Chan</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A high payload frequency-based reversible image hiding method</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>11</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>2286</sb:first-page>
									<sb:last-page>2298</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0025">
						<ce:label>[5]</ce:label>
						<ce:other-ref>
							<ce:textref>F.C. Chang, H.C. Huang, A refactoring method for cache-efficient swarm intelligence algorithms, Information Sciences, (doi:10.1016/j.ins.2010.02.025).</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0030">
						<ce:label>[6]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>T.D.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>N.N.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Optimization of multi-purpose watermarking algorithm based on tabu search</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Comput. Eng. Appl.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>42</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>36</sb:issue-nr>
									<sb:date>2006</sb:date>
								</sb:issue>
							</sb:host>
							<sb:comment>(in Chinese)</sb:comment>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0035">
						<ce:label>[7]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.A.</ce:given-name>
										<ce:surname>El Gamal</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>T.M.</ce:given-name>
										<ce:surname>Cover</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Achievable rates for multiple descriptions</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Inform. Theory</sb:maintitle>
										</sb:title>
										<sb:volume-nr>28</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>6</sb:issue-nr>
									<sb:date>1982</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>851</sb:first-page>
									<sb:last-page>857</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0040">
						<ce:label>[8]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Gersho</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.M.</ce:given-name>
										<ce:surname>Gray</ce:surname>
									</sb:author>
								</sb:authors>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:title>
										<sb:maintitle>Vector Quantization and Signal Compression</sb:maintitle>
									</sb:title>
									<sb:date>1992</sb:date>
									<sb:publisher>
										<sb:name>Kluwer Academic Publishers</sb:name>
										<sb:location>Boston, MA</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0045">
						<ce:label>[9]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>F.</ce:given-name>
										<ce:surname>Glover</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Laguna</ce:surname>
									</sb:author>
								</sb:authors>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:title>
										<sb:maintitle>Tabu Search</sb:maintitle>
									</sb:title>
									<sb:date>1997</sb:date>
									<sb:publisher>
										<sb:name>Kluwer Academic Publishers</sb:name>
										<sb:location>Boston, MA</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0050">
						<ce:label>[10]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>N.</ce:given-name>
										<ce:surname>Görtz</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Leelapornchai</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Optimization of the index assignments for multiple description vector quantizers</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Commun.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>51</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>3</sb:issue-nr>
									<sb:date>2003</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>336</sb:first-page>
									<sb:last-page>340</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0055">
						<ce:label>[11]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.H.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Genetic fingerprinting for copyright protection of multicast media</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Soft Comput.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>13</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>4</sb:issue-nr>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>383</sb:first-page>
									<sb:last-page>391</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0060">
						<ce:label>[12]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.H.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.C.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Copyright protection for image files with EXIF metadata</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Int. J. Innovative Comput. Inform. Control</sb:maintitle>
										</sb:title>
										<sb:volume-nr>5</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>7</sb:issue-nr>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1903</sb:first-page>
									<sb:last-page>1909</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0065">
						<ce:label>[13]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.M.</ce:given-name>
										<ce:surname>Chu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.S.</ce:given-name>
										<ce:surname>Pan</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>The optimized copyright protection system with genetic watermarking</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Soft Comput.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>13</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>4</sb:issue-nr>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>333</sb:first-page>
									<sb:last-page>343</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0070">
						<ce:label>[14]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.C.</ce:given-name>
										<ce:surname>Chu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.S.</ce:given-name>
										<ce:surname>Pan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Z.M.</ce:given-name>
										<ce:surname>Lu</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A tabu search based maximum descent algorithm for VQ codebook design</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Inform. Sci. Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>17</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>5</sb:issue-nr>
									<sb:date>2001</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>753</sb:first-page>
									<sb:last-page>762</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0075">
						<ce:label>[15]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>W.C.</ce:given-name>
										<ce:surname>Fang</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Metadata-based image watermarking for copyright protection</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Simul. Modell. Pract. Theory</sb:maintitle>
										</sb:title>
										<sb:volume-nr>18</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>4</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>436</sb:first-page>
									<sb:last-page>445</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0080">
						<ce:label>[16]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Ito</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Makino</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Designing side information of multiple description coding</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Inform. Hiding Multimedia Signal Process.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>1</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>1</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>10</sb:first-page>
									<sb:last-page>19</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0085">
						<ce:label>[17]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>N.S.</ce:given-name>
										<ce:surname>Jayant</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.D.</ce:given-name>
										<ce:surname>Johnston</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.J.</ce:given-name>
										<ce:surname>Safranek</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Signal compression based on models of human perception</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Proc. IEEE</sb:maintitle>
										</sb:title>
										<sb:volume-nr>81</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>10</sb:issue-nr>
									<sb:date>1993</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1385</sb:first-page>
									<sb:last-page>1422</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0090">
						<ce:label>[18]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Jo</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.D.</ce:given-name>
										<ce:surname>Kim</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A digital image watermarking scheme based on vector quantisation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEICE Trans. Inform. Syst.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>E85-D</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>6</sb:issue-nr>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1054</sb:first-page>
									<sb:last-page>1056</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0095">
						<ce:label>[19]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>X.</ce:given-name>
										<ce:surname>Kang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.Q.</ce:given-name>
										<ce:surname>Shi</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Lin</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A DWT–DFT composite watermarking scheme robust to both affine transform and JPEG compression</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Circuits Syst. Video Technol.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>13</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>8</sb:issue-nr>
									<sb:date>2003</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>776</sb:first-page>
									<sb:last-page>786</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0100">
						<ce:label>[20]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Katzenbeisser</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>F.</ce:given-name>
										<ce:surname>Petitcolas</ce:surname>
									</sb:author>
								</sb:authors>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:title>
										<sb:maintitle>Information Hiding – Techniques for Steganography and Digital Watermarking</sb:maintitle>
									</sb:title>
									<sb:date>2000</sb:date>
									<sb:publisher>
										<sb:name>Artech House</sb:name>
										<sb:location>Norwood, MA</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0105">
						<ce:label>[21]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.H.</ce:given-name>
										<ce:surname>Koenen</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Lacy</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Mackay</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Mitchell</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>The long march to interoperable digital rights management</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Proc. IEEE</sb:maintitle>
										</sb:title>
										<sb:volume-nr>92</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>6</sb:issue-nr>
									<sb:date>2004</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>883</sb:first-page>
									<sb:last-page>897</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0110">
						<ce:label>[22]</ce:label>
						<ce:other-ref>
							<ce:textref>C. Lin, J.S. Pan, Robust VQ-based digital image watermarking for noisy channel, in: First International Conference on Innovative Computing, Information and Control, 2006, pp. 673–676.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0115">
						<ce:label>[23]</ce:label>
						<ce:other-ref>
							<ce:textref>C.Y. Lin, S.F. Chang, Watermarking capacity of digital images based on domain-specific masking effects, in: International Conference on Information Technology: Coding and Computing, 2001, pp. 90–94.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0120">
						<ce:label>[24]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Q.</ce:given-name>
										<ce:surname>Liu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.H.</ce:given-name>
										<ce:surname>Sung</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Qiao</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Z.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>Ribeiro</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>An improved approach to steganalysis of JPEG images</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>9</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1643</sb:first-page>
									<sb:last-page>1655</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0125">
						<ce:label>[25]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Z.</ce:given-name>
										<ce:surname>Liu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Hu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>X.</ce:given-name>
										<ce:surname>Zhang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.</ce:given-name>
										<ce:surname>Ma</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Certificateless signcryption scheme in the standard model</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>3</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>452</sb:first-page>
									<sb:last-page>464</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0130">
						<ce:label>[26]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Loo</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>N.</ce:given-name>
										<ce:surname>Kingsbury</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Watermark detection based on the properties of error control codes</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEE Proc. Vision, Image Signal Process.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>150</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>2</sb:issue-nr>
									<sb:date>2003</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>115</sb:first-page>
									<sb:last-page>121</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0135">
						<ce:label>[27]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Z.M.</ce:given-name>
										<ce:surname>Lu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.H.</ce:given-name>
										<ce:surname>Sun</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Digital image watermarking technique based on vector quantisation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEE Elec. Lett.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>36</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>4</sb:issue-nr>
									<sb:date>2000</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>303</sb:first-page>
									<sb:last-page>305</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0140">
						<ce:label>[28]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>Macq</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Dittmann</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>E.J.</ce:given-name>
										<ce:surname>Delp</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Benchmarking of image watermarking algorithms for digital rights management</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Proc. IEEE</sb:maintitle>
										</sb:title>
										<sb:volume-nr>92</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>6</sb:issue-nr>
									<sb:date>2004</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>971</sb:first-page>
									<sb:last-page>984</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0145">
						<ce:label>[29]</ce:label>
						<ce:other-ref>
							<ce:textref>S. Moskowitz, What is acceptable quality in the application of digital watermarking: trade-offs of security, robustness and quality, in: International Conference on Information Technology: Coding and Computing, 2002, pp. 80–84.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0150">
						<ce:label>[30]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Moulin</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.K.</ce:given-name>
										<ce:surname>Mıhçak</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A framework for evaluating the data-hiding capacity of image sources</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Image Process.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>11</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>9</sb:issue-nr>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1029</sb:first-page>
									<sb:last-page>1042</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0155">
						<ce:label>[31]</ce:label>
						<ce:other-ref>
							<ce:textref>J.S. Pan, C.S. Cheng, B.Y. Liao, C.H. Hsu, K.C. Huang, Optimization of multipurpose watermarking algorithm, in: 2004 IEEE Asia-Pacific Conference on Circuits and Systems, 2004, pp. 601–604.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0160">
						<ce:label>[32]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.S.</ce:given-name>
										<ce:surname>Pan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.C.</ce:given-name>
										<ce:surname>Hsin</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Robust image watermarking based on multiple description vector quantisation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEE Elect. Lett.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>40</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>22</sb:issue-nr>
									<sb:date>2004</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1409</sb:first-page>
									<sb:last-page>1410</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0165">
						<ce:label>[33]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.S.</ce:given-name>
										<ce:surname>Pan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.Y.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.Y.</ce:given-name>
										<ce:surname>Liao</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Multiple description multi-watermarking with tabu search approaches</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Visual Commun. Image Process. Proc. SPIE</sb:maintitle>
										</sb:title>
									</sb:series>
									<sb:issue-nr>5960</sb:issue-nr>
									<sb:date>2005</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1455</sb:first-page>
									<sb:last-page>1467</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0170">
						<ce:label>[34]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:host>
								<sb:edited-book>
									<sb:editors>
										<sb:editor>
											<ce:given-name>J.S.</ce:given-name>
											<ce:surname>Pan</ce:surname>
										</sb:editor>
										<sb:editor>
											<ce:given-name>H.C.</ce:given-name>
											<ce:surname>Huang</ce:surname>
										</sb:editor>
										<sb:editor>
											<ce:given-name>L.C.</ce:given-name>
											<ce:surname>Jain</ce:surname>
										</sb:editor>
									</sb:editors>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>Intelligent Watermarking Techniques</sb:maintitle>
											</sb:title>
										</sb:series>
									</sb:book-series>
									<sb:date>2004</sb:date>
									<sb:publisher>
										<sb:name>World Scientific Publishing Company</sb:name>
										<sb:location>Singapore</sb:location>
									</sb:publisher>
								</sb:edited-book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0175">
						<ce:label>[35]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.S.</ce:given-name>
										<ce:surname>Pan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.T.</ce:given-name>
										<ce:surname>Sung</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.Y.</ce:given-name>
										<ce:surname>Liao</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Robust VQ-based digital watermarking for the memoryless binary symmetric channel</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEICE Trans. Fundam.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>E-87A</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>7</sb:issue-nr>
									<sb:date>2004</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1839</sb:first-page>
									<sb:last-page>1841</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0180">
						<ce:label>[36]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.S.</ce:given-name>
										<ce:surname>Pan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>F.H.</ce:given-name>
										<ce:surname>Wang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>L.C.</ce:given-name>
										<ce:surname>Jain</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Improved schemes for VQ-based image watermarking</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Int. Symp. Consum. Electron.</sb:maintitle>
										</sb:title>
									</sb:series>
									<sb:date>2003</sb:date>
								</sb:issue>
							</sb:host>
							<sb:comment>paper no: ISCE03011</sb:comment>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0185">
						<ce:label>[37]</ce:label>
						<ce:other-ref>
							<ce:textref>F.A.P. Petitcolas, Stirmark benchmark 4.0, 2004. &lt;
								<ce:monospace>http://www.petitcolas.net/fabien/watermarking/stirmark/</ce:monospace>&gt;.
							</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0190">
						<ce:label>[38]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Piva</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>F.</ce:given-name>
										<ce:surname>Bartolini</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Barni</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Managing copyright in open networks</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Internet Comput.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>6</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>3</sb:issue-nr>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>18</sb:first-page>
									<sb:last-page>26</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0195">
						<ce:label>[39]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.I.</ce:given-name>
										<ce:surname>Podilchuk</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>W.J.</ce:given-name>
										<ce:surname>Zeng</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Image-adaptive watermarking using visual models</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE J. Sel. Areas Commun.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>16</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>4</sb:issue-nr>
									<sb:date>1998</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>525</sb:first-page>
									<sb:last-page>539</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0200">
						<ce:label>[40]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Ramkumar</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.N.</ce:given-name>
										<ce:surname>Akansu</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>On the design of data hiding methods robust to lossy compression</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Multimedia</sb:maintitle>
										</sb:title>
										<sb:volume-nr>6</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>6</sb:issue-nr>
									<sb:date>2004</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>947</sb:first-page>
									<sb:last-page>951</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0205">
						<ce:label>[41]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.S.</ce:given-name>
										<ce:surname>Shieh</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.C.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>F.H.</ce:given-name>
										<ce:surname>Wang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.S.</ce:given-name>
										<ce:surname>Pan</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>An embedding algorithm for multiple watermarks</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Inform. Sci. Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>19</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>2</sb:issue-nr>
									<sb:date>2003</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>381</sb:first-page>
									<sb:last-page>395</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0210">
						<ce:label>[42]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.J.</ce:given-name>
										<ce:surname>Shiu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.L.</ce:given-name>
										<ce:surname>Ng</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.F.</ce:given-name>
										<ce:surname>Fang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.C.T.</ce:given-name>
										<ce:surname>Lee</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.H.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Data hiding methods based upon DNA sequences</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>11</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>2196</sb:first-page>
									<sb:last-page>2208</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0215">
						<ce:label>[43]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Sion</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Atallah</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Prabhakar</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Rights protection for relational data</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Knowl. Data Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>16</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>12</sb:issue-nr>
									<sb:date>2004</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1509</sb:first-page>
									<sb:last-page>1525</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0220">
						<ce:label>[44]</ce:label>
						<ce:other-ref>
							<ce:textref>N. Sriyingyong, K. Attakitmongcol, Wavelet-based audio watermarking using adaptive tabu search, in: 2006 1st International Symposium on Wireless Pervasive Computing, 2006, pp. 1–5.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0225">
						<ce:label>[45]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Toscano</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Lyonnet</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A new heuristic approach for non-convex optimization problems</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>10</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1955</sb:first-page>
									<sb:last-page>1966</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0230">
						<ce:label>[46]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>V.A.</ce:given-name>
										<ce:surname>Vaishampayan</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Design of multiple description scalar quantizers</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Inform. Theory</sb:maintitle>
										</sb:title>
										<sb:volume-nr>39</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>3</sb:issue-nr>
									<sb:date>1993</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>821</sb:first-page>
									<sb:last-page>834</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0235">
						<ce:label>[47]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.O.</ce:given-name>
										<ce:surname>Waller</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>Jones</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>T.</ce:given-name>
										<ce:surname>Whitley</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Edwards</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.</ce:given-name>
										<ce:surname>Kaleshi</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Munro</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>MacFarlane</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Wood</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Securing the delivery of digital content over the Internet</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Electron. Commun. Eng. J.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>14</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>5</sb:issue-nr>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>239</sb:first-page>
									<sb:last-page>248</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0240">
						<ce:label>[48]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Wang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.T.</ce:given-name>
										<ce:surname>Orchard</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>V.A.</ce:given-name>
										<ce:surname>Vaishampayan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.R.</ce:given-name>
										<ce:surname>Reibman</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Multiple description coding using pairwise correlating transforms</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Image Process.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>10</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>3</sb:issue-nr>
									<sb:date>2001</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>351</sb:first-page>
									<sb:last-page>366</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0245">
						<ce:label>[49]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Wang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.R.</ce:given-name>
										<ce:surname>Reibman</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.T.</ce:given-name>
										<ce:surname>Orchard</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.</ce:given-name>
										<ce:surname>Jafarkhani</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>An improvement to multiple description transform coding</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Signal Process.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>50</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>11</sb:issue-nr>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>2843</sb:first-page>
									<sb:last-page>2854</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0250">
						<ce:label>[50]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>K.</ce:given-name>
										<ce:surname>Yamamoto</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Iwakiri</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Real-time audio watermarking based on characteristics of PCM in digital instrument</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Inform. Hiding Multimedia Signal Process.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>1</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>2</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>59</sb:first-page>
									<sb:last-page>71</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0255">
						<ce:label>[51]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Z.</ce:given-name>
										<ce:surname>Zhang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>T.</ce:given-name>
										<ce:surname>Berger</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>New results in binary multiple descriptions</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Inform. Theory</sb:maintitle>
										</sb:title>
										<sb:volume-nr>33</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>4</sb:issue-nr>
									<sb:date>1987</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>502</sb:first-page>
									<sb:last-page>521</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
				</ce:bibliography-sec>
			</ce:bibliography>
		</ja:tail>
	</ja:article></doc:document>
