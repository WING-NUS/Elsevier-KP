<doc:document xmlns:doc="http://www.elsevier.com/xml/document/schema"><rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="http://dx.doi.org/10.1016/j.ins.2011.04.023"><dc:format xmlns:dc="http://purl.org/dc/elements/1.1/">application/xml</dc:format><dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Flexible secure inter-domain interoperability through attribute conversion</dc:title><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/"><rdf:Seq><rdf:li>Carles Martínez-García</rdf:li><rdf:li>Guillermo Navarro-Arribas</rdf:li><rdf:li>Simon N. Foley</rdf:li><rdf:li>Vicenç Torra</rdf:li><rdf:li>Joan Borrell</rdf:li></rdf:Seq></dc:creator><dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/"><rdf:Bag><rdf:li>Access control</rdf:li><rdf:li>Interoperability</rdf:li><rdf:li>Attribute conversion</rdf:li><rdf:li>Flexibility</rdf:li></rdf:Bag></dc:subject><dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">Information Sciences 181 (2011) 3491-3507. doi:10.1016/j.ins.2011.04.023</dc:description><prism:aggregationType xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">journal</prism:aggregationType><prism:publicationName xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Information Sciences</prism:publicationName><prism:copyright xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Copyright © 2011 Elsevier Inc. All rights reserved.</prism:copyright><dc:publisher xmlns:dc="http://purl.org/dc/elements/1.1/">Elsevier Inc.</dc:publisher><prism:issn xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">0020-0255</prism:issn><prism:volume xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">181</prism:volume><prism:number xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">16</prism:number><prism:coverDisplayDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">2011</prism:coverDisplayDate><prism:coverDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">2011</prism:coverDate><prism:pageRange xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3491-3507</prism:pageRange><prism:startingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3491</prism:startingPage><prism:endingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3507</prism:endingPage><prism:doi xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">10.1016/j.ins.2011.04.023</prism:doi><prism:url xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">http://dx.doi.org/10.1016/j.ins.2011.04.023</prism:url><dc:identifier xmlns:dc="http://purl.org/dc/elements/1.1/">doi:10.1016/j.ins.2011.04.023</dc:identifier></rdf:Description></rdf:RDF><dp:document-properties xmlns:dp="http://www.elsevier.com/xml/common/doc-properties/schema"><dp:aggregation-type>Journals</dp:aggregation-type><dp:version-number>S300.1</dp:version-number></dp:document-properties><ja:article docsubtype="fla" xml:lang="en" version="5.1" xmlns:ja="http://www.elsevier.com/xml/ja/schema">
		<ja:item-info>
			<ja:jid>INS</ja:jid>
			<ja:aid>9074</ja:aid>
			<ce:pii xmlns:ce="http://www.elsevier.com/xml/common/schema">S0020-0255(11)00197-6</ce:pii>
			<ce:doi xmlns:ce="http://www.elsevier.com/xml/common/schema">10.1016/j.ins.2011.04.023</ce:doi>
			<ce:copyright type="full-transfer" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema">Elsevier Inc.</ce:copyright>
		</ja:item-info>
		<ce:floats xmlns:ce="http://www.elsevier.com/xml/common/schema">
			<ce:figure id="f0005">
				<ce:label>Fig. 1</ce:label>
				<ce:caption>
					<ce:simple-para id="sp010" view="all">Composition of conversion relations.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr1"/>
			</ce:figure>
			<ce:figure id="f0010">
				<ce:label>Fig. 2</ce:label>
				<ce:caption>
					<ce:simple-para id="sp015" view="all">Example of conversion graph.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr2"/>
			</ce:figure>
			<ce:figure id="f0015">
				<ce:label>Fig. 3</ce:label>
				<ce:caption>
					<ce:simple-para id="sp020" view="all">Simple conversion graph.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr3"/>
			</ce:figure>
			<ce:figure id="f0020">
				<ce:label>Fig. 4</ce:label>
				<ce:caption>
					<ce:simple-para id="sp025" view="all">Attribute conversion module.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr4"/>
			</ce:figure>
			<ce:figure id="f0025">
				<ce:label>Fig. 5</ce:label>
				<ce:caption>
					<ce:simple-para id="sp030" view="all">Comparison in the number of conversion policies in a non-transitive scenario versus a transitive circle-like scenario. Note that the vertical axis is represented in a logarithmic scale.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr5"/>
			</ce:figure>
			<ce:figure id="f0030">
				<ce:label>Fig. 6</ce:label>
				<ce:caption>
					<ce:simple-para id="sp035" view="all">Progression of the number of paths when increasing the number of attributes in the scenario. Every domain defines conversion policies to a 10% of the rest of domains. The chart shows an exponential tendency.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr6"/>
			</ce:figure>
			<ce:figure id="f0035">
				<ce:label>Fig. 7</ce:label>
				<ce:caption>
					<ce:simple-para id="sp040" view="all">Comparison of the response time when finding the optimal and sub-optimal solutions composed by 50 paths. Note that the vertical axis is represented in a logarithmic scale.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr7"/>
			</ce:figure>
			<ce:figure id="f0040">
				<ce:label>Fig. 8</ce:label>
				<ce:caption>
					<ce:simple-para id="sp045" view="all">Progression in the number of domains. The chart shows the error introduced by method 1 and method 2.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr8"/>
			</ce:figure>
			<ce:figure id="f0045">
				<ce:label>Fig. 9</ce:label>
				<ce:caption>
					<ce:simple-para id="sp050" view="all">Progression in the number of computed paths. The optimal solution has been computed with an average of 1508 paths.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr9"/>
			</ce:figure>
			<ce:figure id="f0050">
				<ce:label>Fig. 10</ce:label>
				<ce:caption>
					<ce:simple-para id="sp055" view="all">Progression in the attribute similitude.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr10"/>
			</ce:figure>
			<ce:figure id="f0055">
				<ce:label>Fig. 11</ce:label>
				<ce:caption>
					<ce:simple-para id="sp060" view="all">Progression in the size of conversion relations. The figure shows the impact of the size of conversion relations on the execution time.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr11"/>
			</ce:figure>
		</ce:floats>
		<ja:head>
			<ce:title xmlns:ce="http://www.elsevier.com/xml/common/schema">Flexible secure inter-domain interoperability through attribute conversion</ce:title>
			<ce:author-group xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:author biographyid="vt1">
					<ce:given-name>Carles</ce:given-name>
					<ce:surname>Martínez-García</ce:surname>
					<ce:cross-ref refid="aff1">
						<ce:sup loc="post">a</ce:sup>
					</ce:cross-ref>
					<ce:cross-ref refid="cor1">
						<ce:sup loc="post">⁎</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">carlos.martinez@uab.cat</ce:e-address>
					<ce:e-address type="email">cmartinez@deic.uab.cat</ce:e-address>
				</ce:author>
				<ce:author biographyid="vt2">
					<ce:given-name>Guillermo</ce:given-name>
					<ce:surname>Navarro-Arribas</ce:surname>
					<ce:cross-ref refid="aff1">
						<ce:sup loc="post">a</ce:sup>
					</ce:cross-ref>
					<ce:cross-ref refid="aff2">
						<ce:sup loc="post">b</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">guille@iiia.csic.es</ce:e-address>
				</ce:author>
				<ce:author biographyid="vt3">
					<ce:given-name>Simon N.</ce:given-name>
					<ce:surname>Foley</ce:surname>
					<ce:cross-ref refid="aff3">
						<ce:sup loc="post">c</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">s.foley@cs.ucc.ie</ce:e-address>
				</ce:author>
				<ce:author biographyid="vt4">
					<ce:given-name>Vicenç</ce:given-name>
					<ce:surname>Torra</ce:surname>
					<ce:cross-ref refid="aff2">
						<ce:sup loc="post">b</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">vtorra@iiia.csic.es</ce:e-address>
				</ce:author>
				<ce:author biographyid="vt5">
					<ce:given-name>Joan</ce:given-name>
					<ce:surname>Borrell</ce:surname>
					<ce:cross-ref refid="aff1">
						<ce:sup loc="post">a</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">joan.borrell@uab.cat</ce:e-address>
				</ce:author>
				<ce:affiliation id="aff1">
					<ce:label>a</ce:label>
					<ce:textfn>Department of Information and Communications Engineering (dEIC), Universitat Autònoma de Barcelona, 08193 Bellaterra, Catalonia, Spain</ce:textfn>
				</ce:affiliation>
				<ce:affiliation id="aff2">
					<ce:label>b</ce:label>
					<ce:textfn>IIIA, Institut d’Investigació en Intel.ligència Artificial – CSIC, Consejo Superior de Investigaciones Científicas, Campus UAB s/n, 08193 Bellaterra, Catalonia, Spain</ce:textfn>
				</ce:affiliation>
				<ce:affiliation id="aff3">
					<ce:label>c</ce:label>
					<ce:textfn>Department of Computer Science, University College Cork, Ireland</ce:textfn>
				</ce:affiliation>
				<ce:correspondence id="cor1">
					<ce:label>⁎</ce:label>
					<ce:text>Corresponding author. Tel.: +34 935813577; fax: +34 93581 4477.</ce:text>
				</ce:correspondence>
			</ce:author-group>
			<ce:date-received day="10" month="5" year="2010" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:date-revised day="8" month="2" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:date-accepted day="10" month="4" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:abstract class="author" xml:lang="en" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Abstract</ce:section-title>
				<ce:abstract-sec>
					<ce:simple-para id="sp005" view="all">The access control policy of an application that is composed of interoperating components/services is defined in terms of the access control policies enforced by the respective services. These individual access control policies are heterogenous in the sense that the services may be independently developed and managed and it is not practical to assume that all policies are defined with respect to some uniform domain vocabulary of policy attributes. A framework is described that provides a domain mapping for heterogenous policies. A fuzzy-based conversion mechanism determines the degree to which an access control attribute of one (service) policy may safely interoperate with an access control attribute of another (service) policy. The approach is scalable in the sense that it is not necessary to a priori specify every pairwise policy interoperation relationship, rather, where obvious interpretations exist then policy relationships are specified, while other relationships are inferred using the fuzzy mechanism.</ce:simple-para>
				</ce:abstract-sec>
			</ce:abstract>
			<ce:keywords class="keyword" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Keywords</ce:section-title>
				<ce:keyword>
					<ce:text>Access control</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Interoperability</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Attribute conversion</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Flexibility</ce:text>
				</ce:keyword>
			</ce:keywords>
		</ja:head>
		<ja:body view="all">
			<ce:sections xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section id="s0005" view="all">
					<ce:label>1</ce:label>
					<ce:section-title>Introduction</ce:section-title>
					<ce:para id="p0005" view="all">The growth and recent advances in distributed systems and computer networks enable existing systems and services to interact in order to provide new and improved applications. The interoperation of independent systems such as those in health-care industry, public administration and business can result in new functionality and cost savings. However, with this interoperation comes the challenge of ensuring a consistent interpretation of the access controls across the heterogenous systems and shared resources. One must be sure that a malicious user cannot gain access to an unapproved resource on one system by taking a circuitous (but authorized) route via another interoperating system.</ce:para>
					<ce:para id="p0010" view="all">Previous research considered the problem of access-control policy interoperation 
						<ce:cross-ref refid="b0055">[11]</ce:cross-ref> by assuming a common domain vocabulary for policy attributes. For example, an assumption that policy attribute 
						<ce:monospace>write.fileX</ce:monospace> has the same interpretation across the different policies enforced by each system. If the systems are independently developed and managed then they may rely on quite different access control mechanisms and/or different policy attributes. Therefore, in order to support secure interoperation between these heterogenous systems, it is necessary to define how these different attributes may be related. For example, to what extent are the attributes (each from a different system) 
						<ce:monospace>write.fileX</ce:monospace>, 
						<ce:monospace>access.X</ce:monospace> and 
						<ce:monospace>append.X</ce:monospace> similar?
					</ce:para>
					<ce:para id="p0015" view="all">Secure interoperation can be characterized in terms of two principles 
						<ce:cross-ref refid="b0055">[11]</ce:cross-ref>:
						<ce:list id="l0005">
							<ce:list-item id="o0005">
								<ce:label>•</ce:label>
								<ce:para id="p0530" view="all">
									<ce:italic>Principle of Autonomy</ce:italic>: any permitted access within an individual system must also be permitted under secure interoperation. In other words, no user can loose access in its own domain because of the interoperation.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0010">
								<ce:label>•</ce:label>
								<ce:para id="p0535" view="all">
									<ce:italic>Principle of Security</ce:italic>: any denied access within an individual system must also be denied under secure interoperation. In other words, no user can gain access degree in its own domain because of the interoperation agreement.
								</ce:para>
							</ce:list-item>
						</ce:list>
					</ce:para>
					<ce:para id="p0020" view="all">Existing research considers secure interoperation either in term of a meta-model of interoperating systems 
						<ce:cross-refs refid="b0140 b0115">[28,23]</ce:cross-refs>, or in terms of automatic policy generation whereby a uniform global policy is constructed from the individual independent policies 
						<ce:cross-ref refid="b0135">[27]</ce:cross-ref>. However, both approaches require modification of the local access control components or the individual access control policies. In an effort to avoid this limitation 
						<ce:cross-ref refid="b0090">[18]</ce:cross-ref> considers interoperability at the lower level by translating security related attributes between the different policy domains or systems. For example, given two domains in a Role-Based Access Control (RBAC) system 
						<ce:cross-ref refid="b0035">[7]</ce:cross-ref> whereby one may assume that the role 
						<ce:italic>sales-manager</ce:italic> from domain 
						<ce:italic>A</ce:italic> can be translated to the role 
						<ce:italic>marketing-manager</ce:italic> in domain 
						<ce:italic>B</ce:italic>. In this case both domains refer to their original local policies without the need to define new ones and making the interoperation less intrusive to the local domains. However, as the number of domains grows, the number attribute conversion relations between all pairwise domains grows exponentially, making the approach infeasible due to a lack of scalability.
					</ce:para>
					<ce:para id="p0025" view="all">In this paper a novel attribute conversion mechanism is proposed that enables secure interoperation between heterogenous systems. By taking a fuzzy-based approach to constructing the attribute relationships a practical isomorphic conversion mechanism is developed. The approach is scalable in the sense that it is not necessary to a priori specify every pairwise policy interoperation relationship, rather, where obvious interpretations exist then policy relationships are specified, while other relationships are inferred using the fuzzy mechanism. The approach can be used by existing security systems without the need to define new security policies nor modify the local access control components of each system.</ce:para>
					<ce:para id="p0030" view="all">The paper is organized as follows. Section 
						<ce:cross-ref refid="s0010">2</ce:cross-ref> describes the multi-domain environment and defines attribute conversion in terms of fuzzy relations between two administrative domains. Section 
						<ce:cross-ref refid="s0030">3</ce:cross-ref> generalizes this attribute conversion to a group of domains and shows how transitivity in the conversion relation helps to address with the scalability of the approach. Section 
						<ce:cross-ref refid="s0060">4</ce:cross-ref> discusses the security considerations that arise as a consequence of using this fuzzy conversion scheme. Empirical results from simulation and analysis of the mechanism are provided in Section 
						<ce:cross-ref refid="s0095">5</ce:cross-ref>. Finally, Section 
						<ce:cross-ref refid="s0150">6</ce:cross-ref> considers related research and Section 
						<ce:cross-ref refid="s0155">7</ce:cross-ref> concludes the paper.
					</ce:para>
				</ce:section>
				<ce:section id="s0010" view="all">
					<ce:label>2</ce:label>
					<ce:section-title>Fuzzy attribute conversion</ce:section-title>
					<ce:para id="p0035" view="all">Secure interoperation is defined in terms of the low-level attributes – users, actions, and so forth – that make up the heterogenous policies. The security policy 
						<ce:italic>domain</ce:italic> of a system is defined in terms of a set of users, a set of attributes, a set of resources, a set of actions, and a set of access control policies. A domain authority assigns 
						<ce:italic>attributes</ce:italic> to users. Attributes are used to express the policy credentials that are needed in order to execute actions on a resource. Such attributes are considered to be any security related information referred to by the policy, ranging for example, from an identifier to a role, or more generic attributes such as age, regardless of the access control model they use. This approach provides a simple abstraction for a variety of access control models ranging from RBAC to more general discretionary access control.
					</ce:para>
					<ce:para id="p0040" view="all">An interoperation of systems results in the interoperation of their respective security (policy) domains. Each domain is considered to have a 
						<ce:italic>local</ce:italic> subset of attributes from a set of universal attributes 
						<mml:math altimg="si1.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mi mathvariant="double-struck">X</mml:mi>
							</mml:mrow>
						</mml:math>. We denote the set of attributes of a domain 
						<ce:italic>A</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf> as 
						<mml:math altimg="si2.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msub>
									<mml:mrow>
										<mml:mi>A</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>i</mml:mi>
									</mml:mrow>
								</mml:msub>
								<mml:mo>⊆</mml:mo>
								<mml:mi mathvariant="double-struck">X</mml:mi>
							</mml:mrow>
						</mml:math>, that is, we use the same letter to denote a domain and its set of attributes.
					</ce:para>
					<ce:para id="p0045" view="all">While there are scenarios with global attributes, such as 
						<ce:italic>age</ce:italic>, with a common understanding across different domains, global attributes are always treated as local in order to provide a generic solution and also to avoid some security problems that will be discussed in Section 
						<ce:cross-ref refid="s0060">4</ce:cross-ref>. Therefore, given any two interoperating security domains 
						<ce:italic>A</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf> and 
						<ce:italic>A</ce:italic>
						<ce:inf loc="post">
							<ce:italic>j</ce:italic>
						</ce:inf> then we assume that the attribute sets of both domains are always disjoint, 
						<ce:italic>A</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>∩
						<ce:hsp sp="0.25"/>
						<ce:italic>A</ce:italic>
						<ce:inf loc="post">
							<ce:italic>j</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>∅.
					</ce:para>
					<ce:para id="p0050" view="all">Each domain has a set of local users. Users may hold a subset of local attributes from its domain, which in turn acts as an Attribute Authority. We denote as 
						<ce:italic>u</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf>(
						<ce:italic>A</ce:italic>), the set of attributes that user 
						<ce:italic>u</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf> holds in domain 
						<ce:italic>A</ce:italic>. Under the presence of hierarchical relations between attributes of the same domain, such as role hierarchies in RBAC 
						<ce:cross-ref refid="b0035">[7]</ce:cross-ref>, 
						<ce:italic>u</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf>(
						<ce:italic>A</ce:italic>) stands for the attributes explicitly and implicitly (through the hierarchy of attributes) assigned to the user.
					</ce:para>
					<ce:para id="p0055" view="all">In order to enable interoperation of security policies between a set of domains we provide a mechanism to translate or convert attributes between the domains, through fuzzy relations. The interested reader is referred to 
						<ce:cross-ref refid="b0070">[14]</ce:cross-ref> for a background of fuzzy relations and fuzzy theory.
					</ce:para>
					<ce:section id="s0015" view="all">
						<ce:label>2.1</ce:label>
						<ce:section-title>Conversion through fuzzy relations</ce:section-title>
						<ce:para id="p0060" view="all">The conversion of attributes between two domains, 
							<ce:italic>A</ce:italic> and 
							<ce:italic>B</ce:italic>, is performed through a fuzzy relation between the set of attributes of the domains. This relation yields a 
							<ce:italic>conversion degree</ce:italic> associated to each pair of attributes in 
							<ce:italic>A</ce:italic>
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>
							<ce:italic>B</ce:italic>. A fuzzy set 
							<ce:italic>A</ce:italic> is denoted as 
							<ce:italic>A</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>{(
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>μ</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">1</ce:inf>)),
							<ce:hsp sp="0.12"/>(
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">2</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>μ</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">2</ce:inf>)),
							<ce:hsp sp="0.12"/>…}, where 
							<ce:italic>μ</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>) is the membership function for the element 
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf> in the set 
							<ce:italic>A</ce:italic>, and 
							<ce:italic>μ</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf> : 
							<ce:italic>X</ce:italic>
							<ce:hsp sp="0.25"/>→
							<ce:hsp sp="0.25"/>[0,
							<ce:hsp sp="0.12"/>1].
							<ce:enunciation id="n0015">
								<ce:label>Definition 1</ce:label>
								<ce:para id="p0595" view="all">The attribute conversion relation between two domains 
									<ce:italic>A</ce:italic> and 
									<ce:italic>B</ce:italic>, denoted as 
									<mml:math altimg="si3.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi mathvariant="script">C</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi mathvariant="italic">AB</mml:mi>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:math>, is a fuzzy relation between attributes of 
									<ce:italic>A</ce:italic> and 
									<ce:italic>B</ce:italic>, such that: 
									<mml:math altimg="si4.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi mathvariant="script">C</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi mathvariant="italic">AB</mml:mi>
												</mml:mrow>
											</mml:msub>
											<mml:mo>:</mml:mo>
											<mml:mi>A</mml:mi>
											<mml:mo>×</mml:mo>
											<mml:mi>B</mml:mi>
											<mml:mo>→</mml:mo>
											<mml:mo stretchy="false">[</mml:mo>
											<mml:mn>0</mml:mn>
											<mml:mtext>,</mml:mtext>
											<mml:mn>1</mml:mn>
											<mml:mo stretchy="false">]</mml:mo>
										</mml:mrow>
									</mml:math>. The relation determines the degree to which the owner of domain 
									<ce:italic>B</ce:italic> is willing to accept an attribute from domain 
									<ce:italic>A</ce:italic> as being equivalent to an attribute from domain 
									<ce:italic>B</ce:italic>.
								</ce:para>
							</ce:enunciation>
						</ce:para>
						<ce:para id="p0065" view="all">Intuitively, if 
							<mml:math altimg="si5.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>a</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>b</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mn>0.8</mml:mn>
								</mml:mrow>
							</mml:math>, it means that the owner (or administrative authority) of domain 
							<ce:italic>B</ce:italic> considers the attribute 
							<ce:italic>a</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>A</ce:italic> to be 0.8 equivalent to attribute 
							<ce:italic>b</ce:italic> in domain 
							<ce:italic>B</ce:italic> by the conversion relation 
							<mml:math altimg="si6.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>A</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mi>B</mml:mi>
								</mml:mrow>
							</mml:math>. As we will see in Section 
							<ce:cross-ref refid="s0060">4</ce:cross-ref>, the conversion degree is used by the authority in domain 
							<ce:italic>B</ce:italic> to decide whether or not to accept the conversion. The conversion relation, in the general case, is considered to be a fuzzy relation that is reflexive, transitive, and asymmetric. This type of relations are often called 
							<ce:italic>preordering</ce:italic> or 
							<ce:italic>quasi-ordering</ce:italic> relations.
						</ce:para>
						<ce:para id="p0070" view="all">Note that unlike similarity relations, the definition of attribute conversion is not necessarily symmetric. This is because a conversion, although it might be based on a similarity metric, is not necessarily a similarity metric. The fact that a given domain 
							<ce:italic>A</ce:italic> allows the conversion of attributes from domain 
							<ce:italic>B</ce:italic> does not imply that domain 
							<ce:italic>B</ce:italic> has to do the same. Even if domain 
							<ce:italic>B</ce:italic> allows conversion of attributes from 
							<ce:italic>A</ce:italic> the conversion parameters may be different. Consider for example the case where 
							<ce:italic>A</ce:italic> is the library of a town, and 
							<ce:italic>B</ce:italic> is the nuclear power plant of the same town. 
							<ce:italic>A</ce:italic> may allow the conversion of attributes from 
							<ce:italic>B</ce:italic> which may allow employees of 
							<ce:italic>B</ce:italic> to borrow books from 
							<ce:italic>A</ce:italic>, but 
							<ce:italic>B</ce:italic> will not allow conversion of attributes from 
							<ce:italic>A</ce:italic>.
						</ce:para>
						<ce:para id="p0075" view="all">It is also important to remark that the conversion relation 
							<mml:math altimg="si7.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> is defined and applied by the domain 
							<ce:italic>B</ce:italic> or the administrative authority of domain 
							<ce:italic>B</ce:italic>. In other words, the conversion relations must be defined in the target domain due to the fact that it is the target domain that takes the risk in the conversion. This is the primary reason for considering the conversion relation as asymmetric.
						</ce:para>
					</ce:section>
					<ce:section id="s0020" view="all">
						<ce:label>2.2</ce:label>
						<ce:section-title>Conversion modes</ce:section-title>
						<ce:para id="p0080" view="all">The way in which the conversion relation is used to convert attributes between two domains is determined by a 
							<ce:italic>conversion mode</ce:italic>. The mode yields a fuzzy set with the converted attributes and their associated conversion degree.
						</ce:para>
						<ce:para id="p0085" view="all">We use ⊥ to denote a 
							<ce:italic>t</ce:italic>-
							<ce:italic>conorm</ce:italic> representing the union of fuzzy sets. A t-conorm is a function ⊥ : [0,
							<ce:hsp sp="0.12"/>1]
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>[0,
							<ce:hsp sp="0.12"/>1]
							<ce:hsp sp="0.25"/>→
							<ce:hsp sp="0.25"/>[0,
							<ce:hsp sp="0.12"/>1], satisfying symmetry or commutativity, associativity, monotonicity, and with neutral element 0 
							<ce:cross-ref refid="b0155">[31]</ce:cross-ref>. Unless otherwise noted we will use the t-conorm operator ‘maximum’ as the standard union of fuzzy sets. Thus, for two sets 
							<ce:italic>A</ce:italic>, and 
							<ce:italic>B</ce:italic>, their union 
							<ce:italic>A</ce:italic>
							<ce:hsp sp="0.25"/>⊥
							<ce:hsp sp="0.25"/>
							<ce:italic>B</ce:italic> yields a fuzzy set with all elements 
							<ce:italic>x</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>A</ce:italic>, and 
							<ce:italic>x</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>B</ce:italic> and their respective membership function 
							<ce:italic>μ</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>⊥
								<ce:italic>B</ce:italic>
							</ce:inf>(
							<ce:italic>x</ce:italic>)
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>max(
							<ce:italic>μ</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>x</ce:italic>),
							<ce:hsp sp="0.12"/>
							<ce:italic>μ</ce:italic>
							<ce:inf loc="post">
								<ce:italic>B</ce:italic>
							</ce:inf>(
							<ce:italic>x</ce:italic>)).
						</ce:para>
						<ce:para id="p0090" view="all">Similarly, ⊤ denotes a 
							<ce:italic>t</ce:italic>-
							<ce:italic>norm</ce:italic> operand representing the intersection of fuzzy sets. A t-norm is a function ⊤ : [0,
							<ce:hsp sp="0.12"/>1]
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>[0,
							<ce:hsp sp="0.12"/>1]
							<ce:hsp sp="0.25"/>→
							<ce:hsp sp="0.25"/>[0,
							<ce:hsp sp="0.12"/>1] satisfying symmetry or commutativity, associativity, monotonicity, and with neutral element 1. Unless otherwise noted we will use the t-norm operator ‘minimum’ as the standard intersection of fuzzy sets. The use of the maximum and minimum as both the union and intersection of fuzzy sets guarantees some properties that other t-norms and t-conorms may not satisfy as will be seen in Section 
							<ce:cross-ref refid="s0035">3.1</ce:cross-ref>.
						</ce:para>
						<ce:para id="p0095" view="all">Given two domains 
							<ce:italic>A</ce:italic> and 
							<ce:italic>B</ce:italic> and a conversion relation 
							<mml:math altimg="si8.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math>, we define the following two modes:
							<ce:list id="l0010">
								<ce:list-item id="o0015">
									<ce:label>•</ce:label>
									<ce:para id="p0540" view="all">
										<ce:italic>Forward (or a priori)</ce:italic>: Given an attribute 
										<ce:italic>a</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>A</ce:italic>, then 
										<mml:math altimg="si9.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">F</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>a</mml:mi>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> retrieves all attributes in 
										<ce:italic>B</ce:italic> to which 
										<ce:italic>a</ce:italic> can be converted together with their conversion degree as the fuzzy set:
										<ce:display>
											<ce:formula id="e0010">
												<mml:math altimg="si10.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msubsup>
														<mml:mrow>
															<mml:mi mathvariant="script">F</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>a</mml:mi>
														</mml:mrow>
													</mml:msubsup>
													<mml:mo>=</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mi>⊥</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>b</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>∈</mml:mo>
															<mml:mi>B</mml:mi>
														</mml:mrow>
													</mml:munder>
													<mml:mo stretchy="false">{</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>b</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mtext>,</mml:mtext>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="script">C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mi>a</mml:mi>
													<mml:mtext>,</mml:mtext>
													<mml:msub>
														<mml:mrow>
															<mml:mi>b</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo stretchy="false">}</mml:mo>
												</mml:math>
											</ce:formula>
										</ce:display>This set 
										<mml:math altimg="si11.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">F</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>a</mml:mi>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> can be generalized for a subset 
										<ce:italic>P</ce:italic>
										<ce:hsp sp="0.25"/>⊆
										<ce:hsp sp="0.25"/>
										<ce:italic>A</ce:italic>, as:
										<ce:display>
											<ce:formula id="e0015">
												<mml:math altimg="si12.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msubsup>
														<mml:mrow>
															<mml:mi mathvariant="script">F</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>P</mml:mi>
														</mml:mrow>
													</mml:msubsup>
													<mml:mo>=</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mi>⊥</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>a</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>∈</mml:mo>
															<mml:mi>P</mml:mi>
														</mml:mrow>
													</mml:munder>
													<mml:msubsup>
														<mml:mrow>
															<mml:mi mathvariant="script">F</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>a</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:msubsup>
												</mml:math>
											</ce:formula>
										</ce:display>This last fuzzy set can be used to determine the conversion of the attributes for a given user, for example 
										<mml:math altimg="si13.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">F</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>u</mml:mi>
														<mml:mo stretchy="false">(</mml:mo>
														<mml:mi>A</mml:mi>
														<mml:mo stretchy="false">)</mml:mo>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math>, or a subset of such attributes. The forward conversion mode will normally be used when the users need to convert their attributes before queering an action to a foreign domain. Thus, it is more suitable for 
										<ce:italic>push</ce:italic> access control models.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0020">
									<ce:label>•</ce:label>
									<ce:para id="p0545" view="all">
										<ce:italic>Backward (or on-demand)</ce:italic>: Given an attribute 
										<ce:italic>b</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>B</ce:italic> then 
										<mml:math altimg="si14.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">B</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>b</mml:mi>
														<mml:mtext>,</mml:mtext>
														<mml:mi>u</mml:mi>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> retrieves all the attributes in 
										<ce:italic>A</ce:italic> that can be converted to 
										<ce:italic>b</ce:italic> for a given user 
										<ce:italic>u</ce:italic>. We define such conversion as a fuzzy set, which contains all the attributes 
										<ce:italic>a</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>u</ce:italic>(
										<ce:italic>A</ce:italic>) that can be converted to attribute 
										<ce:italic>b</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>B</ce:italic> with their conversion degree as the membership function of the fuzzy set:
										<ce:display>
											<ce:formula id="e0020">
												<mml:math altimg="si15.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msubsup>
														<mml:mrow>
															<mml:mi mathvariant="script">B</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>b</mml:mi>
															<mml:mtext>,</mml:mtext>
															<mml:mi>u</mml:mi>
														</mml:mrow>
													</mml:msubsup>
													<mml:mo>=</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mi>⊥</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>a</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>∈</mml:mo>
															<mml:mi>u</mml:mi>
															<mml:mo stretchy="false">(</mml:mo>
															<mml:mi>A</mml:mi>
															<mml:mo stretchy="false">)</mml:mo>
														</mml:mrow>
													</mml:munder>
													<mml:mo stretchy="false">{</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>a</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mtext>,</mml:mtext>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="script">C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>a</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mtext>,</mml:mtext>
													<mml:mi>b</mml:mi>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo stretchy="false">}</mml:mo>
												</mml:math>
											</ce:formula>
										</ce:display>This set can also be generalized for a subset 
										<ce:italic>Q</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>B</ce:italic> as:
										<ce:display>
											<ce:formula id="e0025">
												<mml:math altimg="si16.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msubsup>
														<mml:mrow>
															<mml:mi mathvariant="script">B</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>Q</mml:mi>
															<mml:mtext>,</mml:mtext>
															<mml:mi>u</mml:mi>
														</mml:mrow>
													</mml:msubsup>
													<mml:mo>=</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mi>⊥</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>b</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>∈</mml:mo>
															<mml:mi>Q</mml:mi>
														</mml:mrow>
													</mml:munder>
													<mml:msubsup>
														<mml:mrow>
															<mml:mi mathvariant="script">B</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>b</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:msubsup>
												</mml:math>
											</ce:formula>
										</ce:display>This conversion mode is specially suited for a 
										<ce:italic>pull</ce:italic> access control modes. For example, when domain 
										<ce:italic>B</ce:italic> establishes that user 
										<ce:italic>u</ce:italic> needs attribute 
										<ce:italic>b</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>B</ce:italic> in order to fulfill its access request.
									</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
						<ce:para id="p0100" view="all">We normally refer to the generalized modes when naming a conversion mode. Furthermore, we are normally interested in the 
							<ce:italic>support</ce:italic> of such fuzzy sets, that is, the elements of the set with a membership function greater than 0. We always refer to the support of the fuzzy when referring to a fuzzy set. Two generic conversion modes are provided, however, other modes can be defined in order to deal with specific requirements of applications.
						</ce:para>
					</ce:section>
					<ce:section id="s0025" view="all">
						<ce:label>2.3</ce:label>
						<ce:section-title>Example</ce:section-title>
						<ce:para id="p0105" view="all">Let 
							<mml:math altimg="si17.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> be the conversion relation between the domains 
							<ce:italic>A</ce:italic> and 
							<ce:italic>B</ce:italic>, represented as the membership matrix:
							<ce:display>
								<ce:formula id="e0030">
									<mml:math altimg="si18.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mtext>
											<ce:inline-figure baseline="0.0">
												<ce:link locator="fx1"/>
											</ce:inline-figure>
										</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
						<ce:para id="p0110" view="all">Then, the forward conversion of the attribute 
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">1</ce:inf> from domain 
							<ce:italic>A</ce:italic> has the following result:
							<ce:display>
								<ce:formula id="e0035">
									<mml:math altimg="si19.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="script">F</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>a</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:mo stretchy="false">{</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>b</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0.0</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>b</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0.9</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>b</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>3</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0.1</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">}</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>The support of the forward conversion being:
							<ce:display>
								<ce:formula id="e0040">
									<mml:math altimg="si20.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="script">F</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>a</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:mo stretchy="false">{</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>b</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0.9</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>b</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>3</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0.1</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">}</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>The backward conversion of the attribute 
							<ce:italic>b</ce:italic>
							<ce:inf loc="post">2</ce:inf>, given a user 
							<ce:italic>u</ce:italic> from domain 
							<ce:italic>A</ce:italic> with the following attribute set 
							<ce:italic>u</ce:italic>(
							<ce:italic>A</ce:italic>)
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>{
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>a</ce:italic>
							<ce:inf loc="post">2</ce:inf>} is:
							<ce:display>
								<ce:formula id="e0045">
									<mml:math altimg="si21.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="script">B</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>b</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:msub>
												<mml:mtext>,</mml:mtext>
												<mml:mi>u</mml:mi>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:mo stretchy="false">{</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>a</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0.9</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">}</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0030" view="all">
					<ce:label>3</ce:label>
					<ce:section-title>Enabling interoperation in groups of domains</ce:section-title>
					<ce:para id="p0115" view="all">This section considers the scenario whereby there is a set of domains (Δ) under security interoperation, and each user of any domain wishes to convert her attributes to the attributes from any other domain. Ideally, each domain has a conversion function for all other domains. This means having to define ∣Δ
						<ce:sup loc="post">2</ce:sup>∣
						<ce:hsp sp="0.25"/>−
						<ce:hsp sp="0.25"/>∣Δ∣ conversion relations. Moreover, if we want to add a new domain, we will need to define ∣Δ∣ new conversion relations, and all other domains will need to define a conversion relation for the new domain. It is clear that as the number of domains increases this approach becomes less scalable.
					</ce:para>
					<ce:para id="p0120" view="all">An intuitive and more flexible approach is to allow each domain to define the relations it needs or it wants. These relationships may be defined based on previous knowledge and/or trust relations with the other domains. Conversion between all nodes can be achieved by chaining attribute conversions from the origin node to the destination by using the existing relations.</ce:para>
					<ce:section id="s0035" view="all">
						<ce:label>3.1</ce:label>
						<ce:section-title>Chaining attribute conversions</ce:section-title>
						<ce:para id="p0125" view="all">By chaining or composing attribute conversions, an attribute converted from domain 
							<ce:italic>A</ce:italic> to domain 
							<ce:italic>B</ce:italic>, can be further converted to another domain 
							<ce:italic>C</ce:italic> (see 
							<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref>
							<ce:float-anchor refid="f0005"/>). This transitivity can be achieved by composition of the conversion relations.
						</ce:para>
						<ce:para id="p0130" view="all">We define the composition of conversion relations as 
							<mml:math altimg="si22.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo>∘</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">BC</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo>:</mml:mo>
									<mml:mi>A</mml:mi>
									<mml:mo>×</mml:mo>
									<mml:mi>C</mml:mi>
									<mml:mo>→</mml:mo>
									<mml:mo stretchy="false">[</mml:mo>
									<mml:mn>0</mml:mn>
									<mml:mtext>,</mml:mtext>
									<mml:mn>1</mml:mn>
									<mml:mo stretchy="false">]</mml:mo>
								</mml:mrow>
							</mml:math>, denoted as 
							<mml:math altimg="si23.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mi>T</mml:mi>
									<mml:mo>=</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo>∘</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">BC</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math>, and determined for 
							<ce:italic>a</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>A</ce:italic>, and 
							<ce:italic>c</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic> by:
							<ce:display>
								<ce:formula id="e0050">
									<mml:math altimg="si24.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>a</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mi>⊥</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>b</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi>B</mml:mi>
											</mml:mrow>
										</mml:munder>
										<mml:mi>⊤</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>a</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>b</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">BC</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>b</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>where ⊥ denotes a t-conorm and ⊤ a t-norm operand. We use the standard max–min composition with ⊥
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>max, ⊤
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>min, thus
							<ce:display>
								<ce:formula id="e0005">
									<ce:label>(1)</ce:label>
									<mml:math altimg="si25.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>a</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mi mathvariant="normal">max</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>b</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi>B</mml:mi>
											</mml:mrow>
										</mml:munder>
										<mml:mrow>
											<mml:mi mathvariant="normal">min</mml:mi>
										</mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>a</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>b</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">BC</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>b</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
						<ce:para id="p0135" view="all">The use of the max–min composition provides a better interpretation of the composition of conversion relations than other t-norms and t-conorms. The monotonicity of a t-norm ensures that its use for aggregating equivalence along a conversion chain does not result in an amplification of the conversion degree. Min is the largest t-norm. T-conorm based aggregation of conversion degrees provides monotonic attribute conversion, that is, adding further attribute conversion relations to a conversion chain does not result in a decrease of the conversion degree. The max operator is the smallest t-conorm. To ensure that a domain does not forwards more attribute equivalence than it has accumulated, we use the max–min composition, which does not necessarily generalize to other t-norm/conorm 
							<ce:cross-ref refid="b0045">[9]</ce:cross-ref>.
						</ce:para>
					</ce:section>
					<ce:section id="s0040" view="all">
						<ce:label>3.2</ce:label>
						<ce:section-title>Conversion graphs</ce:section-title>
						<ce:para id="p0140" view="all">A group of domains together with their conversion relations form a 
							<ce:italic>conversion graph</ce:italic>, that can be used to convert attributes between each pair of domains in the graph, as illustrated in 
							<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref>
							<ce:float-anchor refid="f0010"/>. In such directed graphs, the set of nodes is the set of domains and the arcs are the conversion relations. Recall from Section 
							<ce:cross-ref refid="s0015">2.1</ce:cross-ref>, that the conversion relations are not symmetric (hence, the use of a directed graph).
						</ce:para>
						<ce:para id="p0145" view="all">The aim of the conversion graphs is, given an origin domain 
							<ce:italic>A</ce:italic> and a target domain 
							<ce:italic>B</ce:italic>, to find out how attributes from 
							<ce:italic>A</ce:italic> can be converted to attributes of 
							<ce:italic>B</ce:italic>, by providing the best conversion possible for each attribute. That is, to maximize the final conversion degree. The chained composition should provide a final conversion relation of the form:
							<ce:display>
								<ce:formula id="e0055">
									<mml:math altimg="si26.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>:</mml:mo>
										<mml:mi>A</mml:mi>
										<mml:mo>×</mml:mo>
										<mml:mi>B</mml:mi>
										<mml:mo>→</mml:mo>
										<mml:mo stretchy="false">[</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">]</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
						<ce:section id="s0045" view="all">
							<ce:label>3.2.1</ce:label>
							<ce:section-title>Finding the maximal conversion relation</ce:section-title>
							<ce:para id="p0150" view="all">To compute an attribute conversion between two domains 
								<ce:italic>A</ce:italic> and 
								<ce:italic>B</ce:italic>, we need to find all the possible paths between them. This can be achieved by a loop-less Breadth First Search (BFS). It is important to identify loop-less paths as a cyclic path can allow a user to gain privileges in its own domain and also can allow a user to increase its privileges in the target domain with multiple loops through the path. This may threaten the Principle of Security 
								<ce:cross-ref refid="b0055">[11]</ce:cross-ref>.
							</ce:para>
							<ce:para id="p0155" view="all">For each loop-less path we compute the composition of all the relations in order to find the path’s relation from the origin to the target domain. The maximal relation is then computed as the union of each path’s relation. This relation of the type 
								<mml:math altimg="si27.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>:</mml:mo>
										<mml:mi>A</mml:mi>
										<mml:mo>×</mml:mo>
										<mml:mi>B</mml:mi>
										<mml:mo>→</mml:mo>
										<mml:mo stretchy="false">[</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mn>1</mml:mn>
										<mml:mo stretchy="false">]</mml:mo>
									</mml:mrow>
								</mml:math> allows conversion of attributes from 
								<ce:italic>A</ce:italic> to 
								<ce:italic>B</ce:italic>. The process is described in 
								<ce:cross-ref refid="s0165">Appendix A.1</ce:cross-ref> (Algorithm 1), and is based on a loop-less BFS search for finding all loop less paths.
							</ce:para>
							<ce:para id="p0160" view="all">Note that once the relation has been computed, converting attributes in forward or backward mode over 
								<mml:math altimg="si28.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:math> must be done as explained in Section 
								<ce:cross-ref refid="s0020">2.2</ce:cross-ref>. The attribute conversion mode through a relation is transparent regardless of whether the relation was directly defined or has been computed through the composition of other conversion relations.
							</ce:para>
						</ce:section>
						<ce:section id="s0050" view="all">
							<ce:label>3.2.2</ce:label>
							<ce:section-title>Restricting the number of paths: sub-optimal solutions</ce:section-title>
							<ce:para id="p0165" view="all">As the number of domains and conversion relations grow in the scenario, finding all the paths between two domains may not be computationally viable. To that end, instead of considering all possible loop less paths between two nodes, we provide a new approach to return a bounded number of paths between them.</ce:para>
							<ce:para id="p0170" view="all">We propose two different methods in order to select the paths involved in finding a sub-optimal solution. Both are based on a Yen’s algorithm 
								<ce:cross-ref refid="b0165">[33]</ce:cross-ref> implementation 
								<ce:cross-ref refid="b0120">[24]</ce:cross-ref> which returns a given number of shortest loop-less paths. Both methods rely on associating a weight to each arc or path in the graph. That is, a weight associated to the relation represented by the arc of path.
							</ce:para>
							<ce:para id="p0175" view="all">Given two sets of permissions, 
								<ce:italic>X</ce:italic> and 
								<ce:italic>Y</ce:italic>, and their conversion relation 
								<mml:math altimg="si29.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">XY</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:math>, we define the weight of the relation, denoted as 
								<mml:math altimg="si30.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi>W</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">XY</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math>, as the inverse of the mean of the values in the relations:
								<ce:display>
									<ce:formula id="e0060">
										<mml:math altimg="si31.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mi>W</mml:mi>
											<mml:mo stretchy="false">(</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi mathvariant="script">C</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi mathvariant="italic">XY</mml:mi>
												</mml:mrow>
											</mml:msub>
											<mml:mo stretchy="false">)</mml:mo>
											<mml:mo>=</mml:mo>
											<mml:mfrac>
												<mml:mrow>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mi>X</mml:mi>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mi>Y</mml:mi>
													<mml:mo stretchy="false">|</mml:mo>
												</mml:mrow>
												<mml:mrow>
													<mml:msubsup>
														<mml:mrow>
															<mml:mo>∑</mml:mo>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
															<mml:mo>=</mml:mo>
															<mml:mn>1</mml:mn>
														</mml:mrow>
														<mml:mrow>
															<mml:mo stretchy="false">|</mml:mo>
															<mml:mi>X</mml:mi>
															<mml:mo stretchy="false">|</mml:mo>
														</mml:mrow>
													</mml:msubsup>
													<mml:msubsup>
														<mml:mrow>
															<mml:mo>∑</mml:mo>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>j</mml:mi>
															<mml:mo>=</mml:mo>
															<mml:mn>1</mml:mn>
														</mml:mrow>
														<mml:mrow>
															<mml:mo stretchy="false">|</mml:mo>
															<mml:mi>Y</mml:mi>
															<mml:mo stretchy="false">|</mml:mo>
														</mml:mrow>
													</mml:msubsup>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="script">C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">XY</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mi>i</mml:mi>
													<mml:mtext>,</mml:mtext>
													<mml:mi>j</mml:mi>
													<mml:mo stretchy="false">)</mml:mo>
												</mml:mrow>
											</mml:mfrac>
										</mml:math>
									</ce:formula>
								</ce:display>
							</ce:para>
							<ce:para id="p0180" view="all">This weight prioritizes the relations which yield a greater conversion degree. Moreover, relations with general lower values get quickly discarded as opposed to relations with greater values. Relations with all zero values are weighted as ∞. Note that a path with an ∞-weighted relations does not contribute to the solution and should be discarded. Empirical analysis has shown this weight to be better than other ones in reducing the marginal error (cf. Section 
								<ce:cross-ref refid="s0095">5</ce:cross-ref>), such as the complementary of normalized mean, and several parametrization of weighted means, and ordered weighted averaging (OWA) operators.
							</ce:para>
							<ce:para id="p0185" view="all">We have defined two different methods, which determine how this weight is applied in our modification of Yen’s algorithm.
								<ce:list id="l0025">
									<ce:list-item id="o0060">
										<ce:label>
											<ce:bold>Method 1.</ce:bold>
										</ce:label>
										<ce:para id="p0585" view="all">We directly apply Yen’s algorithm. For all neighborhood relations 
											<mml:math altimg="si32.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
												<mml:mrow>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="script">C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">XY</mml:mi>
														</mml:mrow>
													</mml:msub>
												</mml:mrow>
											</mml:math> between two arbitrary domains 
											<ce:italic>X</ce:italic> and 
											<ce:italic>Y</ce:italic>, the weight 
											<mml:math altimg="si33.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
												<mml:mrow>
													<mml:mi>W</mml:mi>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="script">C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">XY</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
												</mml:mrow>
											</mml:math> is directly applied to the arc. We then compute the 
											<ce:italic>N</ce:italic>
											<ce:inf loc="post">
												<ce:italic>p</ce:italic>
											</ce:inf> shortest paths with accumulative weights, where the weight of every explored sub-path 
											<ce:italic>p</ce:italic> is computed as the sum of all the weights of every relation 
											<ce:italic>r</ce:italic> in 
											<ce:italic>p</ce:italic>.
										</ce:para>
									</ce:list-item>
									<ce:list-item id="o0065">
										<ce:label>
											<ce:bold>Method 2.</ce:bold>
										</ce:label>
										<ce:para id="p0590" view="all">In this case, we compute the 
											<ce:italic>N</ce:italic>
											<ce:inf loc="post">
												<ce:italic>p</ce:italic>
											</ce:inf> shortest paths, but instead of using accumulative weights as in Method 1, the weight of every explored sub-path 
											<ce:italic>p</ce:italic> is computed as the weight of the composition of all relations 
											<ce:italic>r</ce:italic> in the path 
											<ce:italic>p</ce:italic>. The algorithm is detailed in 
											<ce:cross-ref refid="s0170">Appendix A.2</ce:cross-ref> (Algorithm 2).
										</ce:para>
										<ce:para id="p0190" view="all">Note that Yen’s algorithm starts by finding the shortest loop less path with an external algorithm to find a shortest loop less path. Following the same strategy as above, we adapt Dijkstra’s algorithm (see 
											<ce:cross-ref refid="s0170">Appendix A.2</ce:cross-ref>, Algorithm ShortestLooplessPath), that is, instead of accumulating the weights of each arc (relation), the weight is computed based on the composition of all relations for each sub-path.
										</ce:para>
									</ce:list-item>
								</ce:list>
							</ce:para>
							<ce:para id="p0195" view="all">Note that without exploring all the paths it is not possible to ensure that the maximal relation will be found. It is noteworthy to point out that, by 
								<ce:cross-ref refid="n0010">Proposition 1</ce:cross-ref>, sub-optimal solutions never overestimate the optimal solution. Thus, the error induced by restricting the number of paths works against usability rather than security.
								<ce:enunciation id="n0010">
									<ce:label>Proposition 1</ce:label>
									<ce:para id="p0600" view="all">
										<ce:italic>Sub-optimal solutions</ce:italic>
										<mml:math altimg="si34.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:mrow>
													<mml:mfenced open="(" close=")">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi mathvariant="script">C</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi mathvariant="italic">AB</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mo>′</mml:mo>
																</mml:mrow>
															</mml:msubsup>
														</mml:mrow>
													</mml:mfenced>
												</mml:mrow>
											</mml:mrow>
										</mml:math>
										<ce:italic>never overestimate the optimal solution</ce:italic>
										<mml:math altimg="si35.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:math>
										<ce:italic>.</ce:italic>
									</ce:para>
								</ce:enunciation>
								<ce:enunciation id="n0005">
									<ce:label>Proof</ce:label>
									<ce:para id="p0605" view="all">Let 
										<ce:italic>P</ce:italic>′ be the set of 
										<ce:italic>N</ce:italic>
										<ce:inf loc="post">
											<ce:italic>p</ce:italic>
										</ce:inf> paths of the sub-optimal solution, and 
										<ce:italic>P</ce:italic> is the set of all paths taking part of the optimal solution. Then, 
										<ce:italic>P</ce:italic>′
										<ce:hsp sp="0.25"/>⊆
										<ce:hsp sp="0.25"/>
										<ce:italic>P</ce:italic>.
									</ce:para>
									<ce:para id="p0200" view="all">Let us assume that a sub-optimal solution overestimates the optimal solution: 
										<mml:math altimg="si36.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
												<mml:mo>&gt;</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:math>. That is 
										<mml:math altimg="si37.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>a</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi>b</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>=</mml:mo>
												<mml:mo stretchy="false">{</mml:mo>
												<mml:mo>∃</mml:mo>
												<mml:mi>a</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi>A</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi>b</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi>B</mml:mi>
												<mml:mo stretchy="false">|</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msubsup>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>a</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi>b</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>&gt;</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>a</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi>b</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">}</mml:mo>
											</mml:mrow>
										</mml:math>
									</ce:para>
									<ce:para id="p0205" view="all">If 
										<ce:italic>P</ce:italic>′
										<ce:hsp sp="0.25"/>⊆
										<ce:hsp sp="0.25"/>
										<ce:italic>P</ce:italic>, then 
										<mml:math altimg="si38.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:mo stretchy="false">{</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
												</mml:msubsup>
												<mml:mo stretchy="false">}</mml:mo>
												<mml:mo>⊆</mml:mo>
												<mml:mo stretchy="false">{</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
												</mml:msubsup>
												<mml:mo stretchy="false">}</mml:mo>
											</mml:mrow>
										</mml:math>, for all 
										<ce:italic>i</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>P</ce:italic>′, and all 
										<ce:italic>j</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>P</ce:italic>.
									</ce:para>
									<ce:para id="p0210" view="all">As 
										<mml:math altimg="si39.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo>:</mml:mo>
												<mml:munder>
													<mml:mrow>
														<mml:mi>⊥</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>p</mml:mi>
														<mml:mo>∈</mml:mo>
														<mml:mi>P</mml:mi>
													</mml:mrow>
												</mml:munder>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>p</mml:mi>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math>
									</ce:para>
									<ce:para id="p0215" view="all">And the ⊥ operand of any two 
										<mml:math altimg="si40.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">XY</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> and 
										<mml:math altimg="si41.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">XY</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> is defined as 
										<mml:math altimg="si42.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:mi>⊥</mml:mi>
												<mml:mrow>
													<mml:mfenced open="(" close=")">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi mathvariant="script">C</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi mathvariant="italic">XY</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
															</mml:msubsup>
															<mml:mtext>,</mml:mtext>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi mathvariant="script">C</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi mathvariant="italic">XY</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																</mml:mrow>
															</mml:msubsup>
														</mml:mrow>
													</mml:mfenced>
												</mml:mrow>
												<mml:mo>=</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="normal">max</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>x</mml:mi>
														<mml:mo>∈</mml:mo>
														<mml:mi>X</mml:mi>
														<mml:mtext>,</mml:mtext>
														<mml:mi>y</mml:mi>
														<mml:mo>∈</mml:mo>
														<mml:mi>Y</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mrow>
													<mml:mfenced open="(" close=")">
														<mml:mrow>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi mathvariant="script">C</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi mathvariant="italic">XY</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
															</mml:msubsup>
															<mml:mo stretchy="false">(</mml:mo>
															<mml:mi>x</mml:mi>
															<mml:mtext>,</mml:mtext>
															<mml:mi>y</mml:mi>
															<mml:mo stretchy="false">)</mml:mo>
															<mml:mtext>,</mml:mtext>
															<mml:msubsup>
																<mml:mrow>
																	<mml:mi mathvariant="script">C</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi mathvariant="italic">XY</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																</mml:mrow>
															</mml:msubsup>
															<mml:mo stretchy="false">(</mml:mo>
															<mml:mi>x</mml:mi>
															<mml:mtext>,</mml:mtext>
															<mml:mi>y</mml:mi>
															<mml:mo stretchy="false">)</mml:mo>
														</mml:mrow>
													</mml:mfenced>
												</mml:mrow>
											</mml:mrow>
										</mml:math>
									</ce:para>
									<ce:para id="p0220" view="all">The definition of the union operand itself, leads 
										<mml:math altimg="si43.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo>&gt;</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:math> to a contradiction.
										<ce:hsp sp="1"/>□
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0225" view="all">In order to determine the error introduced by sub-optimal solutions 
								<mml:math altimg="si44.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mrow>
											<mml:mfenced open="(" close=")">
												<mml:mrow>
													<mml:msubsup>
														<mml:mrow>
															<mml:mi mathvariant="script">C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">AB</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mo>′</mml:mo>
														</mml:mrow>
													</mml:msubsup>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
									</mml:mrow>
								</mml:math>, we compute the distance between 
								<mml:math altimg="si45.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:math> and the optimal solution 
								<mml:math altimg="si46.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math>. We compute the average of the difference, value by value, between 
								<mml:math altimg="si47.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:math> and 
								<mml:math altimg="si48.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>:
								<ce:display>
									<ce:formula id="e0065">
										<mml:math altimg="si49.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mi>ε</mml:mi>
											<mml:mo>=</mml:mo>
											<mml:mfrac>
												<mml:mrow>
													<mml:mn>1</mml:mn>
												</mml:mrow>
												<mml:mrow>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mi>A</mml:mi>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mi>B</mml:mi>
													<mml:mo stretchy="false">|</mml:mo>
												</mml:mrow>
											</mml:mfrac>
											<mml:munderover>
												<mml:mrow>
													<mml:mo>∑</mml:mo>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>i</mml:mi>
													<mml:mo>=</mml:mo>
													<mml:mn>1</mml:mn>
												</mml:mrow>
												<mml:mrow>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mi>A</mml:mi>
													<mml:mo stretchy="false">|</mml:mo>
												</mml:mrow>
											</mml:munderover>
											<mml:munderover>
												<mml:mrow>
													<mml:mo>∑</mml:mo>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>j</mml:mi>
													<mml:mo>=</mml:mo>
													<mml:mn>1</mml:mn>
												</mml:mrow>
												<mml:mrow>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mi>B</mml:mi>
													<mml:mo stretchy="false">|</mml:mo>
												</mml:mrow>
											</mml:munderover>
											<mml:mrow>
												<mml:mfenced open="(" close=")">
													<mml:mrow>
														<mml:msub>
															<mml:mrow>
																<mml:mi mathvariant="script">C</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mi mathvariant="italic">AB</mml:mi>
															</mml:mrow>
														</mml:msub>
														<mml:mo stretchy="false">(</mml:mo>
														<mml:mi>i</mml:mi>
														<mml:mtext>,</mml:mtext>
														<mml:mi>j</mml:mi>
														<mml:mo stretchy="false">)</mml:mo>
														<mml:mo>-</mml:mo>
														<mml:msubsup>
															<mml:mrow>
																<mml:mi mathvariant="script">C</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mi mathvariant="italic">AB</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mo>′</mml:mo>
															</mml:mrow>
														</mml:msubsup>
														<mml:mo stretchy="false">(</mml:mo>
														<mml:mi>i</mml:mi>
														<mml:mtext>,</mml:mtext>
														<mml:mi>j</mml:mi>
														<mml:mo stretchy="false">)</mml:mo>
													</mml:mrow>
												</mml:mfenced>
											</mml:mrow>
										</mml:math>
									</ce:formula>
								</ce:display>
							</ce:para>
						</ce:section>
					</ce:section>
					<ce:section id="s0055" view="all">
						<ce:label>3.3</ce:label>
						<ce:section-title>Example</ce:section-title>
						<ce:para id="p0230" view="all">Let 
							<mml:math altimg="si50.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:mspace width="0.35em"/>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">BD</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:mspace width="0.35em"/>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AC</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> and 
							<mml:math altimg="si51.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">CD</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> be the conversion relations defined in the simple scenario shown in 
							<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>
							<ce:float-anchor refid="f0015"/>, where:
							<ce:display>
								<ce:formula id="e0070">
									<mml:math altimg="si52.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="[" close="]">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0.0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.9</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.1</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>1.0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.0</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0.2</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.5</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.95</mml:mn>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="1em"/>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">BD</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="[" close="]">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>1</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>1</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>1</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
									</mml:math>
								</ce:formula>
							</ce:display>
							<ce:display>
								<ce:formula id="e0075">
									<mml:math altimg="si53.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AC</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="[" close="]">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.9</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0.8</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.2</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0.2</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.1</mml:mn>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="1em"/>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">CD</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="[" close="]">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>1</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.8</mml:mn>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
						<ce:para id="p0235" view="all">We want to compute the optimal relation between domain 
							<ce:italic>A</ce:italic> and domain 
							<ce:italic>D</ce:italic>. In order to do that, we compute all the paths between the domains. The list of paths is 
							<mml:math altimg="si54.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mo stretchy="false">{</mml:mo>
									<mml:mo stretchy="false">{</mml:mo>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>A</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>B</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mtext>,</mml:mtext>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>B</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>D</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo stretchy="false">}</mml:mo>
									<mml:mtext>,</mml:mtext>
									<mml:mo stretchy="false">{</mml:mo>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>A</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>C</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mtext>,</mml:mtext>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>C</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>D</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo stretchy="false">}</mml:mo>
									<mml:mo stretchy="false">}</mml:mo>
								</mml:mrow>
							</mml:math>. Every path generates a conversion relation between 
							<ce:italic>A</ce:italic> and 
							<ce:italic>D</ce:italic>, where 
							<mml:math altimg="si55.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AD</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
										</mml:mrow>
									</mml:msubsup>
									<mml:mo>=</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo>∘</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">BD</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> and 
							<mml:math altimg="si56.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AD</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
										</mml:mrow>
									</mml:msubsup>
									<mml:mo>=</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AC</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo>∘</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">CD</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math>.
							<ce:display>
								<ce:formula id="e0080">
									<mml:math altimg="si57.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AD</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="[" close="]">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.9</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.1</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>1</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0.2</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.5</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.95</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="1em"/>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AD</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="[" close="]">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.8</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0.8</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>02</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0.2</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.1</mml:mn>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
						<ce:para id="p0240" view="all">The resulting 
							<mml:math altimg="si58.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AD</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> is computed as 
							<mml:math altimg="si59.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AD</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
										</mml:mrow>
									</mml:msubsup>
									<mml:mi>⊥</mml:mi>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AD</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>2</mml:mn>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math>
							<ce:display>
								<ce:formula id="e0085">
									<mml:math altimg="si60.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AD</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mrow>
											<mml:mfenced open="[" close="]">
												<mml:mrow>
													<mml:mtable>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.9</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.1</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.8</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>1</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.2</mml:mn>
															</mml:mtd>
														</mml:mtr>
														<mml:mtr>
															<mml:mtd columnalign="center">
																<mml:mn>0.2</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.5</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.95</mml:mn>
															</mml:mtd>
															<mml:mtd columnalign="center">
																<mml:mn>0.1</mml:mn>
															</mml:mtd>
														</mml:mtr>
													</mml:mtable>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
						<ce:para id="p0245" view="all">If we restrict the number of paths to 1, weighting every relation in the conversion graph as 
							<mml:math altimg="si61.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mi>W</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mn>2.465</mml:mn>
									<mml:mtext>,</mml:mtext>
									<mml:mi>W</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">BD</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mn>4</mml:mn>
									<mml:mtext>,</mml:mtext>
									<mml:mi>W</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AC</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mn>2.727</mml:mn>
								</mml:mrow>
							</mml:math> and 
							<mml:math altimg="si62.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mi>W</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">CD</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mn>4.44</mml:mn>
								</mml:mrow>
							</mml:math>. The shortest path, found by using Dijkstra and computed with accumulative weights, is depicted as {(
							<ce:italic>A</ce:italic>,
							<ce:hsp sp="0.12"/>
							<ce:italic>B</ce:italic>),
							<ce:hsp sp="0.12"/>(
							<ce:italic>B</ce:italic>,
							<ce:hsp sp="0.12"/>
							<ce:italic>D</ce:italic>)}, then the suboptimal solution is 
							<mml:math altimg="si63.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AD</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> and the error introduced by 
							<mml:math altimg="si64.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AD</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mn>1</mml:mn>
										</mml:mrow>
									</mml:msubsup>
								</mml:mrow>
							</mml:math> is 0.084.
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0060" view="all">
					<ce:label>4</ce:label>
					<ce:section-title>Attribute enforcement</ce:section-title>
					<ce:para id="p0250" view="all">When an attribute is converted as described in Section 
						<ce:cross-ref refid="s0010">2</ce:cross-ref>, then the result is a 
						<ce:italic>converted attribute</ce:italic>. These converted attributes differ from the local attributes and are treated in a different manner. We provide enforcement mechanisms in order to control the conditions under which a converted attribute can be used.
					</ce:para>
					<ce:para id="p0255" view="all">The enforcement step to generate local attributes understandable in the target domain is carried out in two steps by the Attribute Conversion Module (ACM) shown in 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>
						<ce:float-anchor refid="f0020"/>. The ACM is composed of two main elements. The 
						<ce:italic>Conversion Service</ce:italic> performs the actual attribute conversion and outputs 
						<ce:italic>converted attributes</ce:italic> based on foreign attributes input. Given a 
						<ce:italic>converted attribute</ce:italic> and the current context, the 
						<ce:italic>Conversion Enforcement</ce:italic> component outputs a
						<ce:italic>local attribute</ce:italic>, that can be used by the local access control module (see 
						<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>).
					</ce:para>
					<ce:para id="p0260" view="all">A 
						<ce:italic>local attribute</ce:italic> is encoded as a certificate with the following structure:
						<ce:display>
							<ce:formula id="e0090">
								<mml:math altimg="si65.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:msub>
										<mml:mrow>
											<mml:mi>S</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>D</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi mathvariant="italic">attr</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>D</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>s</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>V</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
								</mml:math>
							</ce:formula>
						</ce:display>where 
						<ce:italic>attr</ce:italic> is the attribute itself, 
						<ce:italic>D</ce:italic> is the domain where the attribute is defined, 
						<ce:italic>s</ce:italic> is the subject of the certificate, thus, the user, and 
						<ce:italic>V</ce:italic> is a validity specification. Finally, the certificate may be signed by the domain authority to avoid forging. 
						<ce:italic>S</ce:italic>
						<ce:inf loc="post">
							<ce:italic>D</ce:italic>
						</ce:inf> denotes the digital signature of the authority from domain 
						<ce:italic>D</ce:italic>. Attributes can be certified for example using X.509 attribute certificates 
						<ce:cross-ref refid="b0030">[6]</ce:cross-ref>, or SAML attribute statement assertions 
						<ce:cross-ref refid="b0130">[26]</ce:cross-ref>.
					</ce:para>
					<ce:section id="s0065" view="all">
						<ce:label>4.1</ce:label>
						<ce:section-title>Converted attributes</ce:section-title>
						<ce:para id="p0265" view="all">The 
							<ce:italic>converted attributes</ce:italic> have a special form, which cannot be directly used by the local access control module. Such attributes keep important information regarding the conversion process. More precisely, a converted attribute is denoted as:
							<ce:display>
								<ce:formula id="e0095">
									<mml:math altimg="si66.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi>S</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>Y</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mo stretchy="false">〈</mml:mo>
										<mml:mi mathvariant="italic">origin</mml:mi>
										<mml:mo>_</mml:mo>
										<mml:mi mathvariant="italic">attr</mml:mi>
										<mml:mo stretchy="false">〉</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:mo stretchy="false">〈</mml:mo>
										<mml:mi mathvariant="italic">local</mml:mi>
										<mml:mo>_</mml:mo>
										<mml:mi mathvariant="italic">attr</mml:mi>
										<mml:mo stretchy="false">〉</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:mi>μ</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>t</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">XY</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>where 〈
							<ce:italic>local</ce:italic>_
							<ce:italic>attr</ce:italic>〉 is the resulting converted attribute expressed as a local attribute, 〈
							<ce:italic>origin</ce:italic>_
							<ce:italic>attr</ce:italic>〉 is the original attribute, either a local attribute or an already converted attribute, 
							<ce:italic>μ</ce:italic> is the conversion degree, 
							<ce:italic>t</ce:italic> is a timestamp, and 
							<mml:math altimg="si67.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">c</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">XY</mml:mi>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> identifies the conversion relation used. This attribute can be signed by the conversion service if required. If we convert attribute 
							<ce:italic>a</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>A</ce:italic> to attribute 
							<ce:italic>b</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>B</ce:italic>, such that 
							<mml:math altimg="si68.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>a</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>b</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:mn>0.7</mml:mn>
								</mml:mrow>
							</mml:math>, it will be denoted as:
							<ce:display>
								<ce:formula id="e0100">
									<mml:math altimg="si69.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi>S</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>B</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>a</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>b</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mn>0.7</mml:mn>
										<mml:mtext>,</mml:mtext>
										<mml:mi>t</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
					</ce:section>
					<ce:section id="s0070" view="all">
						<ce:label>4.2</ce:label>
						<ce:section-title>Context</ce:section-title>
						<ce:para id="p0270" view="all">There are some considerations that must be taken into account within the 
							<ce:italic>Conversion Enforcement</ce:italic> before the generation of local attributes.
						</ce:para>
						<ce:section id="s0075" view="all">
							<ce:label>4.2.1</ce:label>
							<ce:section-title>Conversion process</ce:section-title>
							<ce:para id="p0275" view="all">Before generating a local attribute, the ACM may want to verify whether the attribute conversion has been performed by a trusted domain and whether the conversion has been performed correctly. This is done by verifying the signature 
								<ce:italic>S</ce:italic>
								<ce:inf loc="post">
									<ce:italic>Y</ce:italic>
								</ce:inf> of the converted attribute, the validity of converted attribute through the signature on the original attribute, the validity specification 
								<ce:italic>V</ce:italic> of both the local attribute and the origin attribute, and the freshness of conversion relations checking if the conversion relation 
								<mml:math altimg="si70.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">XY</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:math> has changed since the conversion took place at time 
								<ce:italic>t</ce:italic>.
							</ce:para>
						</ce:section>
						<ce:section id="s0080" view="all">
							<ce:label>4.2.2</ce:label>
							<ce:section-title>Conversion threshold</ce:section-title>
							<ce:para id="p0280" view="all">The conversion degree of a converted attribute may not sufficiently high for the ACM to generate a local attribute from a converted one. The tolerance level is stated by a dynamic 
								<ce:italic>conversion threshold</ce:italic> denoted as 
								<ce:italic>δ</ce:italic>. Given a converted attribute 
								<mml:math altimg="si71.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">attr</mml:mi>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>S</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>B</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>b</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>a</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>μ</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="script">C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">AB</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mi>t</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="script">C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">AB</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> then the conversion enforcement module in 
								<ce:italic>B</ce:italic>, will output the attribute 
								<ce:italic>b</ce:italic> if and only if 
								<ce:italic>μ</ce:italic>
								<ce:hsp sp="0.25"/>⩾
								<ce:hsp sp="0.25"/>
								<ce:italic>δ</ce:italic>(
								<ce:italic>B</ce:italic>). The set of all converted attributes can be seen as an 
								<ce:italic>α</ce:italic>-cut of the converted attribute set. The 
								<ce:italic>α</ce:italic>-cut of a fuzzy set 
								<ce:italic>A</ce:italic> is a crisp set 
								<ce:italic>A</ce:italic>
								<ce:inf loc="post">
									<ce:italic>α</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>{
								<ce:italic>x</ce:italic>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>X</ce:italic>∣
								<ce:italic>μ</ce:italic>
								<ce:inf loc="post">
									<ce:italic>A</ce:italic>
								</ce:inf>(
								<ce:italic>x</ce:italic>)
								<ce:hsp sp="0.25"/>⩾
								<ce:hsp sp="0.25"/>
								<ce:italic>α</ce:italic>}.
							</ce:para>
							<ce:para id="p0285" view="all">The dynamism of the threshold has a clear implication in the validity of the generated local attributes. Since local attributes are generated under a given value of 
								<ce:italic>δ</ce:italic>, then if this threshold is increased the generated attributes it may not be valid. However, the local access control system does not know the value of 
								<ce:italic>δ</ce:italic> due to the independence between the ACM and the local access control module. In order to avoid possible inconsistencies, we use either short-live certificates or one-time certificates to represent the local attributes generated from converted attributes. Other common approaches to certificate revocation can be used, such as certificate revocation list (CRL) 
								<ce:cross-ref refid="b0015">[3]</ce:cross-ref> or online revalidation such as OCSP (Online Certificate Status Protocol) 
								<ce:cross-ref refid="b0105">[21]</ce:cross-ref> while bearing in mind their weaknesses 
								<ce:cross-refs refid="b0060 b0125 b0025">[12,25,5]</ce:cross-refs>.
							</ce:para>
						</ce:section>
						<ce:section id="s0085" view="all">
							<ce:label>4.2.3</ce:label>
							<ce:section-title>Separation of duties</ce:section-title>
							<ce:para id="p0290" view="all">A common principle in access control is the Separation of Duties (SoD), which ensures that no single user acting by its own can compromise the system. This is normally achieved by disseminating critical privileges among multiple users. In the case of attribute based access control, and more precisely RBAC, separation of duties is normally achieved by defining mutual exclusion of roles or attributes 
								<ce:cross-ref refid="b0075">[15]</ce:cross-ref>. Static separation of duties (SSD) enforces the restrictions at the user-attribute assignment in RBAC 
								<ce:cross-ref refid="b0035">[7]</ce:cross-ref>.
							</ce:para>
							<ce:para id="p0295" view="all">The translations from 
								<ce:italic>converted attributes</ce:italic> to 
								<ce:italic>local attributes</ce:italic> are, in fact, user-attribute assignments. Consequently, the SSD must be enforced in this step. The ACM is responsible to ensure that the restrictions are fulfilled through SSD policies. The format of the SSD policies is not specified but may follow the same format described in the RBAC standard 
								<ce:cross-ref refid="b0035">[7]</ce:cross-ref>. The ACM must keep a log of the local attributes of each user and its validity period to take this into account when generating user-attribute assignments. Note also that converted attributes keep track of the original attribute of the user.
							</ce:para>
							<ce:para id="p0300" view="all">If the resultant output attribute set of a conversion has SSD conflicts then it must be determined which attributes should be converted to local attributes in order to unlock the conflict. If the system is dealing with a forward conversion, the user is responsible to choose one of the alternatives which avoids the SSD conflict and best meet her needs. If the system is dealing with a backward conversion, then the system must be responsible for choosing an alternative that gives the user the suitable attribute set, if any, in order to execute the requested action.</ce:para>
							<ce:para id="p0305" view="all">Note that the same strategy can be used to implement Chinese Wall policies, which can be regarded as a secrecy dual of a separation of duties integrity policy. These policies (separation of duties and Chinese Wall) can be generalized to 
								<ce:italic>history</ce:italic>-
								<ce:italic>based policies</ce:italic>, whereby the current permitted access is based not only on some static policy, but also on the accesses that the subject has made in the past.
							</ce:para>
						</ce:section>
						<ce:section id="s0090" view="all">
							<ce:label>4.2.4</ce:label>
							<ce:section-title>About the cascading problem</ce:section-title>
							<ce:para id="p0310" view="all">In 
								<ce:cross-ref refid="b0040">[8]</ce:cross-ref> the authors describe a cascading problem in managing imprecise delegation of permissions based on similarities. Permissions can be accepted for a given access request if they are 
								<ce:italic>δ</ce:italic>-similar (their similarity is greater or equal to 
								<ce:italic>δ</ce:italic>) to the required permission. When the delegation of such permissions is allowed, a user may scale privileges by delegation. In our case we prevent similar problems by considering always the origin of the converted attribute, as described in Section 
								<ce:cross-ref refid="s0065">4.1</ce:cross-ref>. All converted attributes keep the original attribute and domain, as well and the conversion relation used to convert it (note that this could be a composition of relations), if the attribute needs to be further converted the conversion process will use the original attribute, and original domain to convert it to the desired attribute.
							</ce:para>
						</ce:section>
					</ce:section>
				</ce:section>
				<ce:section id="s0095" view="all">
					<ce:label>5</ce:label>
					<ce:section-title>Evaluation and discussion</ce:section-title>
					<ce:para id="p0315" view="all">In this section we evaluate the scalability of the approach. We first analyze the number of conversion policies required in the scenario, comparing the proposed transitive conversion scheme with non-transitive schemes. We also study the impact of increasing the number of domains in the scenario and evaluate the inaccuracies that emerge as a consequence of sub-optimal solutions.</ce:para>
					<ce:section id="s0100" view="all">
						<ce:label>5.1</ce:label>
						<ce:section-title>Conversion policies</ce:section-title>
						<ce:para id="p0320" view="all">In a non-transitive scenario composed of ∣Δ∣ domains, the number of non-symmetric conversion policies is (∣Δ∣
							<ce:sup loc="post">2</ce:sup>
							<ce:hsp sp="0.25"/>−
							<ce:hsp sp="0.25"/>∣Δ∣). As ∣Δ∣ grows, the required number of conversion policies makes the scheme unrealistic. Furthermore, adding a new domain in the scenario requires the generation of 2
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>∣Δ∣ further conversion policies.
						</ce:para>
						<ce:para id="p0325" view="all">Transitivity can be used to significantly reduce the number of conversion policies in the scenario. In the best case, the scheme guarantees full connectivity with ∣Δ∣ conversion policies. This lowest-bound can be achieved through a circle-like topology, where every domain defines a conversion policy to only one domain in the scenario and every domain is targeted by only one conversion policy. In the general case, we do not expect a strict topology as the circle-like topology, but a random topology where every domain defines the conversion policies it needs or it wants, creating different conversion paths from the different domains. 
							<ce:cross-ref refid="f0025">Fig. 5</ce:cross-ref>
							<ce:float-anchor refid="f0025"/> shows a comparison in the number of policies between a non-transitive scenario with (∣Δ∣
							<ce:sup loc="post">2</ce:sup>
							<ce:hsp sp="0.25"/>−
							<ce:hsp sp="0.25"/>∣Δ∣) conversion policies and the lowest-boundary of Δ transitive conversion policies in a circle-like scenario.
						</ce:para>
						<ce:para id="p0330" view="all">Transitivity not only enables a reduction in the number of conversion policies in the scenario but also allows the problem to be characterized in a natural and intuitive manner. In a practical conversion scenario, we cannot expect every domain to define conversion policies to every other domain. Specifying a conversion policy is an expensive administrative task which requires an analysis on the semantics of attributes in order to determine the equivalence relation. Transitivity is a way to deduce new equivalence relations between attributes based on existing relations.</ce:para>
					</ce:section>
					<ce:section id="s0105" view="all">
						<ce:label>5.2</ce:label>
						<ce:section-title>On the complexity of optimal solutions</ce:section-title>
						<ce:para id="p0335" view="all">We focus on transitive scenarios with a random topology. In our approach, computing the optimal solution of a conversion requires a search for all conversion paths between the origin and the target domain using Yen’s algorithm. The number of conversion paths depends on the number of domains in the scenario, the number of conversion policies and, of course, on the topology which in the general case is unknown. 
							<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>
							<ce:float-anchor refid="f0030"/> shows the number of paths of a scenario with varying number of domains and where every domain defines conversion policies to a 10% of the rest of domains in the scenario. As the number of domains grows, the number of conversion paths grows exponentially, making it computationally infeasible to find the optimal solution for a relatively large number of domains.
						</ce:para>
					</ce:section>
					<ce:section id="s0110" view="all">
						<ce:label>5.3</ce:label>
						<ce:section-title>Sub-optimal solutions</ce:section-title>
						<ce:para id="p0340" view="all">As the number of domains increase, the number of non-transitive conversion policies has a direct impact on the scalability of the scenario. Transitivity, however, introduces the problem of finding all the paths between two domains in order to compose the optimal conversion relation. As the number of domains increases, the number of conversion paths grows exponentially. Sub-optimal solutions restrict the number of paths taking part in the conversion.</ce:para>
						<ce:para id="p0345" view="all">We have developed a prototype in order to test the attribute conversion method. 
							<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>
							<ce:float-anchor refid="f0035"/> shows the computing time spent on finding all the paths to compose the optimal solution and the time for finding 50 paths through method 1 and method 2 introduced in Section 
							<ce:cross-ref refid="s0040">3.2</ce:cross-ref>.
						</ce:para>
						<ce:para id="p0350" view="all">Restricting the number of paths becomes mandatory as the number of domains and conversion policies grow in the scenario in order to limit the response time. In the following we evaluate the error introduced by method 1 and method 2 when restricting the number of paths taking part of the sub-optimal solution. The prototype receives the following parameters:
							<ce:list id="l0015">
								<ce:list-item id="o0025">
									<ce:label>•</ce:label>
									<ce:para id="p0550" view="all">∣Δ∣ is the number of domains in the scenario.</ce:para>
								</ce:list-item>
								<ce:list-item id="o0030">
									<ce:label>•</ce:label>
									<ce:para id="p0555" view="all">
										<ce:italic>P</ce:italic>
										<ce:inf loc="post">
											<ce:italic>n</ce:italic>
										</ce:inf> as the probability of neighborhood between the different domains.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0035">
									<ce:label>•</ce:label>
									<ce:para id="p0560" view="all">∣
										<ce:italic>Attr</ce:italic>∣ as the cardinality of the set of attributes defined in the domains. This parameter will determine the size of the conversion relations.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0040">
									<ce:label>•</ce:label>
									<ce:para id="p0565" view="all">
										<ce:italic>P</ce:italic>
										<ce:inf loc="post">
											<ce:italic>s</ce:italic>
										</ce:inf> as the probability of similarity between the attributes of the different domains. This parameter will set the number of 0’s in the conversion relations.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0045">
									<ce:label>•</ce:label>
									<ce:para id="p0570" view="all">
										<ce:italic>N</ce:italic>
										<ce:inf loc="post">
											<ce:italic>p</ce:italic>
										</ce:inf> is the maximum number of paths taking part of the sub-optimal solution.
									</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
						<ce:para id="p0355" view="all">Given these parameters, the prototype generates a random scenario and randomly selects an origin domain 
							<ce:italic>A</ce:italic> and target domain 
							<ce:italic>B</ce:italic>, and calculates the optimal conversion relation 
							<mml:math altimg="si72.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
								</mml:mrow>
							</mml:math> between both domains (see Section 
							<ce:cross-ref refid="s0045">3.2.1</ce:cross-ref>). Then, we run the two methods restricting the parameter 
							<ce:italic>N</ce:italic>
							<ce:inf loc="post">
								<ce:italic>p</ce:italic>
							</ce:inf> in order to compute the sub-optimal 
							<mml:math altimg="si73.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msubsup>
										<mml:mrow>
											<mml:mi mathvariant="script">C</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">AB</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msubsup>
									<mml:mo stretchy="false">)</mml:mo>
								</mml:mrow>
							</mml:math> conversion relation between the origin and target domain and evaluate the error.
						</ce:para>
						<ce:section id="s0115" view="all">
							<ce:label>5.3.1</ce:label>
							<ce:section-title>Bench 1: progression in the number of domains</ce:section-title>
							<ce:para id="p0360" view="all">In the first set of experiments, we progressively increase ∣Δ∣. The parameters are set as ∣Δ∣
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>{8,
								<ce:hsp sp="0.12"/>11,
								<ce:hsp sp="0.12"/>14,
								<ce:hsp sp="0.12"/>17,
								<ce:hsp sp="0.12"/>20,
								<ce:hsp sp="0.12"/>23}, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>n</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>0.2, ∣
								<ce:italic>Attr</ce:italic>∣
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>100, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>0.05, 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>5. 
								<ce:cross-ref refid="f0040">Fig. 8</ce:cross-ref>
								<ce:float-anchor refid="f0040"/> shows the error for all the given values of ∣Δ∣.
							</ce:para>
							<ce:para id="p0365" view="all">As the number of domains increases, the number of total paths increases exponentially. However, the 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> is set to 5 for all the runs. Despite the fact that the two methods select the 5 better paths, the remainder of the discarded paths also contribute to find the optimal solution, and therefore the error increases. On the other hand, this error tends to 0 as 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> tends to the total number of paths, so finding a good value for 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> is of paramount importance.
							</ce:para>
						</ce:section>
						<ce:section id="s0120" view="all">
							<ce:label>5.3.2</ce:label>
							<ce:section-title>Bench 2: progression in the number of computed paths</ce:section-title>
							<ce:para id="p0370" view="all">In the second set of experiments, we progressively increase 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf>. The parameters are set as ∣Δ∣
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>20, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>n</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>0.2, ∣
								<ce:italic>Attr</ce:italic>∣
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>100, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>0.05, 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>{1,
								<ce:hsp sp="0.12"/>5,
								<ce:hsp sp="0.12"/>10,
								<ce:hsp sp="0.12"/>20,
								<ce:hsp sp="0.12"/>30}. 
								<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>
								<ce:float-anchor refid="f0045"/> shows the error progression for all the given values of 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf>.
							</ce:para>
							<ce:para id="p0375" view="all">Obviously, as 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> tends to the total number of paths between the origin and the target domain, the error tends to 0. It is generally unfeasible to know the total number of paths between the origin and the target domain. However, the total number of paths can be approximated taking into account ∣Δ∣ and 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>n</ce:italic>
								</ce:inf>. As 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> is a trade-off between performance and accuracy, it must be conveniently chosen in order to delimit the error.
							</ce:para>
							<ce:para id="p0380" view="all">Method 2 outperforms method 1 when 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> is relatively low. However, as 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> is increased, method 1 outperforms method 2. Probably the reason is that method 1 promotes the diversity of paths taking part of the sub-optimal solution while method 2 select paths with common good sections. Diversity helps to not focus the sub-optimal solution on specific attribute groups and thus reduce the global error.
							</ce:para>
						</ce:section>
						<ce:section id="s0125" view="all">
							<ce:label>5.3.3</ce:label>
							<ce:section-title>Bench 3: progression in the attribute similitude</ce:section-title>
							<ce:para id="p0385" view="all">In the third set of experiments, we progressively increase 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf>. The parameters are set as ∣Δ∣
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>20, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>n</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>0.2, ∣
								<ce:italic>Attr</ce:italic>∣
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>100, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>{0.01,
								<ce:hsp sp="0.12"/>0.02,
								<ce:hsp sp="0.12"/>0.05,
								<ce:hsp sp="0.12"/>0.1,
								<ce:hsp sp="0.12"/>0.2,
								<ce:hsp sp="0.12"/>0.3,
								<ce:hsp sp="0.12"/>0.4,
								<ce:hsp sp="0.12"/>0.5}, 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>5. 
								<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>
								<ce:float-anchor refid="f0050"/> shows the error progression for all values of 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf>.
							</ce:para>
							<ce:para id="p0390" view="all">The error tends to 0 as 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf> tends to 0 and 1. When 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf> tends to 0, the conversion relations of the scenario are almost 0 for all attributes. Attributes from the origin domain are hardly converted to attributes of the target domain so the discarded paths in the sub-optimal solution do not contribute to increase the error. When 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf> tends to 1, the conversion relations of the scenario are almost 1 for all attributes. All the attributes from the origin are always converted to all the attributes of the target domain so the discarded paths in the sub-optimal solution do not contribute to increase the error. The maximum error is reached when the similarity probability is around 2% (
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>0.02). With such light weighted conversion policies, all the paths strongly contribute to the optimal solution. The low number of computed paths increases the error of the sub-optimal solutions. In a real scenario, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf> tends to be low as one attribute from the origin domain will be normally converted to few attributes of the target domain.
							</ce:para>
						</ce:section>
						<ce:section id="s0130" view="all">
							<ce:label>5.3.4</ce:label>
							<ce:section-title>Bench 4: size of conversion relations</ce:section-title>
							<ce:para id="p0395" view="all">The fourth set of experiments evaluate the impact of the size of conversion relations on the response time of the process. We progressively increase ∣
								<ce:italic>Attr</ce:italic>∣. The parameters are set as ∣Δ∣
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>20, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>n</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>0.2, ∣
								<ce:italic>Attr</ce:italic>∣
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>{5,
								<ce:hsp sp="0.12"/>25,
								<ce:hsp sp="0.12"/>50,
								<ce:hsp sp="0.12"/>100,
								<ce:hsp sp="0.12"/>150,
								<ce:hsp sp="0.12"/>200,
								<ce:hsp sp="0.12"/>250}, 
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>s</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>0.5, 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>100. 
								<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref> shows the error progression for all values of ∣
								<ce:italic>Attr</ce:italic>∣.
							</ce:para>
							<ce:para id="p0400" view="all">The difference in time when computing paths shown in 
								<ce:cross-ref refid="f0055">Fig. 11</ce:cross-ref>
								<ce:float-anchor refid="f0055"/> responds to the difference between method 1 and method 2 when weighting paths. Whilst method 1 weights every conversion relation and then computes the shortest path with accumulative weights, method 2 composes the relations taking part of every sub-path in order to weight it. The size of the attribute set has a direct impact on the response time of method 2, while the response time of method 1 remains constant.
							</ce:para>
						</ce:section>
					</ce:section>
					<ce:section id="s0135" view="all">
						<ce:label>5.4</ce:label>
						<ce:section-title>Analysis</ce:section-title>
						<ce:para id="p0405" view="all">In a non-transitive scenario, an increasing number of domains raises the number of conversion policies in order to enable full connectivity. By enabling transitivity, the number of conversion policies can be dramatically reduced.</ce:para>
						<ce:para id="p0410" view="all">In a transitive scenario, the complexity of our method lies on finding conversion paths between an origin and a target domain. The number of conversion paths grows exponentially when the number of domains is increased in the scenario. Finding all the conversion paths may become computationally inviable. Sub-optimal solutions can be computed limiting the number of conversion paths between the origin and the target domain. The paths taking part of the sub-optimal solution can be chosen following different heuristics in order to delimit the error. We provide two different methods in order to choose that paths.</ce:para>
						<ce:para id="p0415" view="all">In a scenario with high number of conversion paths between the origin and the target domain, where the number of paths taking part on the sub-optimal solution is low compared to the total number of paths, method 2 gives better error rates than method 1. When 
							<ce:italic>N</ce:italic>
							<ce:inf loc="post">
								<ce:italic>p</ce:italic>
							</ce:inf> tends to the total number of paths between the origin and the target domain, method 1 performs better than method 2.
						</ce:para>
						<ce:para id="p0420" view="all">The number of attributes of the domains in the scenario conditions the size of the conversion relations. When conversion relations are big, the response time of method 2 grows exponentially whilst the response time of method 1 is constant. When the response time is fixed, method 1 will be able to compute more paths of the sub-optimal solution than method 2, thus method 1 will provide a better error rate. We conclude that method 2 is better than method 1 only when the number of domains is high and the expected response time is low. In scenarios with dense conversion relations, method 1 is more appropriate than method 2.</ce:para>
						<ce:section id="s0140" view="all">
							<ce:label>5.4.1</ce:label>
							<ce:section-title>Setting the 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf>
							</ce:section-title>
							<ce:para id="p0425" view="all">Finding a good 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> value is a key point to delimit the error. The 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf> parameter sets the border between accuracy and response time. We provide two ways in order to set 
								<ce:italic>N</ce:italic>
								<ce:inf loc="post">
									<ce:italic>p</ce:italic>
								</ce:inf>:
								<ce:list id="l0020">
									<ce:list-item id="o0050">
										<ce:label>•</ce:label>
										<ce:para id="p0575" view="all">
											<ce:bold>Estimation of the number of paths:</ce:bold> Although the number of total paths between two given domains strongly depends on the topology of the graph and it is unpredictable, it is also true that as the number of arcs on the graph grows, the number of simple paths grows exponentially. The number of arcs could be a good measure to determine 
											<ce:italic>N</ce:italic>
											<ce:inf loc="post">
												<ce:italic>p</ce:italic>
											</ce:inf> and can be computed as ∣Δ∣
											<ce:sup loc="post">2</ce:sup>
											<ce:italic>P</ce:italic>
											<ce:inf loc="post">
												<ce:italic>n</ce:italic>
											</ce:inf>.
										</ce:para>
									</ce:list-item>
									<ce:list-item id="o0055">
										<ce:label>•</ce:label>
										<ce:para id="p0580" view="all">
											<ce:bold>Restricted by the response time:</ce:bold> The attribute conversion process must be transparent for the users. In some applications, the response time must be close to constant and cannot depend on the number of total conversion relations in the scenario. Another strategy for setting the 
											<ce:italic>N</ce:italic>
											<ce:inf loc="post">
												<ce:italic>p</ce:italic>
											</ce:inf> parameter is computing the maximum number of paths for a given response time.
										</ce:para>
									</ce:list-item>
								</ce:list>
							</ce:para>
						</ce:section>
						<ce:section id="s0145" view="all">
							<ce:label>5.4.2</ce:label>
							<ce:section-title>Threshold and error</ce:section-title>
							<ce:para id="p0430" view="all">The error introduced by the sub-optimal solutions determines how far the sub-optimal solutions are from the optimal solution. By 
								<ce:cross-ref refid="n0010">Proposition 1</ce:cross-ref>, sub-optimal solutions never overestimate the optimal solution. That is, the equivalence between two attributes can be lower in the sub-optimal solution than in the optimal solution but it cannot be higher. In the attribute enforcement step, when issuing local attributes from converted ones, the equivalence degree must be equal or higher than the conversion threshold in order to issue local attributes. The conversion threshold must be consequent to the error introduced by sub-optimal solutions.
							</ce:para>
						</ce:section>
					</ce:section>
				</ce:section>
				<ce:section id="s0150" view="all">
					<ce:label>6</ce:label>
					<ce:section-title>Related work</ce:section-title>
					<ce:para id="p0435" view="all">There are a number of approaches to dealing with the challenge of access-control cooperation in the multi-domain environment. We distinguish between two types of interoperability: policy-level and attribute-level interoperability. At the policy level, the interoperability is performed through the generation of access control policies, which allow sharing resources between the domains. Two architectural configurations –
						<ce:italic>loosely coupled domains</ce:italic> and 
						<ce:italic>federated domains</ce:italic> – characterize these kinds of scenarios 
						<ce:cross-ref refid="b0065">[13]</ce:cross-ref>. In the former, each domain acts at the same level as the rest and the interoperation is done through the generation of local access-control interoperation policies which allow each domain to authorize users coming from foreign domains. In 
						<ce:cross-ref refid="b0140">[28]</ce:cross-ref> the authors propose an algorithm for the generation of this policies in an RBAC scenario. In the latter architecture, 
						<ce:italic>federated domains</ce:italic>, a master domain has a global access control policy which regulates all the actions that can be performed in the whole scenario. Again 
						<ce:cross-ref refid="b0135">[27]</ce:cross-ref> proposes an algorithm for the generation of the global-policy. In 
						<ce:cross-ref refid="b0020">[4]</ce:cross-ref> a security policy merging from a graph-theoretic perspective is proposed.
					</ce:para>
					<ce:para id="p0440" view="all">Policy-level interoperation requires the modification of the access control policies of the involved domains. Furthermore, adding a new domain to the scenario requires the regeneration of the interoperation access control policies. The scalability of the approach is threatened when the number of domains is high enough, leading to the generation of too complex access control policies.</ce:para>
					<ce:para id="p0445" view="all">An example of policy-level interoperation is 
						<ce:italic>virtual organizations</ce:italic>, which are common in Grid environments. The Globus toolkit, one of the most known Grid middlewares 
						<ce:cross-ref refid="b0050">[10]</ce:cross-ref>, has its own access control module 
						<ce:cross-ref refid="b0115">[23]</ce:cross-ref>. Each Globus domain sharing resources creates a specific access control policy in order to regulate the access from the virtual organization as a whole. At the same time, the virtual organization has its own access control policies to regulate its own users. All accesses to the resources are controlled twice. Firstly to authorize the user inside the virtual organization and secondly to authorize the virtual organization itself in the third party which owns the resource.
					</ce:para>
					<ce:para id="p0450" view="all">While policy-level interoperability is widely explored in the literature, it is normally too complex to be deployed in open environments, or tied to specific architectures or models. On the other hand, attribute-level interoperability has not been as widely explored and may offer interesting solutions. In 
						<ce:cross-refs refid="b0005 b0085">[1,17]</ce:cross-refs>, the (attribute-level) interoperability is based on a crisp relation between the roles of different domains in RBAC-like environments. 
						<ce:cross-ref refid="b0160">[32]</ce:cross-ref> uses an ontology to specify context-related information in RBAC which can be used to define some role relations between domains. In 
						<ce:cross-ref refid="b0090">[18]</ce:cross-ref> a Credential Conversion Service converts, through a policy, attributes from the user’s home domain to local domain attributes. In 
						<ce:cross-ref refid="b0095">[19]</ce:cross-ref> a trust-based access control for the grid environment is proposed whereby the access level of the users is determined by their trust degree. In order to access to foreign domains, users can recognize their trust degree in foreign domains through a Master Security Management Center. Thus, user requests are enforced with the trust-based access control policies of every domain. In relation to these issues, our scheme provide flexibility when defining conversion relations between attributes and helps on the scalability of the approach allowing transitivity in the conversion.
					</ce:para>
					<ce:para id="p0455" view="all">Another form of attribute-level interoperation are the coalition models 
						<ce:cross-refs refid="b0010 b0150 b0080">[2,30,16]</ce:cross-refs>. The coalition models are based on the definition of a global attribute set (as a meta-attribute set) and the generation of a relation between the local attributes of each domain to the global attribute set. This way, when a user wants to act in a foreign domain, its local attributes must be translated to global attributes which can be later translated to the target domain’s local attributes. This method may be scalable because adding one domain to the scenario only involves the definition of the relation between its local attributes and the global attribute set. However, the addition of new domains may involve the update of the global attribute set and consequently, the update of all the attribute relations. Furthermore, all the attributes are translated from the global attribute set regardless of the original domain, making the conversion process less flexible. Our approach can emulate a coalition scheme defining a star-like scenario where every domain in the scenario defines conversion policies only with a central domain.
					</ce:para>
					<ce:para id="p0460" view="all">To the best of our knowledge, there is no much previous work that merges fuzzy sets theory and interoperation in a multi-domain environment. However, we can find closely related works. Foley 
						<ce:cross-ref refid="b0040">[8]</ce:cross-ref> suggests the use of similarity measures between credentials within a single domain in order to prioritize flexibility over high security requirements. Similarity measures are used to specify how close authorizations for different actions are to each other, permitting answers that may not formally meet the query condition but can be considered close enough. Our proposal exploits the attribute similarity in order to tackle the problem of interoperability in the multi-domain environment. A similar idea was applied to SAML-based decision engines 
						<ce:cross-ref refid="b0110">[22]</ce:cross-ref>. The authors use similarity measures to relate attributes within different domains. Similarity is represented by a magnitude in the real unit interval [0,
						<ce:hsp sp="0.12"/>1]. A similarity threshold states the minimum similarity degree accepted. Our proposal extends the model through transitivity in the attribute conversion.
					</ce:para>
					<ce:para id="p0465" view="all">A flexible access control approach intended to reduce security management in RBAC systems is proposed in 
						<ce:cross-ref refid="b0145">[29]</ce:cross-ref>. Restraint rules can be defined to express a set of actions to be executed if prerequisite conditions are fulfilled. Conditions can be weighted so if the sum of all accomplished conditions is greater than a predefined threshold the consequent actions are executed. The execution of actions associated to a restraint rule can produce user-role assignments. Our conversion policies can be defined through restraint rules to define non-transitive role conversion policies. Local roles can be assigned to a foreign user if the user’s roles are similar enough to local ones.
					</ce:para>
				</ce:section>
				<ce:section id="s0155" view="all">
					<ce:label>7</ce:label>
					<ce:section-title>Conclusions</ce:section-title>
					<ce:para id="p0470" view="all">In this paper an interoperation mechanism is presented that is suitable for scenarios where previously working heterogeneous systems come together to share resources. An advantage of the approach is that it is not necessary for the individual systems modify their access control systems nor their access control policies in order to interoperate. A mechanism is proposed that translates each users’ credentials to the local format of the domain where they are supposed to act, thereby enforcing them with the well tested access control policies of each domain.</ce:para>
					<ce:para id="p0475" view="all">An attribute conversion technique is presented that establishes equivalence relations between the attributes of the different domains. In the general case, it is not possible to define an isomorphic equivalence relation between attributes due to the heterogeneity of the domains. The proposed conversion mechanism is flexible, enabling a measure to be associated with the relationship between attributes. These conversions are described as fuzzy relations. Fuzzy relations provide a natural way to exploit transitivity in the conversion, through their composition. Transitivity reduces the total number of attribute relations in the scenario, making the scheme scalable. Conversion algorithms were described for forward and backward conversion. We also provide two sub-optimal heuristic methods to reduce the computational complexity by limiting the number of paths to compute. Finally, we propose a context handler where several verifications about the conversion process may be done prior to the generation of attributes that can be used in the target domain.</ce:para>
					<ce:para id="p0480" view="all">As future work, we are working towards the application of this work in a concrete scenario. We plan to test our conversion mechanisms in the coordination of rescue and medical teams in emergency situations in the application MAETT 
						<ce:cross-ref refid="b0100">[20]</ce:cross-ref>. Moreover, we plan to deal with scenarios where conversion relations are kept in secret for privacy reasons. We will also study the implications of the cascade problem in particular cases.
					</ce:para>
				</ce:section>
			</ce:sections>
			<ce:acknowledgment xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Acknowledgements</ce:section-title>
				<ce:para id="p0610" view="all">Partial support by the Spanish MICINN (projects TIN2010-15764, ARES – CONSOLIDER INGENIO 2010 CSD2007-00004, and eAEGIS TSI2007-65406-C03-02), by 
					<ce:grant-sponsor id="GS1" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">Science Foundation Ireland</ce:grant-sponsor> Grant 
					<ce:grant-number refid="GS1">08/SRC/11403</ce:grant-number> and 
					<ce:grant-sponsor id="GS2" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">Universitat Autònoma de Barcelona</ce:grant-sponsor> (
					<ce:grant-number refid="GS2">PIF 472-01-1/07</ce:grant-number>) is acknowledged.
				</ce:para>
			</ce:acknowledgment>
			<ce:appendices view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section id="s0160" view="all">
					<ce:label>Appendix A</ce:label>
					<ce:section-title>Algorithms</ce:section-title>
					<ce:section id="s0165" view="all">
						<ce:label>A.1</ce:label>
						<ce:section-title>Maximal relation algorithm</ce:section-title>
						<ce:para id="p0485" view="all">The algorithm to obtain the optimal solution to the conversion graph problem of Section 
							<ce:cross-ref refid="s0045">3.2.1</ce:cross-ref> is given in Algorithm 1.
							<ce:display>
								<ce:figure id="f0060">
									<ce:link locator="fx2"/>
								</ce:figure>
							</ce:display>
						</ce:para>
					</ce:section>
					<ce:section id="s0170" view="all">
						<ce:label>A.2</ce:label>
						<ce:section-title>
							<ce:italic>K</ce:italic> shortest paths with subpath relation composition (method 2)
						</ce:section-title>
						<ce:para id="p0490" view="all">In this section we present our modifications to Yen’s algorithm to find the 
							<ce:italic>K</ce:italic> shortest loop less paths, using the weights described in Section 
							<ce:cross-ref refid="s0050">3.2.2</ce:cross-ref>, see 
							<ce:cross-ref refid="b0120">[24]</ce:cross-ref> for detailed descriptions of the original Yen’s algorithm and its implementation.
						</ce:para>
						<ce:para id="p0495" view="all">The following notation is used. The conversion graph is denoted as the graph 
							<mml:math altimg="si74.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi mathvariant="script">N</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi mathvariant="script">A</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
								</mml:mrow>
							</mml:math>, nodes are denoted as 
							<mml:math altimg="si75.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi>v</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo>∈</mml:mo>
									<mml:mi mathvariant="script">N</mml:mi>
								</mml:mrow>
							</mml:math>, arcs as 
							<mml:math altimg="si76.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>i</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>j</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>∈</mml:mo>
									<mml:mi mathvariant="script">A</mml:mi>
								</mml:mrow>
							</mml:math>, and a path is denoted as 
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf>. A subpath from the path 
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf> from node 
							<ce:italic>s</ce:italic> to node 
							<ce:italic>t</ce:italic> is denoted as 
							<mml:math altimg="si77.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="italic">sub</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>p</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>k</mml:mi>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>s</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>t</mml:mi>
									<mml:mo stretchy="false">)</mml:mo>
								</mml:mrow>
							</mml:math>, note that both 
							<ce:italic>s</ce:italic>, 
							<ce:italic>t</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf>. Given a set of 
							<ce:italic>k</ce:italic> paths 
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">
								<ce:italic>k</ce:italic>
							</ce:inf> from node 
							<ce:italic>s</ce:italic> to node 
							<ce:italic>t</ce:italic>, 
							<ce:italic>d</ce:italic>(
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">
								<ce:italic>r</ce:italic>
							</ce:inf>) is the node such that 
							<mml:math altimg="si78.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="italic">sub</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>p</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>r</mml:mi>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:mi>s</mml:mi>
									<mml:mtext>,</mml:mtext>
									<mml:mi>d</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>p</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>r</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo stretchy="false">)</mml:mo>
								</mml:mrow>
							</mml:math> is the path with maximum number of nodes contained in every path 
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:italic>p</ce:italic>
							<ce:inf loc="post">
								<ce:italic>r</ce:italic>−1
							</ce:inf> for 
							<ce:italic>r</ce:italic>
							<ce:hsp sp="0.25"/>⩽
							<ce:hsp sp="0.25"/>
							<ce:italic>k</ce:italic>. Finally, 
							<ce:italic>π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf> designates the label (weight) of node 
							<ce:italic>v</ce:italic>.
						</ce:para>
						<ce:para id="p0500" view="all">The procedures 
							<ce:italic>calculateWeightsForward</ce:italic>, 
							<ce:italic>sucessorsLabelReverse</ce:italic>, 
							<ce:italic>ShortestLooplessPath</ce:italic> are also used in the main Algorithm 2.
							<ce:display>
								<ce:figure id="f0065">
									<ce:link locator="fx3"/>
								</ce:figure>
							</ce:display>
							<ce:display>
								<ce:figure id="f0070">
									<ce:link locator="fx4"/>
								</ce:figure>
							</ce:display>
							<ce:display>
								<ce:figure id="f0075">
									<ce:link locator="fx5"/>
								</ce:figure>
							</ce:display>
							<ce:display>
								<ce:figure id="f0080">
									<ce:link locator="fx6"/>
								</ce:figure>
							</ce:display>
						</ce:para>
					</ce:section>
				</ce:section>
			</ce:appendices>
		</ja:body>
		<ja:tail view="all">
			<ce:bibliography id="bi005" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>References</ce:section-title>
				<ce:bibliography-sec id="bs005">
					<ce:bib-reference id="b0005">
						<ce:label>[1]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Bacon</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.</ce:given-name>
										<ce:surname>Moody</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>W.</ce:given-name>
										<ce:surname>Yao</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Access control and trust in the use of widely distributed services</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of IFIP/ACM International Conference on Distributed Systems Platforms</sb:maintitle>
									</sb:title>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>Lecture Notes in Computer Science</sb:maintitle>
											</sb:title>
											<sb:volume-nr>vol. 2218</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>2001</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>295</sb:first-page>
									<sb:last-page>310</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0010">
						<ce:label>[2]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Belsis</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Gritzalis</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Katsikas</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A scalable security architecture enabling coalition formation between autonomous domains</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of 5th IEEE International Symposium on Signal Processing and Information Technology</sb:maintitle>
									</sb:title>
									<sb:date>2005</sb:date>
									<sb:publisher>
										<sb:name>IEEE</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>560</sb:first-page>
									<sb:last-page>565</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0015">
						<ce:label>[3]</ce:label>
						<ce:other-ref>
							<ce:textref>D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, W. Polk, Internet X.509 public key infrastructure certificate and certificate revocation list (CRL) profile, RFC 5280, Internet Society, 2008.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0020">
						<ce:label>[4]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>Ding</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.F.</ce:given-name>
										<ce:surname>Lax</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.P.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Graph-theoretic method for merging security system specifications</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Information Sciences</sb:maintitle>
										</sb:title>
										<sb:volume-nr>177</sb:volume-nr>
									</sb:series>
									<sb:date>2007</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>2152</sb:first-page>
									<sb:last-page>2166</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0025">
						<ce:label>[5]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.</ce:given-name>
										<ce:surname>Ellison</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>Schneier</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Ten risks of PKI: What you’re not being told about public key infrastructure</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Computer Security Journal</sb:maintitle>
										</sb:title>
										<sb:volume-nr>16</sb:volume-nr>
									</sb:series>
									<sb:date>2000</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1</sb:first-page>
									<sb:last-page>7</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0030">
						<ce:label>[6]</ce:label>
						<ce:other-ref>
							<ce:textref>S. Farrell, R. Housley, An internet attribute certificate profile for authorization, RFC 3281, Internet Society, 2002.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0035">
						<ce:label>[7]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>D.F.</ce:given-name>
										<ce:surname>Ferraiolo</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.S.</ce:given-name>
										<ce:surname>Sandhu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.I.</ce:given-name>
										<ce:surname>Gavrila</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.R.</ce:given-name>
										<ce:surname>Kuhn</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Chandramouli</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Proposed NIST standard for role-based access control</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>ACM Transactions on Information Systems Security</sb:maintitle>
										</sb:title>
										<sb:volume-nr>4</sb:volume-nr>
									</sb:series>
									<sb:date>2001</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>224</sb:first-page>
									<sb:last-page>274</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0040">
						<ce:label>[8]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>S.N.</ce:given-name>
										<ce:surname>Foley</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Supporting imprecise delegation in KeyNote</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of International Security Protocols Workshop</sb:maintitle>
									</sb:title>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>Lecture Notes in Computer Science</sb:maintitle>
											</sb:title>
											<sb:volume-nr>vol. 2845</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>2002</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>179</sb:first-page>
									<sb:last-page>188</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0045">
						<ce:label>[9]</ce:label>
						<ce:other-ref>
							<ce:textref>Simon N. Foley, Wayne Mac Adams, and Barry O’Sullivan. Aggregating Trust Using Triangular Norms in the KeyNote Trust Management System. in: Proc. 6th International Workshop on Security and Trust Management (STM 2010), LNCS. Springer, 2010.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0050">
						<ce:label>[10]</ce:label>
						<ce:other-ref>
							<ce:textref>Globus, Globus Toolkit, Available from: 
								<ce:inter-ref xlink:href="http://www.globus.org" xlink:type="simple" xmlns:xlink="http://www.w3.org/1999/xlink">&lt;http://www.globus.org&gt;</ce:inter-ref>, 2008.
							</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0055">
						<ce:label>[11]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>L.</ce:given-name>
										<ce:surname>Gong</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>X.</ce:given-name>
										<ce:surname>Qian</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Computational issues in secure interoperation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Transactions on Software Engineering</sb:maintitle>
										</sb:title>
										<sb:volume-nr>22</sb:volume-nr>
									</sb:series>
									<sb:date>1996</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>43</sb:first-page>
									<sb:last-page>52</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0060">
						<ce:label>[12]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Gutmann</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>PKI: it’s not dead, just resting</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Computer</sb:maintitle>
										</sb:title>
										<sb:volume-nr>35</sb:volume-nr>
									</sb:series>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>41</sb:first-page>
									<sb:last-page>49</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0065">
						<ce:label>[13]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.B.D.</ce:given-name>
										<ce:surname>Joshi</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Bhatti</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>E.</ce:given-name>
										<ce:surname>Bertino</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Ghafoor</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Access-control language for multidomain environments</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Internet Computing</sb:maintitle>
										</sb:title>
										<sb:volume-nr>8</sb:volume-nr>
									</sb:series>
									<sb:date>2004</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>40</sb:first-page>
									<sb:last-page>50</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0070">
						<ce:label>[14]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>Klir</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>Yuan</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Fuzzy Sets and Fuzzy Logic: Theory and Applications</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:date>1995</sb:date>
									<sb:publisher>
										<sb:name>Prentice Hall</sb:name>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0075">
						<ce:label>[15]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>D.R.</ce:given-name>
										<ce:surname>Kuhn</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Mutual exclusion of roles as a means of implementing separation of duty in role-based access control systems</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of 2nd ACM Workshop on Role-Based Access Control</sb:maintitle>
									</sb:title>
									<sb:date>1997</sb:date>
									<sb:publisher>
										<sb:name>ACM</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>23</sb:first-page>
									<sb:last-page>30</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0080">
						<ce:label>[16]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Li</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Huai</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.</ce:given-name>
										<ce:surname>Hu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Zhu</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A secure collaboration service for dynamic virtual organizations</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Information Sciences</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>3086</sb:first-page>
									<sb:last-page>3107</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0085">
						<ce:label>[17]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>López</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>O.</ce:given-name>
										<ce:surname>Cánovas</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Gómez-Skarmeta</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Use of XACML policies for a network access control service</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of 4th International Workshop for Applied PKI</sb:maintitle>
									</sb:title>
									<sb:date>2005</sb:date>
									<sb:publisher>
										<sb:name>IOS Press</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>111</sb:first-page>
									<sb:last-page>122</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0090">
						<ce:label>[18]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>López</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>O.</ce:given-name>
										<ce:surname>Cánovas</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.F.</ce:given-name>
										<ce:surname>Gómez-Skarmeta</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Otenko</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.W.</ce:given-name>
										<ce:surname>Chadwick</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A heterogeneous network access service based on PERMIS and SAML</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of 2nd European PKI Workshop</sb:maintitle>
									</sb:title>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>Lecture Notes in Computer Science</sb:maintitle>
											</sb:title>
											<sb:volume-nr>vol. 3545</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>2005</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>55</sb:first-page>
									<sb:last-page>72</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0095">
						<ce:label>[19]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Luo</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>X.</ce:given-name>
										<ce:surname>Ni</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Yong</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A trust degree based access control in grid environments</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Information Sciences</sb:maintitle>
										</sb:title>
										<sb:volume-nr>179</sb:volume-nr>
									</sb:series>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>2618</sb:first-page>
									<sb:last-page>2628</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0100">
						<ce:label>[20]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Martí</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Robles</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Martín-Campillo</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Cucurull</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Providing early resource allocation during emergencies: the mobile triage tag</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Journal of Network and Computer Applications</sb:maintitle>
										</sb:title>
										<sb:volume-nr>32</sb:volume-nr>
									</sb:series>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1167</sb:first-page>
									<sb:last-page>1182</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0105">
						<ce:label>[21]</ce:label>
						<ce:other-ref>
							<ce:textref>M. Myers, R. Ankney, A. Malpani, S. Galperin, C. Adams, X.509 internet public key infrastructure online certificate status protocol – OCSP, RFC 2560, Internet Society, 1999.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0110">
						<ce:label>[22]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>Navarro-Arribas</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.N.</ce:given-name>
										<ce:surname>Foley</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Approximating SAML using similarity based imprecision</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of Intelligence in Communication Systems</sb:maintitle>
									</sb:title>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>IFIP International Federation for Information Processing</sb:maintitle>
											</sb:title>
											<sb:volume-nr>vol. 190</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>2005</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>191</sb:first-page>
									<sb:last-page>200</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0115">
						<ce:label>[23]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>L.</ce:given-name>
										<ce:surname>Pearlman</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.</ce:given-name>
										<ce:surname>Kesselman</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>V.</ce:given-name>
										<ce:surname>Welch</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>I.</ce:given-name>
										<ce:surname>Foster</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Tuecke</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>The community authorization service: Status and future</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of Computing in High Energy Physics</sb:maintitle>
									</sb:title>
									<sb:date>2003</sb:date>
									<sb:publisher>
										<sb:name>UCSD</sb:name>
									</sb:publisher>
								</sb:edited-book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0120">
						<ce:label>[24]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>E.</ce:given-name>
										<ce:surname>de Queirós Vieira Martins</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.M.B.</ce:given-name>
										<ce:surname>Pascoal</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A new implementation of Yen’s ranking loopless paths algorithm, 4OR</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>A Quarterly Journal of Operations Research</sb:maintitle>
										</sb:title>
										<sb:volume-nr>1</sb:volume-nr>
									</sb:series>
									<sb:date>2003</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>121</sb:first-page>
									<sb:last-page>133</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0125">
						<ce:label>[25]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Rivest</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Can we eliminate certificate revocations lists?</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of 2nd International Conference on Financial Cryptography</sb:maintitle>
									</sb:title>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>Lecture Notes in Computer Science</sb:maintitle>
											</sb:title>
											<sb:volume-nr>vol. 1465</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>1998</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>178</sb:first-page>
									<sb:last-page>183</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0130">
						<ce:label>[26]</ce:label>
						<ce:other-ref>
							<ce:textref>SAML, Assertions and protocols for the OASIS security assertion markup language (SAML) v2.0, OASIS Standard, 2005.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0135">
						<ce:label>[27]</ce:label>
						<ce:other-ref>
							<ce:textref>B. Shafiq, J. Joshi, E. Bertino, A. Ghafoor, Optimal Secure Interoperation in a Multidomain Environment Employing RBAC Policies, Technical Report 2003-24, CERIAS, Purdue University, 2003.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0140">
						<ce:label>[28]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>Shafiq</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Joshi</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>E.</ce:given-name>
										<ce:surname>Bertino</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Ghafoor</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Secure interoperation in a multidomain environment employing RBAC policies</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Transactions on Knowledge and Data Engineering</sb:maintitle>
										</sb:title>
										<sb:volume-nr>17</sb:volume-nr>
									</sb:series>
									<sb:date>2005</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1557</sb:first-page>
									<sb:last-page>1577</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0145">
						<ce:label>[29]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Sun</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>Gong</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>X.</ce:given-name>
										<ce:surname>Meng</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Z.</ce:given-name>
										<ce:surname>Lin</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>E.</ce:given-name>
										<ce:surname>Bertino</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Specification and enforcement of flexible security policy for active cooperation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Information Sciences</sb:maintitle>
										</sb:title>
										<sb:volume-nr>179</sb:volume-nr>
									</sb:series>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>2629</sb:first-page>
									<sb:last-page>2642</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0150">
						<ce:label>[30]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Sun</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Pan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.</ce:given-name>
										<ce:surname>Fung Leung</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>Shi</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Ontology based hybrid access control for automatic interoperation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of Autonomic and Trusted Computing</sb:maintitle>
									</sb:title>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>Lecture Notes in Computer Science</sb:maintitle>
											</sb:title>
											<sb:volume-nr>vol. 4610</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>2007</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>323</sb:first-page>
									<sb:last-page>332</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0155">
						<ce:label>[31]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>V.</ce:given-name>
										<ce:surname>Torra</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Narukawa</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Modeling Decisions: Information Fusion and Aggregation Operators</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:date>2007</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0160">
						<ce:label>[32]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>D.</ce:given-name>
										<ce:surname>Wu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>X.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Lin</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Zhu</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Ontology-based RBAC specification for interoperation in distributed environment</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proceedings of 1st Asian Semantic Web Conference</sb:maintitle>
									</sb:title>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>Lecture Notes in Computer Science</sb:maintitle>
											</sb:title>
											<sb:volume-nr>vol. 4185</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>2006</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>179</sb:first-page>
									<sb:last-page>190</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0165">
						<ce:label>[33]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Yen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Finding the lengths of all shortest paths in n-node nonnegative-distance complete networks using 12
										<ce:italic>n</ce:italic>
										<ce:sup loc="post">3</ce:sup> additions and 
										<ce:italic>n</ce:italic>
										<ce:sup loc="post">3</ce:sup> comparisons
									</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Journal of the ACM</sb:maintitle>
										</sb:title>
										<sb:volume-nr>19</sb:volume-nr>
									</sb:series>
									<sb:date>1972</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>423</sb:first-page>
									<sb:last-page>424</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
				</ce:bibliography-sec>
			</ce:bibliography>
			<ce:biography id="vt1" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:simple-para id="p0505" view="all">
					<ce:bold>Carles Martínez</ce:bold> is a Ph.D. student in the Department of Information and Communications Engineering at the Universitat Autònoma de Barcelona. His current research is on authorization and access control infrastructures. He received his M.Sc. in computer science from Universitat Autònoma de Barcelona.
				</ce:simple-para>
			</ce:biography>
			<ce:biography id="vt2" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:simple-para id="p0510" view="all">
					<ce:bold>Guillermo Navarro</ce:bold> is an assistant professor in the Department of Information and Communications Engineering at the Universitat Autònoma de Barcelona. He received his Ph.D. in computer science from Universitat Autònoma de Barcelona. His main research interests comprise security in distributed systems, authorization and access control infrastructures, and data privacy.
				</ce:simple-para>
			</ce:biography>
			<ce:biography id="vt3" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:simple-para id="p0515" view="all">
					<ce:bold>Simon N. Foley</ce:bold> is a Statutory Lecturer in Computer Science at UCC where he teaches and carries out research on computer security. He serves on the editorial board of the Journal of Computer Security and has served as Program chair of the IEEE Computer Security Foundations Workshop and the ACM/ACSAC New Security Paradigms Workshop. He has over seventy international peer-reviewed publications on security, and his research interests include security modeling, distributed access controls, risk management, and security psychology.
				</ce:simple-para>
			</ce:biography>
			<ce:biography id="vt4" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:simple-para id="p0520" view="all">
					<ce:bold>Vicenç Torra</ce:bold> is an Associate Research Professor at the Artificial Intelligence Research Institute (IIIA-CSIC) Catalonia, Spain. His fields of interest are privacy technologies, decision making, information fusion and soft computing tools. He has had led several research projects. He is co-editor of the Transactions on Data Privacy and member of the editorial board of Information Sciences, Fuzzy Sets and Systems, and Journal of Advanced Computational Intelligence and Intel. Informatics. He is co-founder with Y. Narukawa of the conference series Modeling Decisions for Artificial Intelligence (MDAI) and Co-chairman of the Privacy in Statistical Databases conference (PSD 2004). He is president (2010-) of the Catalan Association for Artificial Intelligence.
				</ce:simple-para>
			</ce:biography>
			<ce:biography id="vt5" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:simple-para id="p0525" view="all">
					<ce:bold>Joan Borrell</ce:bold> is an Associate Professor in the Department of Information and Communications Engineering at the Universitat Autònoma de Barcelona, where he leads the Security of Networks and Distributed Applications (SeNDA) research group. His research interests include cryptographic protocols for electronic voting and electronic gambling, mobile agent applications and their security, and security of opportunistic computing. Since 1991, he has coauthored 3 patents and over 60 journal and conference papers, and he has supervised 6 Ph.D. thesis.
				</ce:simple-para>
			</ce:biography>
		</ja:tail>
	</ja:article></doc:document>
