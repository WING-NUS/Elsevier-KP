<doc:document xmlns:doc="http://www.elsevier.com/xml/document/schema"><rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="http://dx.doi.org/10.1016/j.ins.2011.04.013"><dc:format xmlns:dc="http://purl.org/dc/elements/1.1/">application/xml</dc:format><dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Minimum spanning tree based split-and-merge: A hierarchical clustering method</dc:title><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/"><rdf:Seq><rdf:li>Caiming Zhong</rdf:li><rdf:li>Duoqian Miao</rdf:li><rdf:li>Pasi Fränti</rdf:li></rdf:Seq></dc:creator><dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">Information Sciences 181 (2011) 3397-3410. doi:10.1016/j.ins.2011.04.013</dc:description><prism:aggregationType xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">journal</prism:aggregationType><prism:publicationName xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Information Sciences</prism:publicationName><prism:copyright xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Copyright © 2011 Elsevier Inc. All rights reserved.</prism:copyright><dc:publisher xmlns:dc="http://purl.org/dc/elements/1.1/">Elsevier Inc.</dc:publisher><prism:issn xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">0020-0255</prism:issn><prism:volume xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">181</prism:volume><prism:number xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">16</prism:number><prism:coverDisplayDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">2011</prism:coverDisplayDate><prism:coverDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">2011</prism:coverDate><prism:pageRange xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3397-3410</prism:pageRange><prism:startingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3397</prism:startingPage><prism:endingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3410</prism:endingPage><prism:doi xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">10.1016/j.ins.2011.04.013</prism:doi><prism:url xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">http://dx.doi.org/10.1016/j.ins.2011.04.013</prism:url><dc:identifier xmlns:dc="http://purl.org/dc/elements/1.1/">doi:10.1016/j.ins.2011.04.013</dc:identifier></rdf:Description></rdf:RDF><dp:document-properties xmlns:dp="http://www.elsevier.com/xml/common/doc-properties/schema"><dp:aggregation-type>Journals</dp:aggregation-type><dp:version-number>S300.1</dp:version-number></dp:document-properties><ja:article docsubtype="fla" xml:lang="en" version="5.1" xmlns:ja="http://www.elsevier.com/xml/ja/schema">
		<ja:item-info>
			<ja:jid>INS</ja:jid>
			<ja:aid>9064</ja:aid>
			<ce:pii xmlns:ce="http://www.elsevier.com/xml/common/schema">S0020-0255(11)00181-2</ce:pii>
			<ce:doi xmlns:ce="http://www.elsevier.com/xml/common/schema">10.1016/j.ins.2011.04.013</ce:doi>
			<ce:copyright type="full-transfer" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema">Elsevier Inc.</ce:copyright>
		</ja:item-info>
		<ce:floats xmlns:ce="http://www.elsevier.com/xml/common/schema">
			<ce:figure id="f0005">
				<ce:label>Fig. 1</ce:label>
				<ce:caption>
					<ce:simple-para id="sp010" view="all">The overview of split-and-merge. In Stage 1, the dataset 
						<ce:italic>X</ce:italic> is pruned into 
						<ce:italic>X</ce:italic>′ according to the MST of 
						<ce:italic>X</ce:italic>, and three iterations of MSTs of 
						<ce:italic>X</ce:italic>′ are computed and combined into a 3-MST graph. In Stage 2, 
						<ce:italic>X</ce:italic>′ is partitioned by 
						<ce:italic>K</ce:italic>-means, where the initial prototypes are generated from the 3-MST graph. The partitions are then adjusted so that each partition is a subtree of the MST of 
						<ce:italic>X</ce:italic>′. In Stage 3, the partitions are merged into the desired number of clusters and the pruned data points are distributed to the clusters.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr1"/>
			</ce:figure>
			<ce:figure id="f0010">
				<ce:label>Fig. 2</ce:label>
				<ce:caption>
					<ce:simple-para id="sp015" view="all">Illustration of the inter edges between subgroups 
						<ce:italic>C</ce:italic>
						<ce:inf loc="post">6</ce:inf> and 
						<ce:italic>C</ce:italic>
						<ce:inf loc="post">7</ce:inf>.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr2"/>
			</ce:figure>
			<ce:figure id="f0015">
				<ce:label>Fig. 3</ce:label>
				<ce:caption>
					<ce:simple-para id="sp020" view="all">Illustration of 
						<ce:italic>connSpan</ce:italic> between subgroups 
						<ce:italic>C</ce:italic>
						<ce:inf loc="post">6</ce:inf> and 
						<ce:italic>C</ce:italic>
						<ce:inf loc="post">7</ce:inf>.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr3"/>
			</ce:figure>
			<ce:figure id="f0020">
				<ce:label>Fig. 4</ce:label>
				<ce:caption>
					<ce:simple-para id="sp025" view="all">Illustration of the bisection process of a cluster 
						<ce:italic>C</ce:italic>
						<ce:inf loc="post">
							<ce:italic>i</ce:italic>
						</ce:inf>. The data set is bisected into 
						<mml:math altimg="si1.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msubsup>
									<mml:mrow>
										<mml:mi>C</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>i</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msubsup>
							</mml:mrow>
						</mml:math> and 
						<mml:math altimg="si2.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msubsup>
									<mml:mrow>
										<mml:mi>C</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>i</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>2</mml:mn>
									</mml:mrow>
								</mml:msubsup>
							</mml:mrow>
						</mml:math> by the cut so that the difference of cardinalities of 
						<mml:math altimg="si3.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msubsup>
									<mml:mrow>
										<mml:mi>C</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>i</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>1</mml:mn>
									</mml:mrow>
								</mml:msubsup>
							</mml:mrow>
						</mml:math> and 
						<mml:math altimg="si4.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:msubsup>
									<mml:mrow>
										<mml:mi>C</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mi>i</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:mn>2</mml:mn>
									</mml:mrow>
								</mml:msubsup>
							</mml:mrow>
						</mml:math> is minimal.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr4"/>
			</ce:figure>
			<ce:figure id="f0025">
				<ce:label>Fig. 5</ce:label>
				<ce:caption>
					<ce:simple-para id="sp030" view="all">Illustration of the six original synthetic datasets.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr5"/>
			</ce:figure>
			<ce:figure id="f0030">
				<ce:label>Fig. 6</ce:label>
				<ce:caption>
					<ce:simple-para id="sp035" view="all">Illustration of clustering results on DS1.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr6"/>
			</ce:figure>
			<ce:figure id="f0035">
				<ce:label>Fig. 7</ce:label>
				<ce:caption>
					<ce:simple-para id="sp040" view="all">Illustration of clustering results on DS2.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr7"/>
			</ce:figure>
			<ce:figure id="f0040">
				<ce:label>Fig. 8</ce:label>
				<ce:caption>
					<ce:simple-para id="sp045" view="all">Illustration of clustering results on DS3.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr8"/>
			</ce:figure>
			<ce:figure id="f0045">
				<ce:label>Fig. 9</ce:label>
				<ce:caption>
					<ce:simple-para id="sp050" view="all">Illustration of clustering results on DS4.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr9"/>
			</ce:figure>
			<ce:figure id="f0050">
				<ce:label>Fig. 10</ce:label>
				<ce:caption>
					<ce:simple-para id="sp055" view="all">Illustration of clustering results on DS5.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr10"/>
			</ce:figure>
			<ce:figure id="f0055">
				<ce:label>Fig. 11</ce:label>
				<ce:caption>
					<ce:simple-para id="sp060" view="all">Illustration of clustering results on DS6.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr11"/>
			</ce:figure>
			<ce:figure id="f0060">
				<ce:label>Fig. 12</ce:label>
				<ce:caption>
					<ce:simple-para id="sp065" view="all">The quality of clustering results for different values of 
						<ce:italic>k</ce:italic> to compute 
						<ce:italic>k</ce:italic>-MSTs.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr12"/>
			</ce:figure>
			<ce:table frame="topbot" id="t0005" rowsep="0" colsep="0">
				<ce:label>Table 1</ce:label>
				<ce:caption>
					<ce:simple-para id="sp070" view="all">Descriptions of used datasets.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="4" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="char" char="."/>
					<cals:colspec colname="col3" align="char" char="."/>
					<cals:colspec colname="col4" align="char" char="."/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Data set</ce:entry>
							<ce:entry>Data size (
								<ce:italic>N</ce:italic>)
							</ce:entry>
							<ce:entry>Dimensionality (
								<ce:italic>d</ce:italic>)
							</ce:entry>
							<ce:entry>Number of clusters (
								<ce:italic>K</ce:italic>)
							</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>DS1</ce:entry>
							<ce:entry align="char" char=".">373</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DS2</ce:entry>
							<ce:entry align="char" char=".">300</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
							<ce:entry align="char" char=".">3</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DS3</ce:entry>
							<ce:entry align="char" char=".">240</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DS4</ce:entry>
							<ce:entry align="char" char=".">788</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
							<ce:entry align="char" char=".">7</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DS5</ce:entry>
							<ce:entry align="char" char=".">3100</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
							<ce:entry align="char" char=".">31</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DS6</ce:entry>
							<ce:entry align="char" char=".">600</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
							<ce:entry align="char" char=".">15</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col4">
								<ce:vsp sp="0.5"/>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Iris</ce:entry>
							<ce:entry align="char" char=".">150</ce:entry>
							<ce:entry align="char" char=".">4</ce:entry>
							<ce:entry align="char" char=".">3</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Wine</ce:entry>
							<ce:entry align="char" char=".">178</ce:entry>
							<ce:entry align="char" char=".">13</ce:entry>
							<ce:entry align="char" char=".">3</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>WBC</ce:entry>
							<ce:entry align="char" char=".">683</ce:entry>
							<ce:entry align="char" char=".">9</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>WDBC</ce:entry>
							<ce:entry align="char" char=".">569</ce:entry>
							<ce:entry align="char" char=".">30</ce:entry>
							<ce:entry align="char" char=".">2</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0010" rowsep="0" colsep="0">
				<ce:label>Table 2</ce:label>
				<ce:caption>
					<ce:simple-para id="sp075" view="all">Adjusted Rand index values of clustering performances on the six synthetic datasets.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="7" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="char" char="."/>
					<cals:colspec colname="col3" align="char" char="."/>
					<cals:colspec colname="col4" align="char" char="."/>
					<cals:colspec colname="col5" align="char" char="."/>
					<cals:colspec colname="col6" align="char" char="."/>
					<cals:colspec colname="col7" align="char" char="."/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Method</ce:entry>
							<ce:entry>DS1</ce:entry>
							<ce:entry>DS2</ce:entry>
							<ce:entry>DS3</ce:entry>
							<ce:entry>DS4</ce:entry>
							<ce:entry>DS5</ce:entry>
							<ce:entry>DS6</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>SAM</ce:entry>
							<ce:entry align="char" char=".">1.0000</ce:entry>
							<ce:entry align="char" char=".">0.9597</ce:entry>
							<ce:entry align="char" char=".">0.9339</ce:entry>
							<ce:entry align="char" char=".">0.9835</ce:entry>
							<ce:entry align="char" char=".">0.8896</ce:entry>
							<ce:entry align="char" char=".">0.9928</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-No-Pruning</ce:entry>
							<ce:entry align="char" char=".">1.0000</ce:entry>
							<ce:entry align="char" char=".">0.7272</ce:entry>
							<ce:entry align="char" char=".">0.9180</ce:entry>
							<ce:entry align="char" char=".">0.9920</ce:entry>
							<ce:entry align="char" char=".">0.8051</ce:entry>
							<ce:entry align="char" char=".">0.8723</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-2-MST</ce:entry>
							<ce:entry align="char" char=".">0.3181</ce:entry>
							<ce:entry align="char" char=".">0.9597</ce:entry>
							<ce:entry align="char" char=".">0.9178</ce:entry>
							<ce:entry align="char" char=".">0.9902</ce:entry>
							<ce:entry align="char" char=".">0.8183</ce:entry>
							<ce:entry align="char" char=".">0.8375</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-SL</ce:entry>
							<ce:entry align="char" char=".">0.2563</ce:entry>
							<ce:entry align="char" char=".">0.6130</ce:entry>
							<ce:entry align="char" char=".">0.9178</ce:entry>
							<ce:entry align="char" char=".">0.8743</ce:entry>
							<ce:entry align="char" char=".">0.8755</ce:entry>
							<ce:entry align="char" char=".">0.9928</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col7">
								<ce:vsp sp="0.5"/>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>K</ce:italic>-means
							</ce:entry>
							<ce:entry align="char" char=".">0.5146</ce:entry>
							<ce:entry align="char" char=".">0.4739</ce:entry>
							<ce:entry align="char" char=".">0.4312</ce:entry>
							<ce:entry align="char" char=".">0.7186</ce:entry>
							<ce:entry align="char" char=".">0.8218</ce:entry>
							<ce:entry align="char" char=".">0.8055</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Single linkage</ce:entry>
							<ce:entry align="char" char=".">0.2563</ce:entry>
							<ce:entry align="char" char=".">0.0004</ce:entry>
							<ce:entry align="char" char=".">0.0103</ce:entry>
							<ce:entry align="char" char=".">0.7996</ce:entry>
							<ce:entry align="char" char=".">0.1739</ce:entry>
							<ce:entry align="char" char=".">0.5425</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DBScan</ce:entry>
							<ce:entry align="char" char=".">1.0000</ce:entry>
							<ce:entry align="char" char=".">0.8213</ce:entry>
							<ce:entry align="char" char=".">0.8859</ce:entry>
							<ce:entry align="char" char=".">0.8043</ce:entry>
							<ce:entry align="char" char=".">0.4321</ce:entry>
							<ce:entry align="char" char=".">0.8804</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Spectral clustering</ce:entry>
							<ce:entry align="char" char=".">0.3178</ce:entry>
							<ce:entry align="char" char=".">0.8757</ce:entry>
							<ce:entry align="char" char=".">0.9178</ce:entry>
							<ce:entry align="char" char=".">0.9919</ce:entry>
							<ce:entry align="char" char=".">0.9522</ce:entry>
							<ce:entry align="char" char=".">0.9928</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CSM</ce:entry>
							<ce:entry align="char" char=".">1.0000</ce:entry>
							<ce:entry align="char" char=".">0.9118</ce:entry>
							<ce:entry align="char" char=".">0.9667</ce:entry>
							<ce:entry align="char" char=".">0.9978</ce:entry>
							<ce:entry align="char" char=".">0.9196</ce:entry>
							<ce:entry align="char" char=".">0.9857</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CHAMELEON</ce:entry>
							<ce:entry align="char" char=".">1.0000</ce:entry>
							<ce:entry align="char" char=".">0.4756</ce:entry>
							<ce:entry align="char" char=".">0.9617</ce:entry>
							<ce:entry align="char" char=".">1.0000</ce:entry>
							<ce:entry align="char" char=".">0.9274</ce:entry>
							<ce:entry align="char" char=".">0.9928</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0015" rowsep="0" colsep="0">
				<ce:label>Table 3</ce:label>
				<ce:caption>
					<ce:simple-para id="sp080" view="all">Clustering performances on IRIS.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="5" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="char" char="."/>
					<cals:colspec colname="col3" align="char" char="."/>
					<cals:colspec colname="col4" align="char" char="."/>
					<cals:colspec colname="col5" align="char" char="."/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Method</ce:entry>
							<ce:entry>Rand</ce:entry>
							<ce:entry>Adjusted Rand</ce:entry>
							<ce:entry>Jaccard</ce:entry>
							<ce:entry>FM</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>SAM</ce:entry>
							<ce:entry align="char" char=".">0.9495</ce:entry>
							<ce:entry align="char" char=".">0.8858</ce:entry>
							<ce:entry align="char" char=".">0.8578</ce:entry>
							<ce:entry align="char" char=".">0.9234</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-No-Pruning</ce:entry>
							<ce:entry align="char" char=".">0.9075</ce:entry>
							<ce:entry align="char" char=".">0.7436</ce:entry>
							<ce:entry align="char" char=".">0.7298</ce:entry>
							<ce:entry align="char" char=".">0.8548</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-2-MST</ce:entry>
							<ce:entry align="char" char=".">0.9495</ce:entry>
							<ce:entry align="char" char=".">0.8858</ce:entry>
							<ce:entry align="char" char=".">0.8578</ce:entry>
							<ce:entry align="char" char=".">0.9234</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-SL</ce:entry>
							<ce:entry align="char" char=".">0.9495</ce:entry>
							<ce:entry align="char" char=".">0.8858</ce:entry>
							<ce:entry align="char" char=".">0.8578</ce:entry>
							<ce:entry align="char" char=".">0.9234</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col5">
								<ce:vsp sp="0.5"/>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>K</ce:italic>-means
							</ce:entry>
							<ce:entry align="char" char=".">0.8797</ce:entry>
							<ce:entry align="char" char=".">0.7302</ce:entry>
							<ce:entry align="char" char=".">0.6959</ce:entry>
							<ce:entry align="char" char=".">0.8208</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Single linkage</ce:entry>
							<ce:entry align="char" char=".">0.7766</ce:entry>
							<ce:entry align="char" char=".">0.5638</ce:entry>
							<ce:entry align="char" char=".">0.5891</ce:entry>
							<ce:entry align="char" char=".">0.7635</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DBScan</ce:entry>
							<ce:entry align="char" char=".">0.8834</ce:entry>
							<ce:entry align="char" char=".">0.7388</ce:entry>
							<ce:entry align="char" char=".">0.7044</ce:entry>
							<ce:entry align="char" char=".">0.8268</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Spectral clustering</ce:entry>
							<ce:entry align="char" char=".">0.8115</ce:entry>
							<ce:entry align="char" char=".">0.5745</ce:entry>
							<ce:entry align="char" char=".">0.5571</ce:entry>
							<ce:entry align="char" char=".">0.7156</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CSM</ce:entry>
							<ce:entry align="char" char=".">0.8859</ce:entry>
							<ce:entry align="char" char=".">0.7455</ce:entry>
							<ce:entry align="char" char=".">0.7119</ce:entry>
							<ce:entry align="char" char=".">0.8321</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CHAMELEON</ce:entry>
							<ce:entry align="char" char=".">0.7783</ce:entry>
							<ce:entry align="char" char=".">0.5492</ce:entry>
							<ce:entry align="char" char=".">0.5680</ce:entry>
							<ce:entry align="char" char=".">0.7369</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0020" rowsep="0" colsep="0">
				<ce:label>Table 4</ce:label>
				<ce:caption>
					<ce:simple-para id="sp085" view="all">Clustering performances on WINE.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="5" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="char" char="."/>
					<cals:colspec colname="col3" align="char" char="."/>
					<cals:colspec colname="col4" align="char" char="."/>
					<cals:colspec colname="col5" align="char" char="."/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Method</ce:entry>
							<ce:entry>Rand</ce:entry>
							<ce:entry>Adjusted Rand</ce:entry>
							<ce:entry>Jaccard</ce:entry>
							<ce:entry>FM</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>SAM</ce:entry>
							<ce:entry align="char" char=".">0.7334</ce:entry>
							<ce:entry align="char" char=".">0.4007</ce:entry>
							<ce:entry align="char" char=".">0.4294</ce:entry>
							<ce:entry align="char" char=".">0.6009</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-No-Pruning</ce:entry>
							<ce:entry align="char" char=".">0.7012</ce:entry>
							<ce:entry align="char" char=".">0.3842</ce:entry>
							<ce:entry align="char" char=".">0.4113</ce:entry>
							<ce:entry align="char" char=".">0.5819</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-2-MST</ce:entry>
							<ce:entry align="char" char=".">0.7334</ce:entry>
							<ce:entry align="char" char=".">0.4007</ce:entry>
							<ce:entry align="char" char=".">0.4294</ce:entry>
							<ce:entry align="char" char=".">0.6009</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-SL</ce:entry>
							<ce:entry align="char" char=".">0.6976</ce:entry>
							<ce:entry align="char" char=".">0.3956</ce:entry>
							<ce:entry align="char" char=".">0.4702</ce:entry>
							<ce:entry align="char" char=".">0.6521</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col5">
								<ce:vsp sp="0.5"/>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>K</ce:italic>-means
							</ce:entry>
							<ce:entry align="char" char=".">0.8797</ce:entry>
							<ce:entry align="char" char=".">0.7302</ce:entry>
							<ce:entry align="char" char=".">0.6959</ce:entry>
							<ce:entry align="char" char=".">0.8208</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Single linkage</ce:entry>
							<ce:entry align="char" char=".">0.7766</ce:entry>
							<ce:entry align="char" char=".">0.5638</ce:entry>
							<ce:entry align="char" char=".">0.5891</ce:entry>
							<ce:entry align="char" char=".">0.7635</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DBScan</ce:entry>
							<ce:entry align="char" char=".">0.6878</ce:entry>
							<ce:entry align="char" char=".">0.3171</ce:entry>
							<ce:entry align="char" char=".">0.3866</ce:entry>
							<ce:entry align="char" char=".">0.5582</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Spectral clustering</ce:entry>
							<ce:entry align="char" char=".">0.7655</ce:entry>
							<ce:entry align="char" char=".">0.4741</ce:entry>
							<ce:entry align="char" char=".">0.4821</ce:entry>
							<ce:entry align="char" char=".">0.6506</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CSM</ce:entry>
							<ce:entry align="char" char=".">0.6742</ce:entry>
							<ce:entry align="char" char=".">0.3757</ce:entry>
							<ce:entry align="char" char=".">0.4708</ce:entry>
							<ce:entry align="char" char=".">0.6618</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CHAMELEON</ce:entry>
							<ce:entry align="char" char=".">0.7364</ce:entry>
							<ce:entry align="char" char=".">0.4769</ce:entry>
							<ce:entry align="char" char=".">0.5266</ce:entry>
							<ce:entry align="char" char=".">0.7049</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0025" rowsep="0" colsep="0">
				<ce:label>Table 5</ce:label>
				<ce:caption>
					<ce:simple-para id="sp090" view="all">Clustering performances on WBC.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="5" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="char" char="."/>
					<cals:colspec colname="col3" align="char" char="."/>
					<cals:colspec colname="col4" align="char" char="."/>
					<cals:colspec colname="col5" align="char" char="."/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Method</ce:entry>
							<ce:entry>Rand</ce:entry>
							<ce:entry>Adjusted Rand</ce:entry>
							<ce:entry>Jaccard</ce:entry>
							<ce:entry>FM</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>SAM</ce:entry>
							<ce:entry align="char" char=".">0.9026</ce:entry>
							<ce:entry align="char" char=".">0.8033</ce:entry>
							<ce:entry align="char" char=".">0.8372</ce:entry>
							<ce:entry align="char" char=".">0.9114</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-No-Pruning</ce:entry>
							<ce:entry align="char" char=".">0.8876</ce:entry>
							<ce:entry align="char" char=".">0.7682</ce:entry>
							<ce:entry align="char" char=".">0.8061</ce:entry>
							<ce:entry align="char" char=".">0.8953</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-2-MST</ce:entry>
							<ce:entry align="char" char=".">0.8922</ce:entry>
							<ce:entry align="char" char=".">0.7820</ce:entry>
							<ce:entry align="char" char=".">0.8222</ce:entry>
							<ce:entry align="char" char=".">0.9025</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-SL</ce:entry>
							<ce:entry align="char" char=".">0.5565</ce:entry>
							<ce:entry align="char" char=".">0.0337</ce:entry>
							<ce:entry align="char" char=".">0.5453</ce:entry>
							<ce:entry align="char" char=".">0.7346</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col5">
								<ce:vsp sp="0.5"/>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>K</ce:italic>-means
							</ce:entry>
							<ce:entry align="char" char=".">0.9240</ce:entry>
							<ce:entry align="char" char=".">0.8465</ce:entry>
							<ce:entry align="char" char=".">0.8703</ce:entry>
							<ce:entry align="char" char=".">0.9307</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Single linkage</ce:entry>
							<ce:entry align="char" char=".">0.5453</ce:entry>
							<ce:entry align="char" char=".">0.0025</ce:entry>
							<ce:entry align="char" char=".">0.5444</ce:entry>
							<ce:entry align="char" char=".">0.7375</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DBScan</ce:entry>
							<ce:entry align="char" char=".">0.8767</ce:entry>
							<ce:entry align="char" char=".">0.7529</ce:entry>
							<ce:entry align="char" char=".">0.7913</ce:entry>
							<ce:entry align="char" char=".">0.8838</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Spectral clustering</ce:entry>
							<ce:entry align="char" char=".">0.5218</ce:entry>
							<ce:entry align="char" char=".">0.0246</ce:entry>
							<ce:entry align="char" char=".">0.4142</ce:entry>
							<ce:entry align="char" char=".">0.5867</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CSM</ce:entry>
							<ce:entry align="char" char=".">0.5658</ce:entry>
							<ce:entry align="char" char=".">0.0585</ce:entry>
							<ce:entry align="char" char=".">0.5468</ce:entry>
							<ce:entry align="char" char=".">0.7333</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CHAMELEON</ce:entry>
							<ce:entry align="char" char=".">0.5235</ce:entry>
							<ce:entry align="char" char=".">0.0279</ce:entry>
							<ce:entry align="char" char=".">0.5107</ce:entry>
							<ce:entry align="char" char=".">0.7007</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0030" rowsep="0" colsep="0">
				<ce:label>Table 6</ce:label>
				<ce:caption>
					<ce:simple-para id="sp095" view="all">Clustering performances on WDBC.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="5" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="char" char="."/>
					<cals:colspec colname="col3" align="char" char="."/>
					<cals:colspec colname="col4" align="char" char="."/>
					<cals:colspec colname="col5" align="char" char="."/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Method</ce:entry>
							<ce:entry>Rand</ce:entry>
							<ce:entry>Adjusted Rand</ce:entry>
							<ce:entry>Jaccard</ce:entry>
							<ce:entry>FM</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>SAM</ce:entry>
							<ce:entry align="char" char=".">0.8138</ce:entry>
							<ce:entry align="char" char=".">0.6269</ce:entry>
							<ce:entry align="char" char=".">0.6981</ce:entry>
							<ce:entry align="char" char=".">0.8223</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-No-Pruning</ce:entry>
							<ce:entry align="char" char=".">0.8003</ce:entry>
							<ce:entry align="char" char=".">0.6091</ce:entry>
							<ce:entry align="char" char=".">0.6772</ce:entry>
							<ce:entry align="char" char=".">0.8101</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-2-MST</ce:entry>
							<ce:entry align="char" char=".">0.8012</ce:entry>
							<ce:entry align="char" char=".">0.6190</ce:entry>
							<ce:entry align="char" char=".">0.6811</ce:entry>
							<ce:entry align="char" char=".">0.8197</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>SAM-SL</ce:entry>
							<ce:entry align="char" char=".">0.5308</ce:entry>
							<ce:entry align="char" char=".">0.0032</ce:entry>
							<ce:entry align="char" char=".">0.5219</ce:entry>
							<ce:entry align="char" char=".">0.7162</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry namest="col1" nameend="col5">
								<ce:vsp sp="0.5"/>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>K</ce:italic>-means
							</ce:entry>
							<ce:entry align="char" char=".">0.7504</ce:entry>
							<ce:entry align="char" char=".">0.4914</ce:entry>
							<ce:entry align="char" char=".">0.6499</ce:entry>
							<ce:entry align="char" char=".">0.7915</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Single linkage</ce:entry>
							<ce:entry align="char" char=".">0.5326</ce:entry>
							<ce:entry align="char" char=".">0.0024</ce:entry>
							<ce:entry align="char" char=".">0.5315</ce:entry>
							<ce:entry align="char" char=".">0.7286</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>DBScan</ce:entry>
							<ce:entry align="char" char=".">0.8691</ce:entry>
							<ce:entry align="char" char=".">0.7367</ce:entry>
							<ce:entry align="char" char=".">0.7828</ce:entry>
							<ce:entry align="char" char=".">0.8782</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>Spectral clustering</ce:entry>
							<ce:entry align="char" char=".">0.7479</ce:entry>
							<ce:entry align="char" char=".">0.4945</ce:entry>
							<ce:entry align="char" char=".">0.6133</ce:entry>
							<ce:entry align="char" char=".">0.7604</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CSM</ce:entry>
							<ce:entry align="char" char=".">0.5860</ce:entry>
							<ce:entry align="char" char=".">0.1335</ce:entry>
							<ce:entry align="char" char=".">0.5392</ce:entry>
							<ce:entry align="char" char=".">0.7201</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>CHAMELEON</ce:entry>
							<ce:entry align="char" char=".">0.8365</ce:entry>
							<ce:entry align="char" char=".">0.6703</ce:entry>
							<ce:entry align="char" char=".">0.7406</ce:entry>
							<ce:entry align="char" char=".">0.8514</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
		</ce:floats>
		<ja:head>
			<ce:title xmlns:ce="http://www.elsevier.com/xml/common/schema">Minimum spanning tree based split-and-merge: A hierarchical clustering method</ce:title>
			<ce:author-group xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:author>
					<ce:given-name>Caiming</ce:given-name>
					<ce:surname>Zhong</ce:surname>
					<ce:cross-ref refid="aff1">
						<ce:sup loc="post">a</ce:sup>
					</ce:cross-ref>
					<ce:cross-ref refid="aff2">
						<ce:sup loc="post">b</ce:sup>
					</ce:cross-ref>
					<ce:cross-ref refid="aff3">
						<ce:sup loc="post">c</ce:sup>
					</ce:cross-ref>
				</ce:author>
				<ce:author>
					<ce:given-name>Duoqian</ce:given-name>
					<ce:surname>Miao</ce:surname>
					<ce:cross-ref refid="aff1">
						<ce:sup loc="post">a</ce:sup>
					</ce:cross-ref>
					<ce:cross-ref refid="cor1">
						<ce:sup loc="post">⁎</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">miaoduoqian@163.com</ce:e-address>
				</ce:author>
				<ce:author>
					<ce:given-name>Pasi</ce:given-name>
					<ce:surname>Fränti</ce:surname>
					<ce:cross-ref refid="aff2">
						<ce:sup loc="post">b</ce:sup>
					</ce:cross-ref>
				</ce:author>
				<ce:affiliation id="aff1">
					<ce:label>a</ce:label>
					<ce:textfn>Department of Computer Science and Technology, Tongji University, Shanghai 201804, PR China</ce:textfn>
				</ce:affiliation>
				<ce:affiliation id="aff2">
					<ce:label>b</ce:label>
					<ce:textfn>Department of Computer Science, University of Eastern Finland, P.O. Box: 111, FIN-80101 Joensuu, Finland</ce:textfn>
				</ce:affiliation>
				<ce:affiliation id="aff3">
					<ce:label>c</ce:label>
					<ce:textfn>College of Science and Technology, Ningbo University, Ningbo 315211, PR China</ce:textfn>
				</ce:affiliation>
				<ce:correspondence id="cor1">
					<ce:label>⁎</ce:label>
					<ce:text>Corresponding author. Tel.: +86 21 69589867.</ce:text>
				</ce:correspondence>
			</ce:author-group>
			<ce:date-received day="6" month="12" year="2009" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:date-revised day="4" month="4" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:date-accepted day="6" month="4" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:abstract class="author" xml:lang="en" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Abstract</ce:section-title>
				<ce:abstract-sec>
					<ce:simple-para id="sp005" view="all">Most clustering algorithms become ineffective when provided with unsuitable parameters or applied to datasets which are composed of clusters with diverse shapes, sizes, and densities. To alleviate these deficiencies, we propose a novel split-and-merge hierarchical clustering method in which a minimum spanning tree (MST) and an MST-based graph are employed to guide the splitting and merging process. In the splitting process, vertices with high degrees in the MST-based graph are selected as initial prototypes, and 
						<ce:italic>K</ce:italic>-means is used to split the dataset. In the merging process, subgroup pairs are filtered and only neighboring pairs are considered for merge. The proposed method requires no parameter except the number of clusters. Experimental results demonstrate its effectiveness both on synthetic and real datasets.
					</ce:simple-para>
				</ce:abstract-sec>
			</ce:abstract>
		</ja:head>
		<ja:body view="all">
			<ce:sections xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section id="s0005" view="all">
					<ce:label>1</ce:label>
					<ce:section-title>Introduction</ce:section-title>
					<ce:para id="p0005" view="all">Clustering plays an important role in data mining, pattern recognition, and machine learning. It aims at grouping 
						<ce:italic>N</ce:italic> data points into 
						<ce:italic>K</ce:italic> clusters so that data points within the same cluster are similar, while data points in diverse clusters are different from each other. From the machine learning point of view, clustering is unsupervised learning as it classifies a dataset without any a priori knowledge. A large number of clustering algorithms 
						<ce:cross-refs refid="b0100 b0185 b0230">[20,37,46]</ce:cross-refs> have been presented in the literature since 
						<ce:italic>K</ce:italic>-means 
						<ce:cross-ref refid="b0160">[32]</ce:cross-ref>, one of the most popular clustering algorithms, was published. The algorithms can be grouped into hierarchical clustering 
						<ce:cross-refs refid="b0060 b0075 b0080 b0095 b0135">[12,15,16,19,27]</ce:cross-refs>, partitional clustering 
						<ce:cross-refs refid="b0010 b0030 b0085 b0120 b0160 b0175">[2,6,17,24,32,35]</ce:cross-refs>, density-based clustering 
						<ce:cross-refs refid="b0050 b0090">[10,18]</ce:cross-refs>, grid-based clustering 
						<ce:cross-refs refid="b0005 b0215">[1,43]</ce:cross-refs>, model-based clustering 
						<ce:cross-refs refid="b0055 b0165">[11,33]</ce:cross-refs>, and graph-based clustering 
						<ce:cross-refs refid="b0145 b0190 b0200 b0225 b0235 b0245">[29,38,40,45,47,49]</ce:cross-refs>. Hierarchical and partitional clustering are the two most common groups 
						<ce:cross-ref refid="b0150">[30]</ce:cross-ref>.
					</ce:para>
					<ce:para id="p0010" view="all">Generally, a hierarchical clustering algorithm partitions a dataset into various clusters by an agglomerative or a divisive approach based on a dendrogram. Agglomerative clustering starts by considering each point as a cluster, and iteratively combines two most similar clusters in terms of an objective function. In contrast, divisive clustering starts with only one cluster including all data points. It iteratively selects a cluster and partitions it into two subclusters. The main advantage of hierarchical clustering is that it produces a nested tree of partitions and can therefore be more informative than non-hierarchical clustering. Furthermore, with the dendrogram, the optimal number of clusters can be determined. However, hierarchical clustering has a relatively high computational cost. Single linkage 
						<ce:cross-ref refid="b0195">[39]</ce:cross-ref> and complete linkage 
						<ce:cross-ref refid="b0130">[26]</ce:cross-ref> are two well-known examples of hierarchical clustering algorithms, and they take 
						<ce:italic>O</ce:italic>(
						<ce:italic>N</ce:italic>
						<ce:sup loc="post">2</ce:sup>
						<ce:hsp sp="0.12"/>log
						<ce:italic>N</ce:italic>) time.
					</ce:para>
					<ce:para id="p0015" view="all">Partitional clustering splits a dataset at once using an objective function. 
						<ce:italic>K</ce:italic>-means is one of the most popular examples of partitional clustering. It employs mean-squared-error as its objective function. Its main advantage is that it runs efficiently: its computational complexity is 
						<ce:italic>O</ce:italic>(
						<ce:italic>NKId</ce:italic>), where 
						<ce:italic>I</ce:italic> is the number of iterations for convergence, and 
						<ce:italic>d</ce:italic> is the dimensionality of the dataset. Since 
						<ce:italic>K</ce:italic> and 
						<ce:italic>d</ce:italic> are usually far less than 
						<ce:italic>N</ce:italic>, the algorithm runs in a linear time on low-dimensional data. However, there does not exist a universal objective function that can be used to discover all different intrinsic structures of datasets. Therefore, partitional clustering produces inaccurate results when the objective function used does not capture the intrinsic structure of the data. This is the reason why partitional clustering algorithms are incapable of dealing with clusters of arbitrary shapes, different sizes and densities.
					</ce:para>
					<ce:para id="p0020" view="all">Clustering algorithms that combine the advantages of hierarchical and partitional clustering have been proposed in the literature 
						<ce:cross-refs refid="b0025 b0115 b0125 b0140 b0150 b0155">[5,23,25,28,30,31]</ce:cross-refs>. This kind of hybrid algorithms analyzes the dataset in two stages. In the first stage, the dataset is split into a number of subsets with a partitioning criterion. In the second stage, the produced subsets are merged in terms of a similarity measure. Different split and merge approaches have been designed in several hybrid algorithms. CSM 
						<ce:cross-ref refid="b0150">[30]</ce:cross-ref> first applies 
						<ce:italic>K</ce:italic>-means to partition the dataset into 
						<ce:italic>K</ce:italic>′ subsets, where 
						<ce:italic>K</ce:italic>′ is an input parameter. Afterwards, single linkage, which uses a dedicated cohesion function as the similarity measure, is utilized to iteratively merge the 
						<ce:italic>K</ce:italic>′ subsets until 
						<ce:italic>K</ce:italic> subsets are achieved. In the split stage, as 
						<ce:italic>K</ce:italic>-means may produce different partitions in different runs, the final results may be unstable.
					</ce:para>
					<ce:para id="p0025" view="all">CHAMELEON 
						<ce:cross-ref refid="b0115">[23]</ce:cross-ref> is another example of a hybrid clustering algorithm. It constructs a 
						<ce:italic>K</ce:italic>-nearest neighbor graph, and employs a graph cut scheme to partition the graph into 
						<ce:italic>K</ce:italic>′ subsets. Relative inter-connectivity and relative closeness are defined to merge the subsets. Liu et al. 
						<ce:cross-ref refid="b0155">[31]</ce:cross-ref> proposed a multi-prototype clustering algorithm, which can also be considered as a hybrid method. The method uses a convergence mechanism, and repeatedly performs split and merge operations until the prototypes remain unchanged. However, many empirical parameters are involved. Kaukoranta et al. 
						<ce:cross-ref refid="b0125">[25]</ce:cross-ref> proposed a split-and-merge algorithm, where the objective function is to minimize the mean squared error.
					</ce:para>
					<ce:para id="p0030" view="all">A minimum spanning tree (MST) is a useful graph structure, which has been employed to capture perceptual grouping 
						<ce:cross-ref refid="b0105">[21]</ce:cross-ref>. Zahn defined several criteria of edge inconsistency for detecting clusters of different shapes 
						<ce:cross-ref refid="b0245">[49]</ce:cross-ref>. However, for datasets consisting of differently shaped clusters, the method lacks an adaptive selection of the criteria. Xu et al. 
						<ce:cross-ref refid="b0235">[47]</ce:cross-ref> proposed three MST-based algorithms: removing long MST-edges, a center-based iterative algorithm, and a representative-based global optimal algorithm. But for a specific dataset, users do not know which algorithm is suitable.
					</ce:para>
					<ce:para id="p0035" view="all">In this paper, we propose a minimum spanning tree based split-and-merge method (SAM). It works on numerical data and assumes that the graph can be calculated in a vector space. In the splitting stage, three iterations of MSTs are used to construct a neighborhood graph called 3-MST graph. The vertices with high degrees in the graph are selected as the initial prototypes, and 
						<ce:italic>K</ce:italic>-means is then applied. In the merge stage, the neighboring subsets with respect to the MST are filtered out and considered for merge.
					</ce:para>
					<ce:para id="p0040" view="all">The rest of the paper is organized as follows: In Section 
						<ce:cross-ref refid="s0010">2</ce:cross-ref>, the proposed algorithm is described. The experimental results are presented in Section 
						<ce:cross-ref refid="s0080">3</ce:cross-ref>, and conclusions are drawn in Section 
						<ce:cross-ref refid="s0105">4</ce:cross-ref>.
					</ce:para>
				</ce:section>
				<ce:section id="s0010" view="all">
					<ce:label>2</ce:label>
					<ce:section-title>The proposed method</ce:section-title>
					<ce:section id="s0015" view="all">
						<ce:label>2.1</ce:label>
						<ce:section-title>Problem formulation</ce:section-title>
						<ce:para id="p0045" view="all">Given a set of data points 
							<ce:italic>X</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>{
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">2</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>N</ce:italic>
							</ce:inf>}, where 
							<mml:math altimg="si5.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="bold">x</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo>=</mml:mo>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>x</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
											<mml:mn>1</mml:mn>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:msub>
										<mml:mrow>
											<mml:mi>x</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
											<mml:mn>2</mml:mn>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:mo>…</mml:mo>
									<mml:mtext>,</mml:mtext>
									<mml:msub>
										<mml:mrow>
											<mml:mi>x</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">ij</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:mo>…</mml:mo>
									<mml:mtext>,</mml:mtext>
									<mml:msub>
										<mml:mrow>
											<mml:mi>x</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">id</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:msup>
										<mml:mrow>
											<mml:mo stretchy="false">)</mml:mo>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>T</mml:mi>
										</mml:mrow>
									</mml:msup>
									<mml:mo>∈</mml:mo>
									<mml:msup>
										<mml:mrow>
											<mml:mi mathvariant="fraktur">R</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>d</mml:mi>
										</mml:mrow>
									</mml:msup>
								</mml:mrow>
							</mml:math> is a feature vector, the goal of clustering is to partition the set 
							<ce:italic>X</ce:italic> into 
							<ce:italic>K</ce:italic> clusters: 
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">1</ce:inf>, 
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">2</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>K</ce:italic>
							</ce:inf>, where 
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>≠
							<ce:hsp sp="0.25"/>∅, 
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∩
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>j</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>∅, 
							<ce:italic>X</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">1</ce:inf>
							<ce:hsp sp="0.25"/>∪
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">2</ce:inf>
							<ce:hsp sp="0.25"/>⋯
							<ce:hsp sp="0.25"/>∪
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>K</ce:italic>
							</ce:inf>, 
							<ce:italic>i</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>1: 
							<ce:italic>K</ce:italic>, 
							<ce:italic>j</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>1: 
							<ce:italic>K</ce:italic>, 
							<ce:italic>i</ce:italic>
							<ce:hsp sp="0.25"/>≠
							<ce:hsp sp="0.25"/>
							<ce:italic>j</ce:italic>. An undirected graph has been employed to represent a dataset for clustering 
							<ce:cross-refs refid="b0190 b0245">[38,49]</ce:cross-refs>. Let 
							<ce:italic>G</ce:italic>(
							<ce:italic>X</ce:italic>)
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>(
							<ce:italic>V</ce:italic>,
							<ce:hsp sp="0.12"/>
							<ce:italic>E</ce:italic>) denote the undirected complete graph of 
							<ce:italic>X</ce:italic>, the weights of the edges can be calculated with function 
							<mml:math altimg="si6.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mi>w</mml:mi>
									<mml:mo>:</mml:mo>
									<mml:mi>E</mml:mi>
									<mml:mo>→</mml:mo>
									<mml:mi mathvariant="double-struck">R</mml:mi>
								</mml:mrow>
							</mml:math>, where 
							<ce:italic>V</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>X</ce:italic>, 
							<ce:italic>E</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>{(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>j</ce:italic>
							</ce:inf>)∣
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>j</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>X</ce:italic>,
							<ce:hsp sp="0.12"/>
							<ce:italic>i</ce:italic>
							<ce:hsp sp="0.25"/>≠
							<ce:hsp sp="0.25"/>
							<ce:italic>j</ce:italic>}, and 
							<mml:math altimg="si7.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mi>w</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="bold">x</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mtext>,</mml:mtext>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="bold">x</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>j</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>=</mml:mo>
									<mml:msqrt>
										<mml:mrow>
											<mml:mo stretchy="false">(</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi mathvariant="bold">x</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>i</mml:mi>
												</mml:mrow>
											</mml:msub>
											<mml:mo>-</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi mathvariant="bold">x</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
											</mml:msub>
											<mml:msup>
												<mml:mrow>
													<mml:mo stretchy="false">)</mml:mo>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>T</mml:mi>
												</mml:mrow>
											</mml:msup>
											<mml:mo stretchy="false">(</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi mathvariant="bold">x</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>i</mml:mi>
												</mml:mrow>
											</mml:msub>
											<mml:mo>-</mml:mo>
											<mml:msub>
												<mml:mrow>
													<mml:mi mathvariant="bold">x</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>j</mml:mi>
												</mml:mrow>
											</mml:msub>
											<mml:mo stretchy="false">)</mml:mo>
										</mml:mrow>
									</mml:msqrt>
								</mml:mrow>
							</mml:math>.
						</ce:para>
					</ce:section>
					<ce:section id="s0020" view="all">
						<ce:label>2.2</ce:label>
						<ce:section-title>Overview of the split-and-merge algorithm</ce:section-title>
						<ce:para id="p0050" view="all">The algorithm consists of three main stages as illustrated in 
							<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref>
							<ce:float-anchor refid="f0005"/>. First, an MST of the given dataset is constructed to guide the clustering process. In the splitting stage, 
							<ce:italic>K</ce:italic>-means is applied to split the dataset into subsets, which are then adjusted according to the MST. In the merge stage, the final clusters are obtained by performing a carefully designed criterion-based merge that aims at maximizing intra-cluster similarity and minimizing inter-connectivity between the clusters.
						</ce:para>
					</ce:section>
					<ce:section id="s0025" view="all">
						<ce:label>2.3</ce:label>
						<ce:section-title>The stage of constructing a 3-MST graph</ce:section-title>
						<ce:section id="s0030" view="all">
							<ce:label>2.3.1</ce:label>
							<ce:section-title>Pruning leaves</ce:section-title>
							<ce:para id="p0055" view="all">A minimum spanning tree (MST) of graph 
								<ce:italic>G</ce:italic>(
								<ce:italic>X</ce:italic>) is a spanning tree 
								<ce:italic>T</ce:italic> such that 
								<mml:math altimg="si8.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi>W</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mo>∑</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="bold">x</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mtext>,</mml:mtext>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="bold">x</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>∈</mml:mo>
												<mml:mi>T</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mi>w</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="bold">x</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="bold">x</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>j</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> is minimum. The leaves of an MST, called hairs in 
								<ce:cross-ref refid="b0245">[49]</ce:cross-ref>, are the vertices of degree 1. The leaves usually locate outside of kernels or skeletons of a dataset. For splitting two neighboring clusters, the data points in the neck 
								<ce:cross-ref refid="b0245">[49]</ce:cross-ref> will have a negative effect on the clustering process. To alleviate the effect, we design a pruning step of removing the leaves so that the clusters are analyzed only on the essential data points. In 
								<ce:cross-ref refid="b0245">[49]</ce:cross-ref>, the skeleton of an MST was detected by repeatedly pruning until the number of removed hairs in two successive iterations remains the same. However, this may remove an entire cluster, and therefore, we conservatively perform only one pruning.
								<ce:enunciation id="n0005">
									<ce:label>Definition 1</ce:label>
									<ce:para id="p0490" view="all">Let 
										<ce:italic>X</ce:italic>′ be the pruned version of 
										<ce:italic>X</ce:italic> as in
										<ce:display>
											<ce:formula id="e0005">
												<ce:label>(1)</ce:label>
												<mml:math altimg="si9.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msup>
														<mml:mrow>
															<mml:mi>X</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mo>′</mml:mo>
														</mml:mrow>
													</mml:msup>
													<mml:mo>=</mml:mo>
													<mml:mi>X</mml:mi>
													<mml:mo>⧹</mml:mo>
													<mml:mrow>
														<mml:mfenced open="{" close="}">
															<mml:mrow>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>v</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mo stretchy="false">|</mml:mo>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>v</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mo>∈</mml:mo>
																<mml:mi>V</mml:mi>
																<mml:mtext>,</mml:mtext>
																<mml:mspace width="0.35em"/>
																<mml:mi mathvariant="italic">degree</mml:mi>
																<mml:mo stretchy="false">(</mml:mo>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>v</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mo stretchy="false">)</mml:mo>
																<mml:mo>=</mml:mo>
																<mml:mn>1</mml:mn>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mtext>,</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>where 
										<ce:italic>degree</ce:italic>(
										<ce:italic>v</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>) denotes the degree of vertex 
										<ce:italic>v</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> in the MST of 
										<ce:italic>X</ce:italic>.
									</ce:para>
								</ce:enunciation>
							</ce:para>
						</ce:section>
						<ce:section id="s0035" view="all">
							<ce:label>2.3.2</ce:label>
							<ce:section-title>Constructing a 3-MST graph</ce:section-title>
							<ce:para id="p0060" view="all">An MST describes the intrinsic skeleton of a dataset and accordingly can be used for clustering. In our proposed method, we use it to guide the splitting and merging processes. However, a single MST loses some neighborhood information that is crucial for splitting and merging. To overcome this drawback, we combine several MSTs and form a graph 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>X</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>k</ce:italic>) as follows:
								<ce:enunciation id="n0010">
									<ce:label>Definition 2</ce:label>
									<ce:para id="p0495" view="all">Let 
										<ce:italic>T</ce:italic>
										<ce:inf loc="post">1</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>
										<ce:italic>f</ce:italic>
										<ce:inf loc="post">
											<ce:italic>mst</ce:italic>
										</ce:inf>(
										<ce:italic>V</ce:italic>,
										<ce:hsp sp="0.12"/>
										<ce:italic>E</ce:italic>) denote the MST of 
										<ce:italic>G</ce:italic>(
										<ce:italic>X</ce:italic>)
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>(
										<ce:italic>V</ce:italic>,
										<ce:hsp sp="0.12"/>
										<ce:italic>E</ce:italic>). The following iterations of an MST are defined as:
										<ce:display>
											<ce:formula id="e0010">
												<ce:label>(2)</ce:label>
												<mml:math altimg="si10.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msub>
														<mml:mrow>
															<mml:mi>T</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>=</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>f</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">mst</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mrow>
														<mml:mfenced open="(" close=")">
															<mml:mrow>
																<mml:mi>V</mml:mi>
																<mml:mtext>,</mml:mtext>
																<mml:mspace width="0.12em"/>
																<mml:mi>E</mml:mi>
																<mml:mo>⧹</mml:mo>
																<mml:msubsup>
																	<mml:mrow>
																		<mml:mo>∪</mml:mo>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>j</mml:mi>
																		<mml:mo>=</mml:mo>
																		<mml:mn>1</mml:mn>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																		<mml:mo>-</mml:mo>
																		<mml:mn>1</mml:mn>
																	</mml:mrow>
																</mml:msubsup>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>T</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>j</mml:mi>
																	</mml:mrow>
																</mml:msub>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mtext>,</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>where 
										<ce:italic>f</ce:italic>
										<ce:inf loc="post">
											<ce:italic>mst</ce:italic>
										</ce:inf>: (
										<ce:italic>V</ce:italic>,
										<ce:hsp sp="0.12"/>
										<ce:italic>E</ce:italic>)
										<ce:hsp sp="0.25"/>→
										<ce:hsp sp="0.25"/>
										<ce:italic>T</ce:italic> is a function to compute an MST from graph 
										<ce:italic>G</ce:italic>(
										<ce:italic>X</ce:italic>)
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>(
										<ce:italic>V</ce:italic>,
										<ce:hsp sp="0.12"/>
										<ce:italic>E</ce:italic>), and 
										<ce:italic>i</ce:italic>
										<ce:hsp sp="0.25"/>⩾
										<ce:hsp sp="0.25"/>2.
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0065" view="all">In theory, the above definition of 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf> is not rigorous because 
								<mml:math altimg="si11.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi>E</mml:mi>
										<mml:mo>⧹</mml:mo>
										<mml:msubsup>
											<mml:mrow>
												<mml:mo>∪</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>j</mml:mi>
												<mml:mo>=</mml:mo>
												<mml:mn>1</mml:mn>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
												<mml:mo>-</mml:mo>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>j</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:math> may produce isolated subgraph. For example, if there exists a vertex 
								<ce:italic>v</ce:italic> in 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf> and the degree of 
								<ce:italic>v</ce:italic> is ∣
								<ce:italic>V</ce:italic>∣
								<ce:hsp sp="0.25"/>−
								<ce:hsp sp="0.25"/>1, 
								<ce:italic>v</ce:italic> will be isolated in 
								<ce:italic>G</ce:italic>(
								<ce:italic>V</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>E</ce:italic>⧹
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf>). Hence, the second MST (
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">2</ce:inf>) cannot be completed in terms of 
								<ce:cross-ref refid="n0010">Definition 2</ce:cross-ref>. In practice, this is not a problem because the first MST 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf> is still connected and we can simply ignore it as a minor artefact, because it has no noticeably effect on the performance of the overall algorithm. However, for the sake of completeness, we solve this minor problem by always connecting such an isolated subgraph with an edge randomly selected from those connecting the isolated subgraph in 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf>.
							</ce:para>
							<ce:para id="p0070" view="all">Let 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>X</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>k</ce:italic>) denote the 
								<ce:italic>k</ce:italic>-MST graph, which is defined as a union of the 
								<ce:italic>k</ce:italic> MSTs: 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>X</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>k</ce:italic>)
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf>
								<ce:hsp sp="0.25"/>∪
								<ce:hsp sp="0.25"/>
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">2</ce:inf>∪
								<ce:hsp sp="0.25"/>⋯
								<ce:hsp sp="0.25"/>∪
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">
									<ce:italic>k</ce:italic>
								</ce:inf>. In this paper, we use 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>X</ce:italic>′,
								<ce:hsp sp="0.12"/>
								<ce:italic>k</ce:italic>) to determine the initial prototypes in the split stage and to calculate the merge index of a neighboring partition pair in the merge stage. Here, 
								<ce:italic>k</ce:italic> is set to 3 in terms of the following observation: 1 round of MST is not sufficient for the criterion-based merge but 3 iterations are. The number itself is a small constant and can be justified from computational point of view. Additional iterations do not add much to the quality, but only increase processing time. A further discussion concerning the selection of 
								<ce:italic>k</ce:italic> can be found in Section 
								<ce:cross-ref refid="s0100">3.4</ce:cross-ref>.
							</ce:para>
						</ce:section>
					</ce:section>
					<ce:section id="s0040" view="all">
						<ce:label>2.4</ce:label>
						<ce:section-title>Split stage</ce:section-title>
						<ce:para id="p0075" view="all">In the split stage, initial prototypes are selected as the nodes of highest degree in the graph 
							<ce:italic>G</ce:italic>
							<ce:inf loc="post">
								<ce:italic>mst</ce:italic>
							</ce:inf>(
							<ce:italic>X</ce:italic>′,
							<ce:hsp sp="0.12"/>
							<ce:italic>k</ce:italic>). 
							<ce:italic>K</ce:italic>-means is then applied to the pruned dataset using these prototypes. The produced partitions are adjusted to keep the clusters connected with respect to the MST.
						</ce:para>
						<ce:section id="s0045" view="all">
							<ce:label>2.4.1</ce:label>
							<ce:section-title>Application of 
								<ce:italic>K</ce:italic>-means
							</ce:section-title>
							<ce:para id="p0080" view="all">The pruned dataset is first split by 
								<ce:italic>K</ce:italic>-means in the original Euclidean space, where the number of partitions 
								<ce:italic>K</ce:italic>′ is set to 
								<mml:math altimg="si12.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msqrt>
											<mml:mrow>
												<mml:mo stretchy="false">|</mml:mo>
												<mml:msup>
													<mml:mrow>
														<mml:mi>X</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msup>
												<mml:mo stretchy="false">|</mml:mo>
											</mml:mrow>
										</mml:msqrt>
									</mml:mrow>
								</mml:math>. This is done under the assumption that the number of clusters in a dataset is smaller than the square root of the number of patterns in the dataset 
								<ce:cross-refs refid="b0015 b0180">[3,36]</ce:cross-refs>. If 
								<mml:math altimg="si13.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msqrt>
											<mml:mrow>
												<mml:mo stretchy="false">|</mml:mo>
												<mml:msup>
													<mml:mrow>
														<mml:mi>X</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msup>
												<mml:mo stretchy="false">|</mml:mo>
											</mml:mrow>
										</mml:msqrt>
										<mml:mo>⩽</mml:mo>
										<mml:mi>K</mml:mi>
									</mml:mrow>
								</mml:math>, 
								<ce:italic>K</ce:italic>′ can be set to 
								<ce:italic>K</ce:italic>
								<ce:hsp sp="0.25"/>+
								<ce:hsp sp="0.25"/>
								<ce:italic>λ</ce:italic>(∣
								<ce:italic>X</ce:italic>′ ∣
								<ce:hsp sp="0.25"/>−
								<ce:hsp sp="0.25"/>
								<ce:italic>K</ce:italic>) to grantee that 
								<ce:italic>K</ce:italic>′ is greater than 
								<ce:italic>K</ce:italic>, where 0
								<ce:hsp sp="0.25"/>&lt;
								<ce:hsp sp="0.25"/>
								<ce:italic>λ</ce:italic>
								<ce:hsp sp="0.25"/>&lt;
								<ce:hsp sp="0.25"/>1. Since this is not a normal situation, we do not discuss the parameter 
								<ce:italic>λ</ce:italic> in this paper. Moreover, if ∣
								<ce:italic>X</ce:italic>′ ∣
								<ce:hsp sp="0.25"/>⩽
								<ce:hsp sp="0.25"/>
								<ce:italic>K</ce:italic>, the split-and-merge scheme will degenerate into a traditional agglomerative clustering.
							</ce:para>
							<ce:para id="p0085" view="all">However, to determine the 
								<ce:italic>K</ce:italic>′ initial prototypes is a tough problem, and a random selection would give an unstable splitting result. For example, the method proposed in 
								<ce:cross-ref refid="b0150">[30]</ce:cross-ref> uses 
								<ce:italic>K</ce:italic>-means with randomly selected prototypes in its split stage, and the final clustering results are not unique. We therefore utilize the MST-based graph 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>X</ce:italic>′,
								<ce:hsp sp="0.12"/>3) to avoid this problem.
								<ce:enunciation id="n0015">
									<ce:label>Definition 3</ce:label>
									<ce:para id="p0500" view="all">Let 
										<ce:italic>v</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> be the 
										<ce:italic>i</ce:italic>th prototype from 
										<ce:italic>G</ce:italic>
										<ce:inf loc="post">
											<ce:italic>mst</ce:italic>
										</ce:inf>(
										<ce:italic>X</ce:italic>′,
										<ce:hsp sp="0.12"/>3)
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>(
										<ce:italic>V</ce:italic>,
										<ce:hsp sp="0.12"/>
										<ce:italic>E</ce:italic>), 
										<ce:italic>V</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>−1
										</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>{
										<ce:italic>v</ce:italic>
										<ce:inf loc="post">1</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>v</ce:italic>
										<ce:inf loc="post">2</ce:inf>,
										<ce:hsp sp="0.12"/>…
										<ce:hsp sp="0.12"/>,
										<ce:hsp sp="0.12"/>
										<ce:italic>v</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>−1
										</ce:inf>}, 
										<ce:italic>E</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>−1
										</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>{(
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>)∣(
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>)
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>E</ce:italic>
										<ce:hsp sp="0.25"/>∧
										<ce:hsp sp="0.25"/>(
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>
										<ce:italic>v</ce:italic>
										<ce:hsp sp="0.25"/>∨
										<ce:hsp sp="0.25"/>
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>
										<ce:italic>v</ce:italic>)
										<ce:hsp sp="0.25"/>∧
										<ce:hsp sp="0.25"/>
										<ce:italic>v</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>V</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>−1
										</ce:inf>}, 
										<ce:italic>v</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> is generated as:
										<ce:display>
											<ce:formula id="e0015">
												<ce:label>(3)</ce:label>
												<mml:math altimg="si14.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msub>
														<mml:mrow>
															<mml:mi>v</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>=</mml:mo>
													<mml:mi mathvariant="normal">arg</mml:mi>
													<mml:munder>
														<mml:mrow>
															<mml:mi mathvariant="normal">max</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>v</mml:mi>
															<mml:mo>∈</mml:mo>
															<mml:mi>V</mml:mi>
															<mml:mo>⧹</mml:mo>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>V</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																	<mml:mo>-</mml:mo>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:munder>
													<mml:mi mathvariant="italic">Car</mml:mi>
													<mml:mrow>
														<mml:mfenced open="(" close=")">
															<mml:mrow>
																<mml:mrow>
																	<mml:mfenced open="{" close="}">
																		<mml:mrow>
																			<mml:mrow>
																				<mml:mfenced open="(" close=")">
																					<mml:mrow>
																						<mml:msub>
																							<mml:mrow>
																								<mml:mi mathvariant="bold">x</mml:mi>
																							</mml:mrow>
																							<mml:mrow>
																								<mml:mi>i</mml:mi>
																							</mml:mrow>
																						</mml:msub>
																						<mml:mtext>,</mml:mtext>
																						<mml:msub>
																							<mml:mrow>
																								<mml:mi mathvariant="bold">x</mml:mi>
																							</mml:mrow>
																							<mml:mrow>
																								<mml:mi>j</mml:mi>
																							</mml:mrow>
																						</mml:msub>
																					</mml:mrow>
																				</mml:mfenced>
																			</mml:mrow>
																			<mml:mo stretchy="false">|</mml:mo>
																			<mml:mrow>
																				<mml:mfenced open="(" close=")">
																					<mml:mrow>
																						<mml:msub>
																							<mml:mrow>
																								<mml:mi mathvariant="bold">x</mml:mi>
																							</mml:mrow>
																							<mml:mrow>
																								<mml:mi>i</mml:mi>
																							</mml:mrow>
																						</mml:msub>
																						<mml:mtext>,</mml:mtext>
																						<mml:msub>
																							<mml:mrow>
																								<mml:mi mathvariant="bold">x</mml:mi>
																							</mml:mrow>
																							<mml:mrow>
																								<mml:mi>j</mml:mi>
																							</mml:mrow>
																						</mml:msub>
																					</mml:mrow>
																				</mml:mfenced>
																			</mml:mrow>
																			<mml:mo>∈</mml:mo>
																			<mml:mrow>
																				<mml:mfenced open="(" close=")">
																					<mml:mrow>
																						<mml:mi>E</mml:mi>
																						<mml:mo>⧹</mml:mo>
																						<mml:msub>
																							<mml:mrow>
																								<mml:mi>E</mml:mi>
																							</mml:mrow>
																							<mml:mrow>
																								<mml:mi>i</mml:mi>
																								<mml:mo>-</mml:mo>
																								<mml:mn>1</mml:mn>
																							</mml:mrow>
																						</mml:msub>
																					</mml:mrow>
																				</mml:mfenced>
																			</mml:mrow>
																			<mml:mi>∧</mml:mi>
																			<mml:mrow>
																				<mml:mfenced open="(" close=")">
																					<mml:mrow>
																						<mml:msub>
																							<mml:mrow>
																								<mml:mi mathvariant="bold">x</mml:mi>
																							</mml:mrow>
																							<mml:mrow>
																								<mml:mi>i</mml:mi>
																							</mml:mrow>
																						</mml:msub>
																						<mml:mo>=</mml:mo>
																						<mml:mi>v</mml:mi>
																						<mml:mi>∨</mml:mi>
																						<mml:msub>
																							<mml:mrow>
																								<mml:mi mathvariant="bold">x</mml:mi>
																							</mml:mrow>
																							<mml:mrow>
																								<mml:mi>j</mml:mi>
																							</mml:mrow>
																						</mml:msub>
																						<mml:mo>=</mml:mo>
																						<mml:mi>v</mml:mi>
																					</mml:mrow>
																				</mml:mfenced>
																			</mml:mrow>
																		</mml:mrow>
																	</mml:mfenced>
																</mml:mrow>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mtext>,</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>where 
										<ce:italic>Car</ce:italic>(
										<ce:italic>S</ce:italic>) denotes the cardinality of set 
										<ce:italic>S</ce:italic>.
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0090" view="all">The above definition determines the vertex with the maximum degree as a prototype. It is a recursive definition, when we determine the 
								<ce:italic>i</ce:italic>th prototype 
								<ce:italic>v</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>, the edges connected to the existing 
								<ce:italic>i</ce:italic>
								<ce:hsp sp="0.25"/>−
								<ce:hsp sp="0.25"/>1 prototypes will not be considered for counting the degrees of vertices. However, there may exist two or more vertices in 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>X</ce:italic>′,
								<ce:hsp sp="0.12"/>3) simultaneously having the maximum degree. In this case, the vertex with the minimum sum of weights of its edges is to be selected.
							</ce:para>
							<ce:para id="p0095" view="all">After the 
								<ce:italic>K</ce:italic>′ initial prototypes have been determined, 
								<ce:italic>K</ce:italic>-means is applied. The seven subsets (
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">1</ce:inf>,
								<ce:hsp sp="0.12"/>…
								<ce:hsp sp="0.12"/>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">7</ce:inf>) in stage 2 of 
								<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref> are the partitions on 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf> produced by 
								<ce:italic>K</ce:italic>-means.
							</ce:para>
						</ce:section>
						<ce:section id="s0050" view="all">
							<ce:label>2.4.2</ce:label>
							<ce:section-title>Adjusting partitions</ce:section-title>
							<ce:para id="p0100" view="all">In traditional MST-based clustering methods such as 
								<ce:cross-refs refid="b0235 b0245">[47,49]</ce:cross-refs>, each partition is a subtree of the MST rather than a forest. This is a reasonable observation, because data points in the same cluster are usually in the same branch of the MST. However, the partitions in stage 2 of 
								<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref> may not coincide with the observation. For example, the four subsets (
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">1</ce:inf>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">4</ce:inf>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">6</ce:inf>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">7</ce:inf>) are forests but not trees.
							</ce:para>
							<ce:para id="p0105" view="all">Furthermore, the partitions in stage 2 of 
								<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref> reduce the ability of the MST to guide the merging process. This is because only neighboring partitions will be considered to be merged, and the neighboring partitions can be easily determined by the MST. However, if the partitions are forests, the MST would lose the ability.
							</ce:para>
							<ce:para id="p0110" view="all">Therefore, a process of redistributing the vertices is designed to transform a forest into a tree. The process is described as follows. Suppose that 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf> of 
								<ce:italic>X</ce:italic>′ is partitioned into 
								<ce:italic>K</ce:italic>′ forests, which are denoted as 
								<mml:math altimg="si15.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi>F</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>F</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:mo>…</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>F</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msup>
													<mml:mrow>
														<mml:mi>K</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msup>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:math>. For redistributing the vertices, the main tree in each forest is defined.
								<ce:enunciation id="n0020">
									<ce:label>Definition 4</ce:label>
									<ce:para id="p0505" view="all">Let 
										<ce:italic>F</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>{
										<ce:italic>t</ce:italic>
										<ce:inf loc="post">1</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>t</ce:italic>
										<ce:inf loc="post">2</ce:inf>,
										<ce:hsp sp="0.12"/>…
										<ce:hsp sp="0.12"/>,
										<ce:hsp sp="0.12"/>
										<ce:italic>t</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>…
										<ce:hsp sp="0.12"/>,
										<ce:hsp sp="0.12"/>
										<ce:italic>t</ce:italic>
										<ce:inf loc="post">
											<ce:italic>n</ce:italic>
										</ce:inf>}, and each 
										<ce:italic>t</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf> being a tree. The main tree of 
										<ce:italic>F</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> is defined as:
										<ce:display>
											<ce:formula id="e0020">
												<ce:label>(4)</ce:label>
												<mml:math altimg="si16.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:mi mathvariant="italic">Maintree</mml:mi>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>F</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>=</mml:mo>
													<mml:mi mathvariant="normal">arg</mml:mi>
													<mml:munder>
														<mml:mrow>
															<mml:mi mathvariant="normal">max</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>t</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>j</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>∈</mml:mo>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>F</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:munder>
													<mml:mi mathvariant="italic">Car</mml:mi>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>t</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>j</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mtext>,</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>where 
										<ce:italic>Car</ce:italic>(
										<ce:italic>t</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>) denotes the edge number of the tree 
										<ce:italic>t</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>.
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0115" view="all">The vertices which are not included in any main tree will be re-allocated so that each subset is a subtree of 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf> of 
								<ce:italic>X</ce:italic>′. Suppose 
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">1</ce:inf>,
								<ce:hsp sp="0.12"/>…
								<ce:hsp sp="0.12"/>,
								<ce:hsp sp="0.12"/>
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">7</ce:inf> are the forests of the subsets 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">1</ce:inf>,
								<ce:hsp sp="0.12"/>…
								<ce:hsp sp="0.12"/>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">7</ce:inf> in 
								<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref>, respectively. To adjust the seven subsets into seven subtrees, vertices 
								<ce:italic>v</ce:italic>1 and 
								<ce:italic>v</ce:italic>2 can be re-allocated to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">2</ce:inf>), 
								<ce:italic>v</ce:italic>3 to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">1</ce:inf>), 
								<ce:italic>v</ce:italic>4, 
								<ce:italic>v</ce:italic>5, 
								<ce:italic>v</ce:italic>6 to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">6</ce:inf>), and 
								<ce:italic>v</ce:italic>7 to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">7</ce:inf>). The re-allocation process is described as follows.
							</ce:para>
							<ce:para id="p0120" view="all">Let 
								<ce:italic>SV</ce:italic> denote the set of vertices that are not in any main tree, 
								<ce:italic>ST</ce:italic> the set of the main trees. The redistribution operation is defined as: for an edge 
								<ce:italic>e</ce:italic>
								<ce:inf loc="post">
									<ce:italic>ab</ce:italic>
								</ce:inf> from 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf> of 
								<ce:italic>X</ce:italic>′, if 
								<ce:italic>a</ce:italic>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>SV</ce:italic>, and ∃
								<ce:italic>T</ce:italic>(
								<ce:italic>T</ce:italic>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>ST</ce:italic>
								<ce:hsp sp="0.25"/>∧
								<ce:hsp sp="0.25"/>
								<ce:italic>b</ce:italic>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>T</ce:italic>), then the vertex 
								<ce:italic>a</ce:italic> is redistributed to 
								<ce:italic>T</ce:italic>. For example, 
								<ce:italic>v</ce:italic>2 is re-allocated to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">2</ce:inf>), since 
								<ce:italic>e</ce:italic>
								<ce:inf loc="post">
									<ce:italic>v</ce:italic>2
									<ce:italic>v</ce:italic>8
								</ce:inf>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf>, 
								<ce:italic>v</ce:italic>2
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>SV</ce:italic>, and 
								<ce:italic>v</ce:italic>8
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">2</ce:inf>). We iteratively perform this operation until all of the vertices in 
								<ce:italic>SV</ce:italic> are re-allocated to the main trees.
							</ce:para>
							<ce:para id="p0125" view="all">The above operation may produce non-unique redistributions. Take 
								<ce:italic>v</ce:italic>6 and 
								<ce:italic>v</ce:italic>7 for example, if 
								<ce:italic>e</ce:italic>
								<ce:inf loc="post">
									<ce:italic>v</ce:italic>6
									<ce:italic>v</ce:italic>9
								</ce:inf> and 
								<ce:italic>e</ce:italic>
								<ce:inf loc="post">
									<ce:italic>v</ce:italic>7
									<ce:italic>v</ce:italic>6
								</ce:inf> are considered before 
								<ce:italic>e</ce:italic>
								<ce:inf loc="post">
									<ce:italic>v</ce:italic>7
									<ce:italic>v</ce:italic>10
								</ce:inf>, then 
								<ce:italic>v</ce:italic>6 and 
								<ce:italic>v</ce:italic>7 will be redistributed to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">6</ce:inf>). Similarly, 
								<ce:italic>v</ce:italic>6 and 
								<ce:italic>v</ce:italic>7 may be redistributed to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">7</ce:inf>), or 
								<ce:italic>v</ce:italic>6 to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">6</ce:inf>) and 
								<ce:italic>v</ce:italic>7 to 
								<ce:italic>Maintree</ce:italic>(
								<ce:italic>F</ce:italic>
								<ce:inf loc="post">7</ce:inf>). However, the non-unique redistribution does not noticeably affect the final clustering result for the two reasons: one is that the subtrees in a subset are usually smaller than the main tree of the subset, the other one is that the non-uniqueness most often happens inside rather than between the expected clusters.
							</ce:para>
						</ce:section>
					</ce:section>
					<ce:section id="s0055" view="all">
						<ce:label>2.5</ce:label>
						<ce:section-title>Merge stage</ce:section-title>
						<ce:para id="p0130" view="all">After 
							<ce:italic>X</ce:italic>′ has been split into 
							<ce:italic>K</ce:italic>′ subgroups, the merge stage is performed to obtain the final clusters. In the merging process, the crucial problem is to determine which pairs of subgroups should be merged. By brute force, there are 
							<ce:italic>K</ce:italic>′
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>(
							<ce:italic>K</ce:italic>′
							<ce:hsp sp="0.25"/>−
							<ce:hsp sp="0.25"/>1)/2 candidate pairs for merge. In this paper, a stepwise refinement method is taken to address the problem. At the beginning, 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">1</ce:inf> is employed to filter out the pairs. On the basis of MST-based clustering 
							<ce:cross-refs refid="b0235 b0245">[47,49]</ce:cross-refs>, unconnected subtrees cannot be merged. For example, the subgroups 
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">3</ce:inf> and 
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">7</ce:inf> in 
							<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref> will not be considered as a pair for merge. Consequently, only the neighboring pairs with respect to 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">1</ce:inf> are the candidates.
						</ce:para>
						<ce:section id="s0060" view="all">
							<ce:label>2.5.1</ce:label>
							<ce:section-title>Neighboring pairs</ce:section-title>
							<ce:para id="p0135" view="all">
								<ce:enunciation id="n0025">
									<ce:label>Definition 5</ce:label>
									<ce:para id="p0510" view="all">Let 
										<ce:italic>Pairs</ce:italic> be the set of neighboring pairs from 
										<ce:italic>X</ce:italic>′ as in:
										<ce:display>
											<ce:formula id="e0025">
												<ce:label>(5)</ce:label>
												<mml:math altimg="si17.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:mi mathvariant="italic">Pairs</mml:mi>
													<mml:mo>=</mml:mo>
													<mml:mrow>
														<mml:mfenced open="{" close="}">
															<mml:mrow>
																<mml:mrow>
																	<mml:mfenced open="(" close=")">
																		<mml:mrow>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi>C</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>i</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mtext>,</mml:mtext>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi>C</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>j</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																		</mml:mrow>
																	</mml:mfenced>
																</mml:mrow>
																<mml:mo stretchy="false">|</mml:mo>
																<mml:mo>∃</mml:mo>
																<mml:mrow>
																	<mml:mfenced open="(" close=")">
																		<mml:mrow>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>p</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mtext>,</mml:mtext>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>q</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																		</mml:mrow>
																	</mml:mfenced>
																</mml:mrow>
																<mml:mo>∈</mml:mo>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>T</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mn>1</mml:mn>
																	</mml:mrow>
																</mml:msub>
																<mml:mtext>,</mml:mtext>
																<mml:mspace width="0.12em"/>
																<mml:mrow>
																	<mml:mfenced open="(" close=")">
																		<mml:mrow>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>p</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mo>∈</mml:mo>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi>C</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>i</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mi>∧</mml:mi>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>q</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mo>∈</mml:mo>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi>C</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>j</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																		</mml:mrow>
																	</mml:mfenced>
																</mml:mrow>
																<mml:mi>∨</mml:mi>
																<mml:mrow>
																	<mml:mfenced open="(" close=")">
																		<mml:mrow>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>p</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mo>∈</mml:mo>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi>C</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>j</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mi>∧</mml:mi>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>q</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mo>∈</mml:mo>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi>C</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>i</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																		</mml:mrow>
																	</mml:mfenced>
																</mml:mrow>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mtext>,</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>where 
										<ce:italic>i</ce:italic>
										<ce:hsp sp="0.25"/>≠
										<ce:hsp sp="0.25"/>
										<ce:italic>j</ce:italic>.
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0140" view="all">For any two subgroups, if there exists an edge in 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf> connecting them, then the two subgroups belong to 
								<ce:italic>Pairs</ce:italic>.
							</ce:para>
							<ce:para id="p0145" view="all">For selecting the best pair to be merged, we define an 
								<ce:italic>inter-connectivity index</ce:italic> and an 
								<ce:italic>intra-similarity index</ce:italic> to rank the pairs.
							</ce:para>
						</ce:section>
						<ce:section id="s0065" view="all">
							<ce:label>2.5.2</ce:label>
							<ce:section-title>Inter-connectivity index</ce:section-title>
							<ce:para id="p0150" view="all">
								<ce:enunciation id="n0030">
									<ce:label>Definition 6</ce:label>
									<ce:para id="p0515" view="all">Suppose (
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>)
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>Pairs</ce:italic>. In 
										<ce:italic>G</ce:italic>
										<ce:inf loc="post">
											<ce:italic>mst</ce:italic>
										</ce:inf>(
										<ce:italic>X</ce:italic>′,
										<ce:hsp sp="0.12"/>3), let 
										<ce:italic>E</ce:italic>
										<ce:inf loc="post">
											<ce:italic>inter</ce:italic>
										</ce:inf>(
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>) be the set of edges across the partitions 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> and 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>:
										<ce:display>
											<ce:formula id="e0030">
												<ce:label>(6)</ce:label>
												<mml:math altimg="si18.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msub>
														<mml:mrow>
															<mml:mi>E</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">inter</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mtext>,</mml:mtext>
													<mml:msub>
														<mml:mrow>
															<mml:mi>C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>j</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>=</mml:mo>
													<mml:mo stretchy="false">{</mml:mo>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="bold">x</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>p</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mtext>,</mml:mtext>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="bold">x</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>q</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo stretchy="false">|</mml:mo>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="bold">x</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>p</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>∈</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mi>∧</mml:mi>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="bold">x</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>q</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>∈</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>j</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mi>∨</mml:mi>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="bold">x</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>p</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>∈</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>j</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mi>∧</mml:mi>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="bold">x</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>q</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>∈</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>C</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo stretchy="false">}</mml:mo>
													<mml:mtext>.</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0155" view="all">In 
								<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref>
								<ce:float-anchor refid="f0010"/>, 
								<ce:italic>E</ce:italic>
								<ce:inf loc="post">
									<ce:italic>inter</ce:italic>
								</ce:inf>(
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">6</ce:inf>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">7</ce:inf>)
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>{(
								<ce:italic>a</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>g</ce:italic>), (
								<ce:italic>a</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>h</ce:italic>), (
								<ce:italic>b</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>g</ce:italic>), (
								<ce:italic>c</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>i</ce:italic>), (
								<ce:italic>d</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>i</ce:italic>), (
								<ce:italic>d</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>j</ce:italic>), (
								<ce:italic>e</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>i</ce:italic>), (
								<ce:italic>e</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>j</ce:italic>), (
								<ce:italic>e</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>l</ce:italic>), (
								<ce:italic>e</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>k</ce:italic>)}, i.e. the edges crossing the dotted curve.
								<ce:enunciation id="n0035">
									<ce:label>Definition 7</ce:label>
									<ce:para id="p0520" view="all">Suppose that (
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>)
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>Pairs</ce:italic>. In 
										<ce:italic>G</ce:italic>
										<ce:inf loc="post">
											<ce:italic>mst</ce:italic>
										</ce:inf>(
										<ce:italic>X</ce:italic>′,
										<ce:hsp sp="0.12"/>3), set 
										<ce:italic>V</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>,
											<ce:italic>j</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>=
										<ce:hsp sp="0.25"/>{
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>p</ce:italic>
										</ce:inf>∣(
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>p</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>q</ce:italic>
										</ce:inf>)
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>E</ce:italic>
										<ce:inf loc="post">
											<ce:italic>inter</ce:italic>
										</ce:inf>(
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>)
										<ce:hsp sp="0.25"/>∧
										<ce:hsp sp="0.25"/>
										<ce:bold>x</ce:bold>
										<ce:inf loc="post">
											<ce:italic>p</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>}, 
										<ce:italic>E</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>,
											<ce:italic>j</ce:italic>
										</ce:inf> is a set of edges within 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> where at least one endpoint is in 
										<ce:italic>V</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>,
											<ce:italic>j</ce:italic>
										</ce:inf>:
										<ce:display>
											<ce:formula id="e0035">
												<ce:label>(7)</ce:label>
												<mml:math altimg="si19.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msub>
														<mml:mrow>
															<mml:mi>E</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
															<mml:mtext>,</mml:mtext>
															<mml:mi>j</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>=</mml:mo>
													<mml:mrow>
														<mml:mfenced open="{" close="}">
															<mml:mrow>
																<mml:mrow>
																	<mml:mfenced open="(" close=")">
																		<mml:mrow>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>p</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mtext>,</mml:mtext>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>q</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																		</mml:mrow>
																	</mml:mfenced>
																</mml:mrow>
																<mml:mo stretchy="false">|</mml:mo>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi mathvariant="bold">x</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>p</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mtext>,</mml:mtext>
																<mml:mspace width="0.12em"/>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi mathvariant="bold">x</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>q</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mo>∈</mml:mo>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>C</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mi>∧</mml:mi>
																<mml:mrow>
																	<mml:mfenced open="(" close=")">
																		<mml:mrow>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>p</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mo>∈</mml:mo>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi>V</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>i</mml:mi>
																					<mml:mtext>,</mml:mtext>
																					<mml:mi>j</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mi>∨</mml:mi>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi mathvariant="bold">x</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>q</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																			<mml:mo>∈</mml:mo>
																			<mml:msub>
																				<mml:mrow>
																					<mml:mi>V</mml:mi>
																				</mml:mrow>
																				<mml:mrow>
																					<mml:mi>i</mml:mi>
																					<mml:mtext>,</mml:mtext>
																					<mml:mi>j</mml:mi>
																				</mml:mrow>
																			</mml:msub>
																		</mml:mrow>
																	</mml:mfenced>
																</mml:mrow>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mtext>.</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0160" view="all">In 
								<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref>, for example, 
								<ce:italic>V</ce:italic>
								<ce:inf loc="post">6,7</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>{
								<ce:italic>g</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>h</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>i</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>j</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>k</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>l</ce:italic>}, 
								<ce:italic>V</ce:italic>
								<ce:inf loc="post">7,6</ce:inf>
								<ce:hsp sp="0.25"/>=
								<ce:hsp sp="0.25"/>{
								<ce:italic>a</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>b</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>c</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>d</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>e</ce:italic>}, 
								<ce:italic>E</ce:italic>
								<ce:inf loc="post">6,7</ce:inf> includes all the internal edges of 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">6</ce:inf> (i.e. the edges whose both endpoints are from 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">6</ce:inf>) except {(
								<ce:italic>n</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>m</ce:italic>), (
								<ce:italic>n</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>o</ce:italic>), (
								<ce:italic>n</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>p</ce:italic>), (
								<ce:italic>m</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>o</ce:italic>), (
								<ce:italic>m</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>p</ce:italic>), (
								<ce:italic>m</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>q</ce:italic>), (
								<ce:italic>p</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>o</ce:italic>), (
								<ce:italic>p</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>q</ce:italic>)}, and 
								<ce:italic>E</ce:italic>
								<ce:inf loc="post">7,6</ce:inf> includes all the internal edges of 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">7</ce:inf>. Actually, 
								<ce:italic>E</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>,
									<ce:italic>j</ce:italic>
								</ce:inf> is defined as the edges in the region of 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf> that is close to 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf>.
							</ce:para>
							<ce:para id="p0165" view="all">
								<ce:italic>Connection span</ce:italic> is then defined with respect to 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>X</ce:italic>′,
								<ce:hsp sp="0.12"/>3) as a factor of measuring the similarity of two clusters based on the width of their connection. The intuition behind this index is that it estimates the size of the common border of the two clusters. The larger the common border is, the higher the priority for merging these clusters will be. It depends only on the distances in vector space and makes no assumption on the dimensionality.
								<ce:enunciation id="n0040">
									<ce:label>Definition 8</ce:label>
									<ce:para id="p0525" view="all">Suppose that (
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>)
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>Pairs</ce:italic>. In 
										<ce:italic>G</ce:italic>
										<ce:inf loc="post">
											<ce:italic>mst</ce:italic>
										</ce:inf>(
										<ce:italic>X</ce:italic>′,
										<ce:hsp sp="0.12"/>3), the connection span of 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> with respect to 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf> is:
										<ce:display>
											<ce:formula id="e0040">
												<ce:label>(8)</ce:label>
												<mml:math altimg="si20.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="italic">ConnSpan</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
															<mml:mtext>,</mml:mtext>
															<mml:mi>j</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>=</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mi mathvariant="normal">max</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi mathvariant="bold">x</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>p</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mtext>,</mml:mtext>
															<mml:msub>
																<mml:mrow>
																	<mml:mi mathvariant="bold">x</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>q</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo>∈</mml:mo>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>V</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>i</mml:mi>
																	<mml:mtext>,</mml:mtext>
																	<mml:mi>j</mml:mi>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:munder>
													<mml:mi>w</mml:mi>
													<mml:mrow>
														<mml:mfenced open="(" close=")">
															<mml:mrow>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi mathvariant="bold">x</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>p</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mtext>,</mml:mtext>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi mathvariant="bold">x</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>q</mml:mi>
																	</mml:mrow>
																</mml:msub>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mtext>.</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0170" view="all">In 
								<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>
								<ce:float-anchor refid="f0015"/>, the connection span of 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">6</ce:inf> and 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">7</ce:inf> is marked by the dotted edges (
								<ce:italic>g</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>k</ce:italic>) and (
								<ce:italic>a</ce:italic>,
								<ce:hsp sp="0.12"/>
								<ce:italic>e</ce:italic>), respectively.
								<ce:enunciation id="n0045">
									<ce:label>Definition 9</ce:label>
									<ce:para id="p0530" view="all">Suppose that (
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>)
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>Pairs</ce:italic>. In 
										<ce:italic>G</ce:italic>
										<ce:inf loc="post">
											<ce:italic>mst</ce:italic>
										</ce:inf>(
										<ce:italic>X</ce:italic>′,
										<ce:hsp sp="0.12"/>3), the inter-connectivity (
										<ce:italic>IC</ce:italic>) of 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> and 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf> is defined as:
										<ce:display>
											<ce:formula id="e0045">
												<ce:label>(9)</ce:label>
												<mml:math altimg="si21.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:mi mathvariant="italic">IC</mml:mi>
													<mml:mrow>
														<mml:mfenced open="(" close=")">
															<mml:mrow>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>C</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mtext>,</mml:mtext>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>C</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>j</mml:mi>
																	</mml:mrow>
																</mml:msub>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mo>=</mml:mo>
													<mml:mfrac>
														<mml:mrow>
															<mml:mrow>
																<mml:mfenced open="|" close="|">
																	<mml:mrow>
																		<mml:msub>
																			<mml:mrow>
																				<mml:mi>E</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mi mathvariant="italic">inter</mml:mi>
																			</mml:mrow>
																		</mml:msub>
																		<mml:mrow>
																			<mml:mfenced open="(" close=")">
																				<mml:mrow>
																					<mml:msub>
																						<mml:mrow>
																							<mml:mi>C</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>i</mml:mi>
																						</mml:mrow>
																					</mml:msub>
																					<mml:mtext>,</mml:mtext>
																					<mml:msub>
																						<mml:mrow>
																							<mml:mi>C</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>j</mml:mi>
																						</mml:mrow>
																					</mml:msub>
																				</mml:mrow>
																			</mml:mfenced>
																		</mml:mrow>
																	</mml:mrow>
																</mml:mfenced>
															</mml:mrow>
														</mml:mrow>
														<mml:mrow>
															<mml:mrow>
																<mml:mi mathvariant="normal">min</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mfenced open="(" close=")">
																	<mml:mrow>
																		<mml:mo stretchy="false">|</mml:mo>
																		<mml:msub>
																			<mml:mrow>
																				<mml:mi>C</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mi>i</mml:mi>
																			</mml:mrow>
																		</mml:msub>
																		<mml:mo stretchy="false">|</mml:mo>
																		<mml:mtext>,</mml:mtext>
																		<mml:mo stretchy="false">|</mml:mo>
																		<mml:msub>
																			<mml:mrow>
																				<mml:mi>C</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mi>j</mml:mi>
																			</mml:mrow>
																		</mml:msub>
																		<mml:mo stretchy="false">|</mml:mo>
																	</mml:mrow>
																</mml:mfenced>
															</mml:mrow>
														</mml:mrow>
													</mml:mfrac>
													<mml:mo>×</mml:mo>
													<mml:mfrac>
														<mml:mrow>
															<mml:mrow>
																<mml:mi mathvariant="normal">min</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mfenced open="(" close=")">
																	<mml:mrow>
																		<mml:mi mathvariant="italic">Avg</mml:mi>
																		<mml:mrow>
																			<mml:mfenced open="(" close=")">
																				<mml:mrow>
																					<mml:msub>
																						<mml:mrow>
																							<mml:mi>E</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>i</mml:mi>
																							<mml:mtext>,</mml:mtext>
																							<mml:mi>j</mml:mi>
																						</mml:mrow>
																					</mml:msub>
																				</mml:mrow>
																			</mml:mfenced>
																		</mml:mrow>
																		<mml:mtext>,</mml:mtext>
																		<mml:mi mathvariant="italic">Avg</mml:mi>
																		<mml:mrow>
																			<mml:mfenced open="(" close=")">
																				<mml:mrow>
																					<mml:msub>
																						<mml:mrow>
																							<mml:mi>E</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>j</mml:mi>
																							<mml:mtext>,</mml:mtext>
																							<mml:mi>i</mml:mi>
																						</mml:mrow>
																					</mml:msub>
																				</mml:mrow>
																			</mml:mfenced>
																		</mml:mrow>
																	</mml:mrow>
																</mml:mfenced>
															</mml:mrow>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">Avg</mml:mi>
															<mml:mrow>
																<mml:mfenced open="(" close=")">
																	<mml:mrow>
																		<mml:msub>
																			<mml:mrow>
																				<mml:mi>E</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mi mathvariant="italic">inter</mml:mi>
																			</mml:mrow>
																		</mml:msub>
																		<mml:mrow>
																			<mml:mfenced open="(" close=")">
																				<mml:mrow>
																					<mml:msub>
																						<mml:mrow>
																							<mml:mi>C</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>i</mml:mi>
																						</mml:mrow>
																					</mml:msub>
																					<mml:mtext>,</mml:mtext>
																					<mml:msub>
																						<mml:mrow>
																							<mml:mi>C</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>j</mml:mi>
																						</mml:mrow>
																					</mml:msub>
																				</mml:mrow>
																			</mml:mfenced>
																		</mml:mrow>
																	</mml:mrow>
																</mml:mfenced>
															</mml:mrow>
														</mml:mrow>
													</mml:mfrac>
													<mml:mo>×</mml:mo>
													<mml:mrow>
														<mml:mi mathvariant="normal">max</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mfenced open="(" close=")">
															<mml:mrow>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi mathvariant="italic">ConnSpan</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																		<mml:mtext>,</mml:mtext>
																		<mml:mi>j</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mtext>,</mml:mtext>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi mathvariant="italic">ConnSpan</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mo stretchy="false">(</mml:mo>
																	</mml:mrow>
																</mml:msub>
																<mml:mi>j</mml:mi>
																<mml:mtext>,</mml:mtext>
																<mml:mi>i</mml:mi>
																<mml:mo stretchy="false">)</mml:mo>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mtext>,</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>where 
										<ce:italic>Avg</ce:italic>(
										<ce:italic>E</ce:italic>) denotes the average weight of an edge set 
										<ce:italic>E</ce:italic>.
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0175" view="all">From Eq. 
								<ce:cross-ref refid="e0045">(9)</ce:cross-ref>, the inter-connectivity index 
								<ce:italic>IC</ce:italic> is a composite of three factors. The factor ∣
								<ce:italic>E</ce:italic>
								<ce:inf loc="post">
									<ce:italic>inter</ce:italic>
								</ce:inf>(
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf>)∣/min(∣
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>∣,
								<ce:hsp sp="0.12"/>∣
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf>∣) describes that the more edges straddling a pair of clusters, the stronger is the connective strength between the two clusters. In the second factor, min (
								<ce:italic>Avg</ce:italic>(
								<ce:italic>E</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>,
									<ce:italic>j</ce:italic>
								</ce:inf>),
								<ce:hsp sp="0.12"/>
								<ce:italic>Avg</ce:italic>(
								<ce:italic>E</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>,
									<ce:italic>i</ce:italic>
								</ce:inf>)) is the minimum of the average weights of the edges that are in the two close regions from 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf> and 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf>, respectively. 
								<ce:italic>Avg</ce:italic>(
								<ce:italic>E</ce:italic>
								<ce:inf loc="post">
									<ce:italic>inter</ce:italic>
								</ce:inf>(
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf>)) is the average weight of the edges straddling 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf> and 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf>. This factor reflects that the ratio of the average weight of the straddling edges to the minimum average weight in the two close regions is inversely proportional to the connectivity of the two clusters. In fact, this is based on the observation that if the density between the two clusters is low compared with those of the close regions, the two clusters have a small probability to be merged. The third factor max (
								<ce:italic>ConnSpan</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>,
									<ce:italic>j</ce:italic>
								</ce:inf>,
								<ce:hsp sp="0.12"/>
								<ce:italic>ConnSpan</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>,
									<ce:italic>i</ce:italic>
								</ce:inf>) indicates that a pair of clusters with large connection span has strong connectivity.
							</ce:para>
						</ce:section>
						<ce:section id="s0070" view="all">
							<ce:label>2.5.3</ce:label>
							<ce:section-title>Intra-similarity index</ce:section-title>
							<ce:para id="p0180" view="all">For describing the intra-similarity of pairs of clusters, a strategy inspired by Karypis et al. 
								<ce:cross-ref refid="b0115">[23]</ce:cross-ref> is employed. Each cluster of a neighboring pair is bisected in terms of 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf>, and the corresponding inter-edges with respect to 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>X</ce:italic>′,
								<ce:hsp sp="0.12"/>3) are used to evaluate the intra-similarity between the two clusters. The process is described as follows.
							</ce:para>
							<ce:para id="p0185" view="all">Suppose 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf> is the cluster to be bisected, and 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>1
								</ce:inf> is the subtree of 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">1</ce:inf> restricted to nodes and edges of 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>. The bisecting edge 
								<ce:italic>e</ce:italic>
								<ce:inf loc="post">
									<ce:italic>bisect</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>1
								</ce:inf> can be determined as:
								<ce:display>
									<ce:formula id="e0050">
										<ce:label>(10)</ce:label>
										<mml:math altimg="si22.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:msub>
												<mml:mrow>
													<mml:mi>e</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi mathvariant="italic">bisect</mml:mi>
												</mml:mrow>
											</mml:msub>
											<mml:mo>=</mml:mo>
											<mml:mi mathvariant="normal">arg</mml:mi>
											<mml:munder>
												<mml:mrow>
													<mml:mi mathvariant="normal">min</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:msub>
														<mml:mrow>
															<mml:mi>e</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>j</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>∈</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>T</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>i</mml:mi>
															<mml:mn>1</mml:mn>
														</mml:mrow>
													</mml:msub>
												</mml:mrow>
											</mml:munder>
											<mml:mrow>
												<mml:mfenced open="|" close="|">
													<mml:mrow>
														<mml:mi mathvariant="italic">Car</mml:mi>
														<mml:mrow>
															<mml:mfenced open="(" close=")">
																<mml:mrow>
																	<mml:msub>
																		<mml:mrow>
																			<mml:mi>t</mml:mi>
																		</mml:mrow>
																		<mml:mrow>
																			<mml:mi>j</mml:mi>
																			<mml:mn>1</mml:mn>
																		</mml:mrow>
																	</mml:msub>
																</mml:mrow>
															</mml:mfenced>
														</mml:mrow>
														<mml:mo>-</mml:mo>
														<mml:mi mathvariant="italic">Car</mml:mi>
														<mml:mrow>
															<mml:mfenced open="(" close=")">
																<mml:mrow>
																	<mml:msub>
																		<mml:mrow>
																			<mml:mi>t</mml:mi>
																		</mml:mrow>
																		<mml:mrow>
																			<mml:mi>j</mml:mi>
																			<mml:mn>2</mml:mn>
																		</mml:mrow>
																	</mml:msub>
																</mml:mrow>
															</mml:mfenced>
														</mml:mrow>
													</mml:mrow>
												</mml:mfenced>
											</mml:mrow>
											<mml:mtext>,</mml:mtext>
										</mml:math>
									</ce:formula>
								</ce:display>where 
								<ce:italic>t</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>1
								</ce:inf> and 
								<ce:italic>t</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>2
								</ce:inf> are two subtrees of 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>1
								</ce:inf> generated by removing 
								<ce:italic>e</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf> from 
								<ce:italic>T</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>1
								</ce:inf>, and 
								<ce:italic>Car</ce:italic>(
								<ce:italic>t</ce:italic>) denotes the number of edges in a tree 
								<ce:italic>t</ce:italic>. An example of the bisection is shown in 
								<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>
								<ce:float-anchor refid="f0020"/>. Correspondingly, 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf> is bisected into two subsets: 
								<mml:math altimg="si23.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math> and 
								<mml:math altimg="si24.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msubsup>
									</mml:mrow>
								</mml:math>. The inter-edge set 
								<mml:math altimg="si25.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi>E</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">inter</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:mtext>,</mml:mtext>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> with respect to 
								<ce:italic>G</ce:italic>
								<ce:inf loc="post">
									<ce:italic>mst</ce:italic>
								</ce:inf>(
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>,
								<ce:hsp sp="0.12"/>3) is obtained by 
								<ce:cross-ref refid="n0030">Definition 6</ce:cross-ref>. The intra-similarity of 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf> and 
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf> is then defined as follows:
								<ce:enunciation id="n0050">
									<ce:label>Definition 10</ce:label>
									<ce:para id="p0535" view="all">Suppose that (
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>)
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>Pairs</ce:italic>, 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf> is bisected into 
										<mml:math altimg="si26.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> and 
										<mml:math altimg="si27.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math>, 
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf> is bisected into 
										<mml:math altimg="si28.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math> and 
										<mml:math altimg="si29.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:msubsup>
											</mml:mrow>
										</mml:math>, the 
										<ce:italic>intra-similarity</ce:italic> (
										<ce:italic>IS</ce:italic>) of the pair (
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>i</ce:italic>
										</ce:inf>,
										<ce:hsp sp="0.12"/>
										<ce:italic>C</ce:italic>
										<ce:inf loc="post">
											<ce:italic>j</ce:italic>
										</ce:inf>) is defined as:
										<ce:display>
											<ce:formula id="e0055">
												<ce:label>(11)</ce:label>
												<mml:math altimg="si30.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:mi mathvariant="italic">IS</mml:mi>
													<mml:mrow>
														<mml:mfenced open="(" close=")">
															<mml:mrow>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>C</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>i</mml:mi>
																	</mml:mrow>
																</mml:msub>
																<mml:mtext>,</mml:mtext>
																<mml:msub>
																	<mml:mrow>
																		<mml:mi>C</mml:mi>
																	</mml:mrow>
																	<mml:mrow>
																		<mml:mi>j</mml:mi>
																	</mml:mrow>
																</mml:msub>
															</mml:mrow>
														</mml:mfenced>
													</mml:mrow>
													<mml:mo>=</mml:mo>
													<mml:mfrac>
														<mml:mrow>
															<mml:mn>1</mml:mn>
														</mml:mrow>
														<mml:mrow>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>r</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>1</mml:mn>
																</mml:mrow>
															</mml:msub>
															<mml:mo>×</mml:mo>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>r</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mn>2</mml:mn>
																</mml:mrow>
															</mml:msub>
														</mml:mrow>
													</mml:mfrac>
													<mml:mo>×</mml:mo>
													<mml:mfrac>
														<mml:mrow>
															<mml:msqrt>
																<mml:mrow>
																	<mml:mi mathvariant="italic">Avg</mml:mi>
																	<mml:mrow>
																		<mml:mfenced open="(" close=")">
																			<mml:mrow>
																				<mml:msub>
																					<mml:mrow>
																						<mml:mi>E</mml:mi>
																					</mml:mrow>
																					<mml:mrow>
																						<mml:mi mathvariant="italic">inter</mml:mi>
																					</mml:mrow>
																				</mml:msub>
																				<mml:mrow>
																					<mml:mfenced open="(" close=")">
																						<mml:mrow>
																							<mml:msubsup>
																								<mml:mrow>
																									<mml:mi>C</mml:mi>
																								</mml:mrow>
																								<mml:mrow>
																									<mml:mi>i</mml:mi>
																								</mml:mrow>
																								<mml:mrow>
																									<mml:mn>1</mml:mn>
																								</mml:mrow>
																							</mml:msubsup>
																							<mml:mtext>,</mml:mtext>
																							<mml:msubsup>
																								<mml:mrow>
																									<mml:mi>C</mml:mi>
																								</mml:mrow>
																								<mml:mrow>
																									<mml:mi>i</mml:mi>
																								</mml:mrow>
																								<mml:mrow>
																									<mml:mn>2</mml:mn>
																								</mml:mrow>
																							</mml:msubsup>
																						</mml:mrow>
																					</mml:mfenced>
																				</mml:mrow>
																			</mml:mrow>
																		</mml:mfenced>
																	</mml:mrow>
																	<mml:mo>×</mml:mo>
																	<mml:mi mathvariant="italic">Avg</mml:mi>
																	<mml:mrow>
																		<mml:mfenced open="(" close=")">
																			<mml:mrow>
																				<mml:msub>
																					<mml:mrow>
																						<mml:mi>E</mml:mi>
																					</mml:mrow>
																					<mml:mrow>
																						<mml:mi mathvariant="italic">inter</mml:mi>
																					</mml:mrow>
																				</mml:msub>
																				<mml:mrow>
																					<mml:mfenced open="(" close=")">
																						<mml:mrow>
																							<mml:msubsup>
																								<mml:mrow>
																									<mml:mi>C</mml:mi>
																								</mml:mrow>
																								<mml:mrow>
																									<mml:mi>j</mml:mi>
																								</mml:mrow>
																								<mml:mrow>
																									<mml:mn>1</mml:mn>
																								</mml:mrow>
																							</mml:msubsup>
																							<mml:mtext>,</mml:mtext>
																							<mml:msubsup>
																								<mml:mrow>
																									<mml:mi>C</mml:mi>
																								</mml:mrow>
																								<mml:mrow>
																									<mml:mi>j</mml:mi>
																								</mml:mrow>
																								<mml:mrow>
																									<mml:mn>2</mml:mn>
																								</mml:mrow>
																							</mml:msubsup>
																						</mml:mrow>
																					</mml:mfenced>
																				</mml:mrow>
																			</mml:mrow>
																		</mml:mfenced>
																	</mml:mrow>
																</mml:mrow>
															</mml:msqrt>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">Avg</mml:mi>
															<mml:mrow>
																<mml:mfenced open="(" close=")">
																	<mml:mrow>
																		<mml:msub>
																			<mml:mrow>
																				<mml:mi>E</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mi mathvariant="italic">inter</mml:mi>
																			</mml:mrow>
																		</mml:msub>
																		<mml:mrow>
																			<mml:mfenced open="(" close=")">
																				<mml:mrow>
																					<mml:msubsup>
																						<mml:mrow>
																							<mml:mi>C</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>i</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mn>1</mml:mn>
																						</mml:mrow>
																					</mml:msubsup>
																					<mml:mtext>,</mml:mtext>
																					<mml:msubsup>
																						<mml:mrow>
																							<mml:mi>C</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>i</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mn>2</mml:mn>
																						</mml:mrow>
																					</mml:msubsup>
																				</mml:mrow>
																			</mml:mfenced>
																		</mml:mrow>
																	</mml:mrow>
																</mml:mfenced>
															</mml:mrow>
															<mml:mo>+</mml:mo>
															<mml:mi mathvariant="italic">Avg</mml:mi>
															<mml:mrow>
																<mml:mfenced open="(" close=")">
																	<mml:mrow>
																		<mml:msub>
																			<mml:mrow>
																				<mml:mi>E</mml:mi>
																			</mml:mrow>
																			<mml:mrow>
																				<mml:mi mathvariant="italic">inter</mml:mi>
																			</mml:mrow>
																		</mml:msub>
																		<mml:mrow>
																			<mml:mfenced open="(" close=")">
																				<mml:mrow>
																					<mml:msubsup>
																						<mml:mrow>
																							<mml:mi>C</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>j</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mn>1</mml:mn>
																						</mml:mrow>
																					</mml:msubsup>
																					<mml:mtext>,</mml:mtext>
																					<mml:msubsup>
																						<mml:mrow>
																							<mml:mi>C</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mi>j</mml:mi>
																						</mml:mrow>
																						<mml:mrow>
																							<mml:mn>2</mml:mn>
																						</mml:mrow>
																					</mml:msubsup>
																				</mml:mrow>
																			</mml:mfenced>
																		</mml:mrow>
																	</mml:mrow>
																</mml:mfenced>
															</mml:mrow>
														</mml:mrow>
													</mml:mfrac>
													<mml:mtext>,</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>where 
										<ce:italic>r</ce:italic>
										<ce:inf loc="post">1</ce:inf> and 
										<ce:italic>r</ce:italic>
										<ce:inf loc="post">2</ce:inf> are the numbers of edges of 
										<mml:math altimg="si31.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>E</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">inter</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msubsup>
												<mml:mtext>,</mml:mtext>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:msubsup>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:math> and 
										<mml:math altimg="si32.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>E</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">inter</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>1</mml:mn>
													</mml:mrow>
												</mml:msubsup>
												<mml:mtext>,</mml:mtext>
												<mml:msubsup>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mn>2</mml:mn>
													</mml:mrow>
												</mml:msubsup>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:math>, respectively, and 
										<ce:italic>Avg</ce:italic>(
										<ce:italic>E</ce:italic>) denotes the average weight of an edge set 
										<ce:italic>E</ce:italic>.
									</ce:para>
								</ce:enunciation>
							</ce:para>
							<ce:para id="p0190" view="all">Eq. 
								<ce:cross-ref refid="e0055">(11)</ce:cross-ref> implies that the intra-similarity between the pair (
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>,
								<ce:hsp sp="0.12"/>
								<ce:italic>C</ce:italic>
								<ce:inf loc="post">
									<ce:italic>j</ce:italic>
								</ce:inf>) is high when the two averages 
								<mml:math altimg="si33.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">Avg</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>E</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">inter</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:mtext>,</mml:mtext>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>i</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> and 
								<mml:math altimg="si34.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">Avg</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>E</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">inter</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>j</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>1</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:mtext>,</mml:mtext>
										<mml:msubsup>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>j</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mn>2</mml:mn>
											</mml:mrow>
										</mml:msubsup>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> are close to each other. For the two numbers 
								<ce:italic>r</ce:italic>
								<ce:inf loc="post">1</ce:inf> and 
								<ce:italic>r</ce:italic>
								<ce:inf loc="post">2</ce:inf>, unbalanced and small sizes indicate that the two clusters are more likely to be merged.
							</ce:para>
							<ce:para id="p0195" view="all">Taking into account the inter-connectivity and the intra-similarity as a whole, we define the overall merge index as:
								<ce:display>
									<ce:formula id="e0060">
										<ce:label>(12)</ce:label>
										<mml:math altimg="si35.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mi>R</mml:mi>
											<mml:mrow>
												<mml:mfenced open="(" close=")">
													<mml:mrow>
														<mml:msub>
															<mml:mrow>
																<mml:mi>C</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mi>i</mml:mi>
															</mml:mrow>
														</mml:msub>
														<mml:mtext>,</mml:mtext>
														<mml:msub>
															<mml:mrow>
																<mml:mi>C</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mi>j</mml:mi>
															</mml:mrow>
														</mml:msub>
													</mml:mrow>
												</mml:mfenced>
											</mml:mrow>
											<mml:mo>=</mml:mo>
											<mml:mi mathvariant="italic">IC</mml:mi>
											<mml:mrow>
												<mml:mfenced open="(" close=")">
													<mml:mrow>
														<mml:msub>
															<mml:mrow>
																<mml:mi>C</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mi>i</mml:mi>
															</mml:mrow>
														</mml:msub>
														<mml:mtext>,</mml:mtext>
														<mml:msub>
															<mml:mrow>
																<mml:mi>C</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mi>j</mml:mi>
															</mml:mrow>
														</mml:msub>
													</mml:mrow>
												</mml:mfenced>
											</mml:mrow>
											<mml:mo>×</mml:mo>
											<mml:mi mathvariant="italic">IS</mml:mi>
											<mml:mrow>
												<mml:mfenced open="(" close=")">
													<mml:mrow>
														<mml:msub>
															<mml:mrow>
																<mml:mi>C</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mi>i</mml:mi>
															</mml:mrow>
														</mml:msub>
														<mml:mtext>,</mml:mtext>
														<mml:msub>
															<mml:mrow>
																<mml:mi>C</mml:mi>
															</mml:mrow>
															<mml:mrow>
																<mml:mi>j</mml:mi>
															</mml:mrow>
														</mml:msub>
													</mml:mrow>
												</mml:mfenced>
											</mml:mrow>
											<mml:mtext>.</mml:mtext>
										</mml:math>
									</ce:formula>
								</ce:display>The neighboring pair with the highest 
								<ce:italic>R</ce:italic>() value is merged first. After one neighboring pair is merged, 
								<ce:italic>Pairs</ce:italic> and corresponding 
								<ce:italic>R</ce:italic>() values are updated. When 
								<ce:italic>K</ce:italic> partitions are achieved, the merge process stops. Because a pruned leaf ∈
								<ce:italic>X</ce:italic> is connected to exact one vertex 
								<ce:bold>x</ce:bold>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>∈
								<ce:hsp sp="0.25"/>
								<ce:italic>X</ce:italic>′ in the MST of 
								<ce:italic>X</ce:italic>, it is assigned the same label as 
								<ce:bold>x</ce:bold>
								<ce:inf loc="post">
									<ce:italic>i</ce:italic>
								</ce:inf>.
							</ce:para>
							<ce:para id="p0200" view="all">Finally, the proposed algorithm is described as follows:
								<ce:display>
									<ce:table frame="topbot" id="t0035" rowsep="0" colsep="0">
										<cals:tgroup cols="1" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
											<cals:colspec colname="col1" align="left"/>
											<cals:thead>
												<cals:row rowsep="1" valign="top">
													<ce:entry>
														<ce:bold>Algorithm 1:</ce:bold> Split-and-merge (SAM)
													</ce:entry>
												</cals:row>
											</cals:thead>
											<cals:tbody>
												<cals:row valign="top">
													<ce:entry>
														<ce:bold>Input:</ce:bold> Dataset 
														<ce:italic>X</ce:italic>, number of clusters 
														<ce:italic>K</ce:italic>
													</ce:entry>
												</cals:row>
												<cals:row valign="top">
													<ce:entry>
														<ce:bold>Output:</ce:bold>
														<ce:italic>K</ce:italic> clusters 
														<ce:italic>C</ce:italic>
														<ce:inf loc="post">1</ce:inf>, 
														<ce:italic>C</ce:italic>
														<ce:inf loc="post">2</ce:inf>,
														<ce:hsp sp="0.12"/>…
														<ce:hsp sp="0.12"/>,
														<ce:hsp sp="0.12"/>
														<ce:italic>C</ce:italic>
														<ce:inf loc="post">
															<ce:italic>K</ce:italic>
														</ce:inf>
													</ce:entry>
												</cals:row>
												<cals:row valign="top">
													<ce:entry>
														<ce:list id="l0005">
															<ce:list-item id="o0005">
																<ce:label>1.</ce:label>
																<ce:para id="p0350" view="all">Construct 3-MST graph
																	<ce:list id="l0025">
																		<ce:list-item id="o0085">
																			<ce:label>1.1</ce:label>
																			<ce:para id="p0430" view="all">Construct an MST on 
																				<ce:italic>X</ce:italic>
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0090">
																			<ce:label>1.2</ce:label>
																			<ce:para id="p0435" view="all">Produce 
																				<ce:italic>X</ce:italic>′ by pruning the leaves of the MST
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0095">
																			<ce:label>1.3</ce:label>
																			<ce:para id="p0440" view="all">Create three MSTs on 
																				<ce:italic>X</ce:italic>′: 
																				<ce:italic>T</ce:italic>
																				<ce:inf loc="post">1</ce:inf>, 
																				<ce:italic>T</ce:italic>
																				<ce:inf loc="post">2</ce:inf> and 
																				<ce:italic>T</ce:italic>
																				<ce:inf loc="post">3</ce:inf>
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0100">
																			<ce:label>1.4</ce:label>
																			<ce:para id="p0445" view="all">Compute 3-MST graph based on 
																				<ce:italic>X</ce:italic>′: 
																				<ce:italic>G</ce:italic>
																				<ce:inf loc="post">
																					<ce:italic>mst</ce:italic>
																				</ce:inf>(
																				<ce:italic>X</ce:italic>′,
																				<ce:hsp sp="0.12"/>3)
																				<ce:hsp sp="0.25"/>←
																				<ce:hsp sp="0.25"/>
																				<ce:italic>T</ce:italic>
																				<ce:inf loc="post">1</ce:inf>
																				<ce:hsp sp="0.25"/>∪
																				<ce:hsp sp="0.25"/>
																				<ce:italic>T</ce:italic>
																				<ce:inf loc="post">2</ce:inf>
																				<ce:hsp sp="0.25"/>∪
																				<ce:hsp sp="0.25"/>
																				<ce:italic>T</ce:italic>
																				<ce:inf loc="post">3</ce:inf>
																			</ce:para>
																		</ce:list-item>
																	</ce:list>
																</ce:para>
															</ce:list-item>
															<ce:list-item id="o0010">
																<ce:label>2.</ce:label>
																<ce:para id="p0355" view="all">Split the pruned dataset 
																	<ce:italic>X</ce:italic>′ into clusters
																	<ce:list id="l0030">
																		<ce:list-item id="o0105">
																			<ce:label>2.1</ce:label>
																			<ce:para id="p0450" view="all">Select 
																				<ce:italic>K</ce:italic>′ highest degree nodes from 
																				<ce:italic>G</ce:italic>
																				<ce:inf loc="post">
																					<ce:italic>mst</ce:italic>
																				</ce:inf>(
																				<ce:italic>X</ce:italic>′,
																				<ce:hsp sp="0.12"/>3) as initial prototypes
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0110">
																			<ce:label>2.2</ce:label>
																			<ce:para id="p0455" view="all">Apply 
																				<ce:italic>K</ce:italic>-means with the prototypes to produce 
																				<ce:italic>K</ce:italic>′ partitions
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0115">
																			<ce:label>2.3</ce:label>
																			<ce:para id="p0460" view="all">For each of the partitions, find its main tree in 
																				<ce:italic>T</ce:italic>
																				<ce:inf loc="post">1</ce:inf>
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0120">
																			<ce:label>2.4</ce:label>
																			<ce:para id="p0465" view="all">For each of the subtrees, repeatedly combine it with another subtree until it belongs to a main tree</ce:para>
																		</ce:list-item>
																	</ce:list>
																</ce:para>
															</ce:list-item>
															<ce:list-item id="o0015">
																<ce:label>3.</ce:label>
																<ce:para id="p0360" view="all">Merge the partitions into final clusters
																	<ce:list id="l0035">
																		<ce:list-item id="o0125">
																			<ce:label>3.1</ce:label>
																			<ce:para id="p0470" view="all">Generate the set of neighboring partition pairs 
																				<ce:italic>Pairs</ce:italic>
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0130">
																			<ce:label>3.2</ce:label>
																			<ce:para id="p0475" view="all">For each pair (
																				<ce:italic>C</ce:italic>
																				<ce:inf loc="post">
																					<ce:italic>i</ce:italic>
																				</ce:inf>,
																				<ce:hsp sp="0.12"/>
																				<ce:italic>C</ce:italic>
																				<ce:inf loc="post">
																					<ce:italic>j</ce:italic>
																				</ce:inf>)
																				<ce:hsp sp="0.25"/>∈
																				<ce:hsp sp="0.25"/>
																				<ce:italic>Pairs</ce:italic>, calculate the merge criterion 
																				<ce:italic>R</ce:italic>(
																				<ce:italic>C</ce:italic>
																				<ce:inf loc="post">
																					<ce:italic>i</ce:italic>
																				</ce:inf>,
																				<ce:hsp sp="0.12"/>
																				<ce:italic>C</ce:italic>
																				<ce:inf loc="post">
																					<ce:italic>j</ce:italic>
																				</ce:inf>)
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0135">
																			<ce:label>3.3</ce:label>
																			<ce:para id="p0480" view="all">Repeatedly merge the pair with maximum 
																				<ce:italic>R</ce:italic>()-value until 
																				<ce:italic>K</ce:italic> clusters have been obtained
																			</ce:para>
																		</ce:list-item>
																		<ce:list-item id="o0140">
																			<ce:label>3.4</ce:label>
																			<ce:para id="p0485" view="all">Add the pruned leaves to the clustering using 
																				<ce:italic>T</ce:italic>
																				<ce:inf loc="post">1</ce:inf>
																			</ce:para>
																		</ce:list-item>
																	</ce:list>
																</ce:para>
															</ce:list-item>
														</ce:list>
													</ce:entry>
												</cals:row>
											</cals:tbody>
										</cals:tgroup>
									</ce:table>
								</ce:display>
							</ce:para>
						</ce:section>
					</ce:section>
					<ce:section id="s0075" view="all">
						<ce:label>2.6</ce:label>
						<ce:section-title>Computational complexity</ce:section-title>
						<ce:para id="p0205" view="all">To construct an MST, if Fibonacci heaps are employed in Prim’s algorithm, the running time is 
							<ce:italic>O</ce:italic>(∣
							<ce:italic>E</ce:italic>∣
							<ce:hsp sp="0.25"/>+
							<ce:hsp sp="0.25"/>∣
							<ce:italic>V</ce:italic>∣log∣
							<ce:italic>V</ce:italic>∣) 
							<ce:cross-ref refid="b0045">[9]</ce:cross-ref>. In this paper, an MST is computed from a complete graph, ∣
							<ce:italic>E</ce:italic>∣
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>O</ce:italic>(∣
							<ce:italic>V</ce:italic>∣
							<ce:sup loc="post">2</ce:sup>)
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>
							<ce:sup loc="post">2</ce:sup>), and therefore, the complexity of constructing an MST is 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>
							<ce:sup loc="post">2</ce:sup>).
						</ce:para>
						<ce:para id="p0210" view="all">In Step 1.1, the MST is constructed in 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>
							<ce:sup loc="post">2</ce:sup>) time, and in Step 1.2, the complexity of pruning the leaves from the MST is 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>). In Step 1.3, to generate the three MSTs of 
							<ce:italic>X</ce:italic>′ takes 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>
							<ce:sup loc="post">2</ce:sup>) time. 
							<ce:italic>G</ce:italic>
							<ce:inf loc="post">
								<ce:italic>mst</ce:italic>
							</ce:inf>(
							<ce:italic>X</ce:italic>′,
							<ce:hsp sp="0.12"/>3) is obtained in 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>) time in Step 1.4. In Step 2.1, the initial prototypes are determined in 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>), the time complexity of 
							<ce:italic>K</ce:italic>-means on 
							<ce:italic>X</ce:italic>′ is 
							<ce:italic>O</ce:italic>(
							<ce:italic>K</ce:italic>′
							<ce:hsp sp="0.12"/>
							<ce:italic>NdI</ce:italic>), where 
							<ce:italic>d</ce:italic> is the dimensionality of 
							<ce:italic>X</ce:italic>′, and 
							<ce:italic>I</ce:italic> is the number of iterations. Since 
							<mml:math altimg="si36.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msup>
										<mml:mrow>
											<mml:mi>K</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mo>′</mml:mo>
										</mml:mrow>
									</mml:msup>
									<mml:mo>⩽</mml:mo>
									<mml:msqrt>
										<mml:mrow>
											<mml:mi>N</mml:mi>
										</mml:mrow>
									</mml:msqrt>
								</mml:mrow>
							</mml:math>, the total complexity of Step 2.1 is 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>
							<ce:sup loc="post">3/2</ce:sup>
							<ce:italic>dI</ce:italic>). The main trees can be determined in 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>) in Step 2.2, and re-allocation can also be achieved in 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>) in Step 2.3. Step 3.1 takes 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>) to generate 
							<ce:italic>Pairs</ce:italic>, and Step 3.2 takes 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>) to compute the merge index 
							<ce:italic>R</ce:italic>() for every pair in 
							<ce:italic>Pairs</ce:italic>. As the merging of a pair can be achieved in constant time, the maximum complexity of updating the merge index 
							<ce:italic>R</ce:italic>() is 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>), and the number of iterations of Step 3.3 is 
							<mml:math altimg="si37.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mi>O</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msqrt>
										<mml:mrow>
											<mml:mi>N</mml:mi>
										</mml:mrow>
									</mml:msqrt>
									<mml:mo stretchy="false">)</mml:mo>
								</mml:mrow>
							</mml:math>, the worst case complexity of this Step is therefore 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>
							<ce:sup loc="post">3/2</ce:sup>). Step 3.4 can be processed in constant time.
						</ce:para>
						<ce:para id="p0215" view="all">To sum up, the computational complexity of the proposed method (SAM) is 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>
							<ce:sup loc="post">2</ce:sup>), which is dominated by the construction of the 3-MST graph. If also the factor of dimensionality 
							<ce:italic>d</ce:italic> is considered, the exact complexity would be 
							<ce:italic>O</ce:italic>(
							<ce:italic>N</ce:italic>
							<ce:sup loc="post">2</ce:sup>
							<ce:italic>d</ce:italic>).
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0080" view="all">
					<ce:label>3</ce:label>
					<ce:section-title>Experimental results</ce:section-title>
					<ce:para id="p0220" view="all">The clustering performance of the proposed method is evaluated on six synthetic and four real datasets. The first four synthetic datasets DS1–DS4 are taken from the literature 
						<ce:cross-refs refid="b0110 b0020 b0070 b0065">[22,4,14,13]</ce:cross-refs>, and the next two DS5, DS6 are from 
						<ce:cross-ref refid="b0210">[42]</ce:cross-ref>. These datasets are illustrated in 
						<ce:cross-ref refid="f0025">Fig. 5</ce:cross-ref>
						<ce:float-anchor refid="f0025"/>. The four real world instances are taken from the UCI datasets 
						<ce:cross-ref refid="b0250">[50]</ce:cross-ref>, including IRIS, WINE, Breast Cancer Wisconsin (WBC), and Breast Cancer Wisconsin Diagnostic (WDBC). The descriptions of these datasets are shown in 
						<ce:cross-ref refid="t0005">Table 1</ce:cross-ref>
						<ce:float-anchor refid="t0005"/>.
					</ce:para>
					<ce:para id="p0225" view="all">The proposed method SAM is compared to the following six clustering algorithms:
						<ce:list id="l0010">
							<ce:list-item id="o0020">
								<ce:label>1.</ce:label>
								<ce:para id="p0365" view="all">
									<ce:italic>K</ce:italic>-means 
									<ce:cross-ref refid="b0160">[32]</ce:cross-ref>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0025">
								<ce:label>2.</ce:label>
								<ce:para id="p0370" view="all">DBScan 
									<ce:cross-ref refid="b0050">[10]</ce:cross-ref>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0030">
								<ce:label>3.</ce:label>
								<ce:para id="p0375" view="all">Single linkage 
									<ce:cross-ref refid="b0195">[39]</ce:cross-ref>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0035">
								<ce:label>4.</ce:label>
								<ce:para id="p0380" view="all">Spectral clustering 
									<ce:cross-ref refid="b0190">[38]</ce:cross-ref>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0040">
								<ce:label>5.</ce:label>
								<ce:para id="p0385" view="all">CSM 
									<ce:cross-ref refid="b0150">[30]</ce:cross-ref>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0045">
								<ce:label>6.</ce:label>
								<ce:para id="p0390" view="all">CHAMELEON 
									<ce:cross-ref refid="b0115">[23]</ce:cross-ref>.
								</ce:para>
							</ce:list-item>
						</ce:list>
					</ce:para>
					<ce:para id="p0230" view="all">The first four algorithms are traditional clustering methods, whereas the next two are hybrid ones. In addition, three variants of SAM are performed to demonstrate the importance of the various steps and design choices of the algorithm:
						<ce:list id="l0015">
							<ce:list-item id="o0050">
								<ce:label>1.</ce:label>
								<ce:para id="p0395" view="all">SAM-No-Pruning: split-and-merge without the pruning step.</ce:para>
							</ce:list-item>
							<ce:list-item id="o0055">
								<ce:label>2.</ce:label>
								<ce:para id="p0400" view="all">SAM-2-MST: split-and-merge but using 2-MST instead of 3-MST.</ce:para>
							</ce:list-item>
							<ce:list-item id="o0060">
								<ce:label>3.</ce:label>
								<ce:para id="p0405" view="all">SAM-SL: split-and-merge but using single linkage within the merge stage instead of the criterion based on 
									<ce:italic>R</ce:italic>()-values.
								</ce:para>
							</ce:list-item>
						</ce:list>
					</ce:para>
					<ce:para id="p0235" view="all">As 
						<ce:italic>K</ce:italic>-means and CSM may produce different partitions in different runs, in the following experiments we take the best clustering result out of 10 trial runs performed for each dataset in terms of one of the most used external clustering validity indices, Adjusted Rand (see Section 
						<ce:cross-ref refid="s0085">3.1</ce:cross-ref>). For DBScan, since we have no a priori knowledge about the parameters (
						<ce:italic>MinPts</ce:italic> and 
						<ce:italic>Eps</ce:italic>), proper values were selected by trial and error.
					</ce:para>
					<ce:section id="s0085" view="all">
						<ce:label>3.1</ce:label>
						<ce:section-title>External clustering validity indexes</ce:section-title>
						<ce:para id="p0240" view="all">An external clustering validity index is defined to measure the degree of correspondence between a clustering result and the prespecified partitions 
							<ce:cross-ref refid="b0205">[41]</ce:cross-ref>. We will employ the four popular external indexes, Rand, FM, Jaccard, and Adjusted Rand (
							<ce:cross-refs refid="b0170 b0205 b0220 b0240">[34,41,44,48]</ce:cross-refs>), to evaluate the quality of the clustering results. Briefly, these four indexes are described as follows.
						</ce:para>
						<ce:para id="p0245" view="all">Suppose {
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>} is the set of prespecified partitions, {
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">1</ce:inf>,
							<ce:hsp sp="0.12"/>…
							<ce:hsp sp="0.12"/>,
							<ce:hsp sp="0.12"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>K</ce:italic>
							</ce:inf>} is a set of partitions produced by a clustering. For a pair of vectors (
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>), it is referred as: (a) SS pair if ∃
							<ce:italic>I</ce:italic>(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>I</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∧
							<ce:hsp sp="0.25"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>I</ce:italic>
							</ce:inf>) and ∃
							<ce:italic>J</ce:italic>(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>J</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∧
							<ce:hsp sp="0.25"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>J</ce:italic>
							</ce:inf>), (b) SD pair if ∃
							<ce:italic>I</ce:italic>(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>I</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∧
							<ce:hsp sp="0.25"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>I</ce:italic>
							</ce:inf>) and ∄
							<ce:italic>J</ce:italic>(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>J</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∧
							<ce:hsp sp="0.25"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>J</ce:italic>
							</ce:inf>), (c) DS pair if ∄
							<ce:italic>I</ce:italic>(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>I</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∧
							<ce:hsp sp="0.25"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>I</ce:italic>
							</ce:inf>) and ∃
							<ce:italic>J</ce:italic>(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>J</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∧
							<ce:hsp sp="0.25"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>J</ce:italic>
							</ce:inf>), (d) DD pair if ∄
							<ce:italic>I</ce:italic>(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>I</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∧
							<ce:hsp sp="0.25"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>I</ce:italic>
							</ce:inf>) and ∄
							<ce:italic>J</ce:italic>(
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>u</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>J</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∧
							<ce:hsp sp="0.25"/>
							<ce:bold>x</ce:bold>
							<ce:inf loc="post">
								<ce:italic>v</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>J</ce:italic>
							</ce:inf>). Let 
							<ce:italic>a</ce:italic>, 
							<ce:italic>b</ce:italic>, 
							<ce:italic>c</ce:italic>, 
							<ce:italic>d</ce:italic> denote the numbers of SS, SD, DS, and DD pairs, respectively, and 
							<ce:italic>M</ce:italic> the number of total pairs, the four indexes are defined as:
							<ce:list id="l0020">
								<ce:list-item id="o0065">
									<ce:label>1.</ce:label>
									<ce:para id="p0410" view="all">Rand
										<ce:display>
											<ce:formula id="e0065">
												<ce:label>(13)</ce:label>
												<mml:math altimg="si38.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:mi>R</mml:mi>
													<mml:mo>=</mml:mo>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mi>a</mml:mi>
													<mml:mo>+</mml:mo>
													<mml:mi>d</mml:mi>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>/</mml:mo>
													<mml:mi>M</mml:mi>
													<mml:mtext>.</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0070">
									<ce:label>2.</ce:label>
									<ce:para id="p0415" view="all">Jaccard
										<ce:display>
											<ce:formula id="e0070">
												<ce:label>(14)</ce:label>
												<mml:math altimg="si39.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:mi>J</mml:mi>
													<mml:mo>=</mml:mo>
													<mml:mi>a</mml:mi>
													<mml:mo>/</mml:mo>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mi>a</mml:mi>
													<mml:mo>+</mml:mo>
													<mml:mi>b</mml:mi>
													<mml:mo>+</mml:mo>
													<mml:mi>c</mml:mi>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mtext>.</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0075">
									<ce:label>3.</ce:label>
									<ce:para id="p0420" view="all">FM
										<ce:display>
											<ce:formula id="e0075">
												<ce:label>(15)</ce:label>
												<mml:math altimg="si40.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:mi mathvariant="italic">FM</mml:mi>
													<mml:mo>=</mml:mo>
													<mml:msqrt>
														<mml:mrow>
															<mml:mfrac>
																<mml:mrow>
																	<mml:mi>a</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>a</mml:mi>
																	<mml:mo>+</mml:mo>
																	<mml:mi>b</mml:mi>
																</mml:mrow>
															</mml:mfrac>
															<mml:mfrac>
																<mml:mrow>
																	<mml:mi>a</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>a</mml:mi>
																	<mml:mo>+</mml:mo>
																	<mml:mi>c</mml:mi>
																</mml:mrow>
															</mml:mfrac>
														</mml:mrow>
													</mml:msqrt>
													<mml:mtext>.</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0080">
									<ce:label>4.</ce:label>
									<ce:para id="p0425" view="all">Adjusted Rand
										<ce:display>
											<ce:formula id="e0080">
												<ce:label>(16)</ce:label>
												<mml:math altimg="si41.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
													<mml:mi mathvariant="italic">AR</mml:mi>
													<mml:mo>=</mml:mo>
													<mml:mfrac>
														<mml:mrow>
															<mml:mn>2</mml:mn>
															<mml:mrow>
																<mml:mfenced open="(" close=")">
																	<mml:mrow>
																		<mml:mi mathvariant="italic">Ma</mml:mi>
																		<mml:mo>-</mml:mo>
																		<mml:mo stretchy="false">(</mml:mo>
																		<mml:mi>a</mml:mi>
																		<mml:mo>+</mml:mo>
																		<mml:mi>b</mml:mi>
																		<mml:mo stretchy="false">)</mml:mo>
																		<mml:mo stretchy="false">(</mml:mo>
																		<mml:mi>a</mml:mi>
																		<mml:mo>+</mml:mo>
																		<mml:mi>c</mml:mi>
																		<mml:mo stretchy="false">)</mml:mo>
																	</mml:mrow>
																</mml:mfenced>
															</mml:mrow>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>M</mml:mi>
															<mml:mo stretchy="false">(</mml:mo>
															<mml:mn>2</mml:mn>
															<mml:mi>a</mml:mi>
															<mml:mo>+</mml:mo>
															<mml:mi>b</mml:mi>
															<mml:mo>+</mml:mo>
															<mml:mi>c</mml:mi>
															<mml:mo stretchy="false">)</mml:mo>
															<mml:mo>-</mml:mo>
															<mml:mn>2</mml:mn>
															<mml:mo stretchy="false">(</mml:mo>
															<mml:mi>a</mml:mi>
															<mml:mo>+</mml:mo>
															<mml:mi>b</mml:mi>
															<mml:mo stretchy="false">)</mml:mo>
															<mml:mo stretchy="false">(</mml:mo>
															<mml:mi>a</mml:mi>
															<mml:mo>+</mml:mo>
															<mml:mi>c</mml:mi>
															<mml:mo stretchy="false">)</mml:mo>
														</mml:mrow>
													</mml:mfrac>
													<mml:mtext>.</mml:mtext>
												</mml:math>
											</ce:formula>
										</ce:display>
									</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
					</ce:section>
					<ce:section id="s0090" view="all">
						<ce:label>3.2</ce:label>
						<ce:section-title>Results on synthetic datasets</ce:section-title>
						<ce:para id="p0250" view="all">
							<ce:italic>DS1:</ce:italic> This instance contains two datasets shaped like a crescent with different densities. The clustering results are illustrated in 
							<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>
							<ce:float-anchor refid="f0030"/>. SAM and SAM-No-Pruning, DBScan, CSM and CHAMELEON can partition the dataset properly. Both SAM-2-MST and SAM-SL fail. Since 
							<ce:italic>K</ce:italic>-means favors spherical clusters, it fails on DS1. Single linkage clustering produces unsatisfactory partitions because it measures the distance between two clusters as the minimum distance between the pairs of data points in the two clusters. In the spectral clustering algorithm, the similarity matrix is created by a Gaussian kernel function with Euclidean distances, but the clustering result of this algorithm is similar to that of 
							<ce:italic>K</ce:italic>-means. Although DBScan produces the expected partitions, it was difficult to tune the two parameters to achieve the proper result.
						</ce:para>
						<ce:para id="p0255" view="all">
							<ce:italic>DS2:</ce:italic> The set is composed of two Gaussian distributed clusters and one unclosed ring cluster surrounding the first two. 
							<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>
							<ce:float-anchor refid="f0035"/> illustrates the clustering results. SAM and SAM-2-MST provide satisfactory clustering results, whereas SAM-No-Pruning and SAM-SL produce improper results. CSM can sometimes identify the proper clusters, but not always. The results of DBScan and spectral clustering are not perfect, but better than those of 
							<ce:italic>K</ce:italic>-means, single linkage, and CHAMELEON.
						</ce:para>
						<ce:para id="p0260" view="all">
							<ce:italic>DS3:</ce:italic> This dataset contains a spherical cluster and a half ring shaped cluster. The clustering results are shown in 
							<ce:cross-ref refid="f0040">Fig. 8</ce:cross-ref>
							<ce:float-anchor refid="f0040"/>. All the algorithms except 
							<ce:italic>K</ce:italic>-means and single linkage discover the expected clusters.
						</ce:para>
						<ce:para id="p0265" view="all">
							<ce:italic>DS4:</ce:italic> This dataset consists of 7 Gaussian distributed clusters. 
							<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>
							<ce:float-anchor refid="f0045"/> illustrates the clustering results. SAM, its variant SAM-No-Pruning and SAM-2-MST, spectral clustering, CSM, and CHAMELEON find the expected clusters. SAM-SL and 
							<ce:italic>K</ce:italic>-means provide partitions with low quality.
						</ce:para>
						<ce:para id="p0270" view="all">
							<ce:italic>DS5:</ce:italic> This dataset consists of 31 Gaussian distributed clusters. The clustering results are illustrated in 
							<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>
							<ce:float-anchor refid="f0050"/>. Spectral clustering, CSM, and CHAMELEON produce the expected partitions. SAM and SAM-SL are also successful except they fail to detect the cluster on the rightmost part. SAM-No-Pruning and SAM-2-MST perform much worse, whereas 
							<ce:italic>K</ce:italic>-means, single linkage, and DBScan fail to detect almost all the expected clusters.
						</ce:para>
						<ce:para id="p0275" view="all">
							<ce:italic>DS6:</ce:italic> The 15 Gaussian distributed clusters in this dataset are arranged in two concentric circles. 
							<ce:cross-ref refid="f0055">Fig. 11</ce:cross-ref>
							<ce:float-anchor refid="f0055"/> describes the clustering results. SAM, SAM-SL, spectral clustering, CSM, and CHAMELEON produce the proper partitions, but SAM-No-Pruning, SAM-2-MST, 
							<ce:italic>K</ce:italic>-means, single linkage, and DBScan do not.
						</ce:para>
						<ce:para id="p0280" view="all">The corresponding Adjusted Rand index values of the clustering results on these six synthetic datasets are shown in 
							<ce:cross-ref refid="t0010">Table 2</ce:cross-ref>
							<ce:float-anchor refid="t0010"/>.
						</ce:para>
					</ce:section>
					<ce:section id="s0095" view="all">
						<ce:label>3.3</ce:label>
						<ce:section-title>Results on real datasets</ce:section-title>
						<ce:para id="p0285" view="all">The performance on each of the four UCI datasets is evaluated using the four common external clustering validity indices: Rand, Adjusted-Rand, Jaccard coefficient, and Fowlkes and Mallows (FM). The evaluation results on the four datasets are shown in 
							<ce:cross-refs refid="t0015 t0020 t0025 t0030">Tables 3–6</ce:cross-refs>
							<ce:float-anchor refid="t0015"/>
							<ce:float-anchor refid="t0020"/>
							<ce:float-anchor refid="t0025"/>
							<ce:float-anchor refid="t0030"/>, respectively. The parameters of DBScan for IRIS, WINE, WBC, and WDBC are set to (MinPts
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>8,
							<ce:hsp sp="0.12"/> Eps
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>0.4), (MinPts
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>3,
							<ce:hsp sp="0.12"/>Eps
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>0.3), (MinPts
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>9,
							<ce:hsp sp="0.12"/>Eps
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>2), (MinPts
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>4,
							<ce:hsp sp="0.12"/>Eps
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>32.3), respectively.
						</ce:para>
						<ce:para id="p0290" view="all">For the IRIS dataset, 
							<ce:cross-ref refid="t0015">Table 3</ce:cross-ref> indicates that SAM, SAM-2-MST, and SAM-SL have the same performance and outperform the others. SAM-No-Pruning, CSM, DBScan, and 
							<ce:italic>K</ce:italic>-means also provide partitions with relative high quality. In the case of the WINE dataset, the corresponding clustering qualities are shown in 
							<ce:cross-ref refid="t0020">Table 4</ce:cross-ref>. 
							<ce:italic>K</ce:italic>-means has the best performance, single linkage and spectral clustering provide more proper partitions than the proposed method SAM. It can be seen from 
							<ce:cross-ref refid="t0025">Table 5</ce:cross-ref> that SAM outperforms the other algorithms except 
							<ce:italic>K</ce:italic>-means on the WBC dataset. As for the WDBC dataset in 
							<ce:cross-ref refid="t0030">Table 6</ce:cross-ref>, DBScan has the best performance, while the proposed method SAM is better than 
							<ce:italic>K</ce:italic>-means, single linkage, spectral clustering, CSM as well as its variants.
						</ce:para>
					</ce:section>
					<ce:section id="s0100" view="all">
						<ce:label>3.4</ce:label>
						<ce:section-title>Discussion about the SAM variants</ce:section-title>
						<ce:para id="p0295" view="all">Pruning gives a small but consistent improvement (SAM vs. SAM-No-Pruning) based on the numeric results (
							<ce:cross-refs refid="t0010 t0015 t0020 t0025">Tables 2–5</ce:cross-refs>). In the case of DS2, pruning is critical to obtain the correct clustering whereas for the other test sets its effect is more like fine-tuning.
						</ce:para>
						<ce:para id="p0300" view="all">For the merge criterion, the index 
							<ce:italic>R</ce:italic>(
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>,
							<ce:hsp sp="0.12"/>
							<ce:italic>C</ce:italic>
							<ce:inf loc="post">
								<ce:italic>j</ce:italic>
							</ce:inf>) is more complicated to evaluate than some simple alternatives like the single linkage criterion. Its effect on the clustering quality, however, is significant and in most cases the proposed approach (SAM) outperforms the single linkage variant (SAM-SL) using the single linkage algorithm in the merge stage. We consider the criterion-based merge critical for the performance of the algorithm.
						</ce:para>
						<ce:para id="p0305" view="all">The role of the 
							<ce:italic>k</ce:italic>-MST is important. The value 
							<ce:italic>k</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>3 was fixed already in preliminary tests using DS1-DS6, but let us discuss other choices. In SAM, 1-MST cannot be used in the merge stage as the criterion requires more information about the neighborhood than a simple spanning tree can provide, as the results of SAM-SL already showed. The question about the exact value of 
							<ce:italic>k</ce:italic>, however, is less critical. In most cases, SAM and SAM-2-MST provide the same result, and only in two cases (DS1 and DS2) the 2-MST variant fails.
						</ce:para>
						<ce:para id="p0310" view="all">Higher values than 
							<ce:italic>k</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>3 were also tested, see 
							<ce:cross-ref refid="f0060">Fig. 12</ce:cross-ref>
							<ce:float-anchor refid="f0060"/>. In most cases, the improvements due to higher values for 
							<ce:italic>k</ce:italic> are insignificant and just increase the processing time. A contradicting example is the WDBC test set where higher values turn out to be harmful. Therefore, it is reasonable that the value of 
							<ce:italic>k</ce:italic> is set to 3.
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0105" view="all">
					<ce:label>4</ce:label>
					<ce:section-title>Conclusion</ce:section-title>
					<ce:para id="p0315" view="all">The proposed method employs minimum spanning trees in different stages. Before a dataset is split into different clusters, the hairs (leaves together with the connecting edges) of the first MST computed for the whole instance are pruned.</ce:para>
					<ce:para id="p0320" view="all">In the splitting stage, more than the desired 
						<ce:italic>K</ce:italic> clusters are created by 
						<ce:italic>K</ce:italic>-means. Three MSTs on an iteratively refined graph are computed and combined to determine the initial prototypes for 
						<ce:italic>K</ce:italic>-means, because randomly selected initial prototypes would lead to unstable partitions.
					</ce:para>
					<ce:para id="p0325" view="all">After splitting, the initial MST is employed to adjust the partitions to make each subgroup corresponding to a subtree. Finally, in the merge step only neighboring pairs with respect to the same MST are considered to be merged.</ce:para>
					<ce:para id="p0330" view="all">Experiments have demonstrated the importance of each step of the algorithm. Except the number of clusters, there are no parameters left to be tuned by the user.</ce:para>
					<ce:para id="p0335" view="all">In summary, various MSTs are utilized during the whole split-and-merge algorithm because they can capture the intrinsic structure of a dataset. However, the computational complexity of constructing an MST is close to 
						<ce:italic>O</ce:italic>(
						<ce:italic>N</ce:italic>
						<ce:sup loc="post">2</ce:sup>). The expensive computational cost obstructs the application of an MST to large scale data sets. One of our future work is to find a fast algorithm to construct an approximate MST.
					</ce:para>
					<ce:para id="p0340" view="all">One drawback of the proposed method is that the universality of the definitions of inter-connectivity and intra-similarity is insufficient. Although there does not exist a universal clustering method that can deal with all kinds of clustering problems, we try to improve the definition of inter-connectivity and intra-similarity to make the proposed method suitable for as many clustering problems as possible.</ce:para>
					<ce:para id="p0345" view="all">Although the proposed method does not have any direct restrictions for being applied to datasets with high dimensions, it is assumed to have all the same weaknesses as the other distance-based methods. Because to determine the intrinsic structure of this kind of datasets, different dimensions may have varied importance, whereas the proposed method equally considers all of dimensions of an input dataset. Thus, subspace clusterings 
						<ce:cross-refs refid="b0035 b0040">[7,8]</ce:cross-refs> or other methods tailored for high dimensional data are expected to work better for high-dimensional datasets.
					</ce:para>
				</ce:section>
			</ce:sections>
			<ce:acknowledgment xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Acknowledgments</ce:section-title>
				<ce:para id="p0540" view="all">The authors thank the anonymous reviewers for their constructive comments and suggestions which helped improve the quality of this paper. The work of C. Zhong was supported by 
					<ce:grant-sponsor id="GS1" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">Zhejiang Provincial Natural Science Foundation of China</ce:grant-sponsor>, No. 
					<ce:grant-number refid="GS1">Y1090851</ce:grant-number>, and the 
					<ce:grant-sponsor id="GS2" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">Center for International Mobility (CIMO)</ce:grant-sponsor>. The work of D. Miao was supported by the 
					<ce:grant-sponsor id="GS3" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">National Natural Science Foundation of China</ce:grant-sponsor>, No. 
					<ce:grant-number refid="GS3">60970061</ce:grant-number>, No. 
					<ce:grant-number refid="GS3">61075056</ce:grant-number>, and the 
					<ce:grant-sponsor id="GS4" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">Research Fund for the Doctoral Program of Higher Education</ce:grant-sponsor>, No. 
					<ce:grant-number refid="GS4">20060247039</ce:grant-number>.
				</ce:para>
			</ce:acknowledgment>
		</ja:body>
		<ja:tail view="all">
			<ce:bibliography id="bi005" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>References</ce:section-title>
				<ce:bibliography-sec id="bs005">
					<ce:bib-reference id="b0005">
						<ce:label>[1]</ce:label>
						<ce:other-ref>
							<ce:textref>R. Agrawal, J. Gehrke, D. Gunopulos, P. Raghavan, Automatic subspace clustering of high dimensional data for datamining applications, in: Proceedings of ACM-SIGMOD Conference on the Management of Data, 1998, pp. 94–105.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0010">
						<ce:label>[2]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Bereta</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>T.</ce:given-name>
										<ce:surname>Burczynski</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Immune 
										<ce:italic>k</ce:italic>-means and negative selection algorithms for data analysis
									</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>179</sb:volume-nr>
									</sb:series>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1407</sb:first-page>
									<sb:last-page>1425</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0015">
						<ce:label>[3]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.C.</ce:given-name>
										<ce:surname>Bezdek</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>N.R.</ce:given-name>
										<ce:surname>Pal</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Some new indexes of cluster validity</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Syst. Man Cybern. B. Cybern.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>28</sb:volume-nr>
									</sb:series>
									<sb:date>1998</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>301</sb:first-page>
									<sb:last-page>315</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0020">
						<ce:label>[4]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.</ce:given-name>
										<ce:surname>Chang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.Y.</ce:given-name>
										<ce:surname>Yeung</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Robust path-based spectral clustering</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Pattern Recognit.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>41</sb:volume-nr>
									</sb:series>
									<sb:date>2008</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>191</sb:first-page>
									<sb:last-page>203</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0025">
						<ce:label>[5]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>D.</ce:given-name>
										<ce:surname>Cheng</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Kannan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Vempala</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>Wang</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A divide-and-merge methodology for clustering</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>ACM Trans. Database Syst.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>31</sb:volume-nr>
									</sb:series>
									<sb:date>2006</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1499</sb:first-page>
									<sb:last-page>1525</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0030">
						<ce:label>[6]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.C.</ce:given-name>
										<ce:surname>Chiang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.W.</ce:given-name>
										<ce:surname>Tsai</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.S.</ce:given-name>
										<ce:surname>Yang</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A time-efficient pattern reduction algorithm for 
										<ce:italic>k</ce:italic>-means clustering
									</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>181</sb:volume-nr>
									</sb:series>
									<sb:date>2011</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>716</sb:first-page>
									<sb:last-page>731</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0035">
						<ce:label>[7]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Chu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.</ce:given-name>
										<ce:surname>Chuang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.</ce:given-name>
										<ce:surname>Yang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Density conscious subspace clustering for high-dimensional data</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Knowl. Data Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>22</sb:volume-nr>
									</sb:series>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>16</sb:first-page>
									<sb:last-page>30</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0040">
						<ce:label>[8]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Chu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.</ce:given-name>
										<ce:surname>Yang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Reducing redundancy in subspace clustering</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Knowl. Data Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>21</sb:volume-nr>
									</sb:series>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1432</sb:first-page>
									<sb:last-page>1446</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0045">
						<ce:label>[9]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>T.H.</ce:given-name>
										<ce:surname>Corman</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.E.</ce:given-name>
										<ce:surname>Leiserson</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.L.</ce:given-name>
										<ce:surname>Rivest</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.</ce:given-name>
										<ce:surname>Stein</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Introduction to Algorithms</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:edition>second ed.</sb:edition>
									<sb:date>2001</sb:date>
									<sb:publisher>
										<sb:name>MIT Press</sb:name>
										<sb:location>Cambridge, MA</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0050">
						<ce:label>[10]</ce:label>
						<ce:other-ref>
							<ce:textref>M. Ester, H.-P. Kriegel, J. Sander, X. Xu, A density-based algorithm for discovering clusters in large spatial data sets with noise, in: Proceedings of the Second International Conference on Knowledge Discovery and Data Mining, Portland, OR, 1996, pp. 226–231.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0055">
						<ce:label>[11]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Figueiredo</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.K.</ce:given-name>
										<ce:surname>Jain</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Unsupervised learning of finite mixture models</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Pattern Anal. Mach. Intell.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>24</sb:volume-nr>
									</sb:series>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>381</sb:first-page>
									<sb:last-page>396</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0060">
						<ce:label>[12]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Fränti</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>O.</ce:given-name>
										<ce:surname>Virmajoki</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>V.</ce:given-name>
										<ce:surname>Hautamäki</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Fast agglomerative clustering using a k-nearest neighbor graph</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Pattern Anal. Mach. Intell.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>28</sb:volume-nr>
									</sb:series>
									<sb:date>2006</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1875</sb:first-page>
									<sb:last-page>1881</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0065">
						<ce:label>[13]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>L.</ce:given-name>
										<ce:surname>Fu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>E.</ce:given-name>
										<ce:surname>Medico</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>FLAME, a novel fuzzy clustering method for the analysis of DNA microarray data</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>BMC Bioinformatics</sb:maintitle>
										</sb:title>
										<sb:volume-nr>8</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>3</sb:issue-nr>
									<sb:date>2007</sb:date>
								</sb:issue>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0070">
						<ce:label>[14]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Gionis</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.</ce:given-name>
										<ce:surname>Annila</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Tsaparas</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Clustering aggregation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>ACM Trans. Knowl. Disc. Data</sb:maintitle>
										</sb:title>
										<sb:volume-nr>1</sb:volume-nr>
									</sb:series>
									<sb:date>2007</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1</sb:first-page>
									<sb:last-page>30</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0075">
						<ce:label>[15]</ce:label>
						<ce:other-ref>
							<ce:textref>S. Guha, R. Rastogi, K. Shim, CURE: an efficient clustering algorithm for large databases, in: Proceedings of the 1998 ACM-SIGMOD International Conference Management of Data (SIGMOD’98), 1998, pp. 73–84.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0080">
						<ce:label>[16]</ce:label>
						<ce:other-ref>
							<ce:textref>S. Guha, R. Rastogi, K. Shim, ROCK: a robust clustering algorithm for categorical attributes, in: Proceedings of the IEEE Conference on Data Engineering, 1999, pp. 512–521.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0085">
						<ce:label>[17]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>T.</ce:given-name>
										<ce:surname>Hastie</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Tibshirani</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Friedman</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>The Elements of Statistical Learning, Data Mining, Inference and Prediction</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:date>2001</sb:date>
									<sb:publisher>
										<sb:name>Springer</sb:name>
										<sb:location>New York</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0090">
						<ce:label>[18]</ce:label>
						<ce:other-ref>
							<ce:textref>A. Hinneburg, D.A. Keim, An efficient approach to clustering in large multimedia databases with noise, in: Knowledge Discovery and Data Mining, 1998, pp. 58–65.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0095">
						<ce:label>[19]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.-C.</ce:given-name>
										<ce:surname>Hsu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.-L.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.-W.</ce:given-name>
										<ce:surname>Su</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Hierarchical clustering of mixed data based on distance hierarchy</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>177</sb:volume-nr>
									</sb:series>
									<sb:date>2007</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>4474</sb:first-page>
									<sb:last-page>4492</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0100">
						<ce:label>[20]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.K.</ce:given-name>
										<ce:surname>Jain</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Murthy</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Flynn</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Data clustering: a review</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>ACM Comput. Surv.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>31</sb:volume-nr>
									</sb:series>
									<sb:date>1999</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>264</sb:first-page>
									<sb:last-page>323</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0105">
						<ce:label>[21]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.K.</ce:given-name>
										<ce:surname>Jain</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.C.</ce:given-name>
										<ce:surname>Dubes</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Algorithms for Clustering Data</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:date>1988</sb:date>
									<sb:publisher>
										<sb:name>Prentice-Hall</sb:name>
										<sb:location>Englewood Cliffs, NJ</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0110">
						<ce:label>[22]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.K.</ce:given-name>
										<ce:surname>Jain</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.C.</ce:given-name>
										<ce:surname>Law</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Data clustering: a user’s dilemma</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Pattern Recognition and Machine Intelligence</sb:maintitle>
									</sb:title>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>LNCS</sb:maintitle>
											</sb:title>
											<sb:volume-nr>vol. 3776</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>2005</sb:date>
									<sb:publisher>
										<sb:name>Springer-Verlag</sb:name>
										<sb:location>Berlin, Heidelberg</sb:location>
									</sb:publisher>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>1</sb:first-page>
									<sb:last-page>10</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0115">
						<ce:label>[23]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>Karypis</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>E.H.</ce:given-name>
										<ce:surname>Han</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>V.</ce:given-name>
										<ce:surname>Kumar</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>CHAMELEON: a hierarchical clustering algorithm using dynamic modeling</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Comput.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>32</sb:volume-nr>
									</sb:series>
									<sb:date>1999</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>68</sb:first-page>
									<sb:last-page>75</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0120">
						<ce:label>[24]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>L.</ce:given-name>
										<ce:surname>Kaufman</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.J.</ce:given-name>
										<ce:surname>Rousseeuw</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Finding Groups in Data: An Introduction to Cluster Analysis</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:date>1990</sb:date>
									<sb:publisher>
										<sb:name>Wiley</sb:name>
										<sb:location>New York</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0125">
						<ce:label>[25]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>T.</ce:given-name>
										<ce:surname>Kaukoranta</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Fränti</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>O.</ce:given-name>
										<ce:surname>Nevalainen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Iterative split-and-merge algorithm for VQ codebook generation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Opt. Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>37</sb:volume-nr>
									</sb:series>
									<sb:date>1998</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>2726</sb:first-page>
									<sb:last-page>2732</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0130">
						<ce:label>[26]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>B.</ce:given-name>
										<ce:surname>King</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Step-wise clustering procedures</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Am. Stat. Assoc.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>69</sb:volume-nr>
									</sb:series>
									<sb:date>1967</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>86</sb:first-page>
									<sb:last-page>101</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0135">
						<ce:label>[27]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.Z.C.</ce:given-name>
										<ce:surname>Lai</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>T.J.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>An agglomerative clustering algorithm using a dynamic 
										<ce:italic>k</ce:italic>-nearest-neighbor list
									</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>181</sb:volume-nr>
									</sb:series>
									<sb:date>2011</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1722</sb:first-page>
									<sb:last-page>1734</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0140">
						<ce:label>[28]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.S.</ce:given-name>
										<ce:surname>Lee</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Olafsson</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Data clustering by minimizing disconnectivity</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>181</sb:volume-nr>
									</sb:series>
									<sb:date>2011</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>732</sb:first-page>
									<sb:last-page>746</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0145">
						<ce:label>[29]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.H.</ce:given-name>
										<ce:surname>Lee</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>O.R.</ce:given-name>
										<ce:surname>Zaïane</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>H.-H.</ce:given-name>
										<ce:surname>Park</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Huang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Greiner</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Clustering high dimensional data: a graph-based relaxed optimization approach</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>178</sb:volume-nr>
									</sb:series>
									<sb:date>2008</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>4501</sb:first-page>
									<sb:last-page>4511</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0150">
						<ce:label>[30]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.R.</ce:given-name>
										<ce:surname>Lin</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.S.</ce:given-name>
										<ce:surname>Chen</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Combining partitional and hierarchical algorithms for robust and efficient data clustering with cohesion self-merging</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Knowl. Data Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>17</sb:volume-nr>
									</sb:series>
									<sb:date>2005</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>145</sb:first-page>
									<sb:last-page>159</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0155">
						<ce:label>[31]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Liu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>X.</ce:given-name>
										<ce:surname>Jiang</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.C.</ce:given-name>
										<ce:surname>Kot</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A multi-prototype clustering algorithm</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Pattern Recognit.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>42</sb:volume-nr>
									</sb:series>
									<sb:date>2009</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>689</sb:first-page>
									<sb:last-page>698</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0160">
						<ce:label>[32]</ce:label>
						<ce:other-ref>
							<ce:textref>J. MacQueen, Some methods for classification and analysis of multivariate observations, in: Fifth Berkeley Symposium on Mathematics, Statistics and Probability, 1967, pp. 281–297.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0165">
						<ce:label>[33]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.</ce:given-name>
										<ce:surname>McLachlan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.</ce:given-name>
										<ce:surname>Basford</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Mixture Models: Inference and Application to Clustering</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:date>1988</sb:date>
									<sb:publisher>
										<sb:name>Marcel Dekker</sb:name>
										<sb:location>New York</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0170">
						<ce:label>[34]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.W.</ce:given-name>
										<ce:surname>Milligan</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.C.</ce:given-name>
										<ce:surname>Soon</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>L.M.</ce:given-name>
										<ce:surname>Sokol</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>The effect of cluster size, dimensionality, and the number of clusters on recovery of true cluster structure</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Pattern Anal. Mach. Intell.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>5</sb:volume-nr>
									</sb:series>
									<sb:date>1983</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>40</sb:first-page>
									<sb:last-page>47</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0175">
						<ce:label>[35]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.T.</ce:given-name>
										<ce:surname>Ng</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Han</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>CLARANS: a method for clustering objects for spatial data mining</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Knowl. Data Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>14</sb:volume-nr>
									</sb:series>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1003</sb:first-page>
									<sb:last-page>1016</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0180">
						<ce:label>[36]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.R.</ce:given-name>
										<ce:surname>Rezaee</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>B.P.F.</ce:given-name>
										<ce:surname>Lelieveldt</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.H.C.</ce:given-name>
										<ce:surname>Reiber</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A new cluster validity index for the fuzzy 
										<ce:italic>c</ce:italic>-mean
									</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Pattern Recognit. Lett.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>19</sb:volume-nr>
									</sb:series>
									<sb:date>1998</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>237</sb:first-page>
									<sb:last-page>246</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0185">
						<ce:label>[37]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>S.E.</ce:given-name>
										<ce:surname>Schaeffer</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Graph clustering</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Comput. Sci. Rev.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>1</sb:volume-nr>
									</sb:series>
									<sb:date>2007</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>27</sb:first-page>
									<sb:last-page>64</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0190">
						<ce:label>[38]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Shi</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Malik</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Normalized cuts and image segmentation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Pattern Anal. Mach. Intell.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>22</sb:volume-nr>
									</sb:series>
									<sb:date>2000</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>888</sb:first-page>
									<sb:last-page>905</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0195">
						<ce:label>[39]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>P.H.A.</ce:given-name>
										<ce:surname>Sneath</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.R.</ce:given-name>
										<ce:surname>Sokal</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Numerical Taxonomy</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:date>1973</sb:date>
									<sb:publisher>
										<sb:name>Freeman</sb:name>
										<sb:location>San Francisco, London</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0200">
						<ce:label>[40]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>G.T.</ce:given-name>
										<ce:surname>Toussaint</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>The relative neighborhood graph of a finite planar set</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Pattern Recognit.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>12</sb:volume-nr>
									</sb:series>
									<sb:date>1980</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>261</sb:first-page>
									<sb:last-page>268</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0205">
						<ce:label>[41]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Theodorodis</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>K.</ce:given-name>
										<ce:surname>Kouttoumbas</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Pattern Recognition</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:edition>fourth ed.</sb:edition>
									<sb:date>2009</sb:date>
									<sb:publisher>
										<sb:name>Academic Press</sb:name>
										<sb:location>Amsterdam</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0210">
						<ce:label>[42]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.J.</ce:given-name>
										<ce:surname>Veenman</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.J.T.</ce:given-name>
										<ce:surname>Reinders</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>E.</ce:given-name>
										<ce:surname>Backer</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>A maximum variance cluster algorithm</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Pattern Anal. Mach. Intell.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>24</sb:volume-nr>
									</sb:series>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1273</sb:first-page>
									<sb:last-page>1280</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0215">
						<ce:label>[43]</ce:label>
						<ce:other-ref>
							<ce:textref>W. Wang, J. Yang, M. Muntz, STING: a statistical information grid approach to spatial datamining, in: Proceedings of the International Conference on Very Large Data Bases, 1997, pp. 186–195.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0220">
						<ce:label>[44]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>M.J.</ce:given-name>
										<ce:surname>Warrens</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>On the equivalence of Cohen’s kappa and the Hubert–Arabie Adjusted Rand index</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Classif.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>25</sb:volume-nr>
									</sb:series>
									<sb:date>2008</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>177</sb:first-page>
									<sb:last-page>183</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0225">
						<ce:label>[45]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Z.</ce:given-name>
										<ce:surname>Wu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Leahy</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>An optimal graph theoretic approach to data clustering: theory and its application to image segmentation</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Pattern Anal. Mach. Intell.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>15</sb:volume-nr>
									</sb:series>
									<sb:date>1993</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1101</sb:first-page>
									<sb:last-page>1113</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0230">
						<ce:label>[46]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Xu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.</ce:given-name>
										<ce:surname>Wunsch</ce:surname>
										<ce:suffix>II</ce:suffix>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Survey of clustering algorithms</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Neural Netw.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>16</sb:volume-nr>
									</sb:series>
									<sb:date>2005</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>645</sb:first-page>
									<sb:last-page>678</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0235">
						<ce:label>[47]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Xu</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>V.</ce:given-name>
										<ce:surname>Olman</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.</ce:given-name>
										<ce:surname>Xu</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Clustering gene expression data using a graph-theoretic approach: an application of minimum spanning tree</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Bioinformatics</sb:maintitle>
										</sb:title>
										<sb:volume-nr>18</sb:volume-nr>
									</sb:series>
									<sb:date>2002</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>536</sb:first-page>
									<sb:last-page>545</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0240">
						<ce:label>[48]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>K.Y.</ce:given-name>
										<ce:surname>Yeung</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>C.</ce:given-name>
										<ce:surname>Fraley</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Murua</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>A.E.</ce:given-name>
										<ce:surname>Raftery</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Model-based clustering and data transformations for gene expression data</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Bioinformatics</sb:maintitle>
										</sb:title>
										<sb:volume-nr>17</sb:volume-nr>
									</sb:series>
									<sb:date>2001</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>977</sb:first-page>
									<sb:last-page>987</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0245">
						<ce:label>[49]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.T.</ce:given-name>
										<ce:surname>Zahn</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Graph-theoretical methods for detecting and describing gestalt clusters</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Comput.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>C-20</sb:volume-nr>
									</sb:series>
									<sb:date>1971</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>68</sb:first-page>
									<sb:last-page>86</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0250">
						<ce:label>[50]</ce:label>
						<ce:other-ref>
							<ce:textref>
								<ce:inter-ref xlink:href="http://www.ics.uci/mlearn/MLRespository.html" xlink:type="simple" xmlns:xlink="http://www.w3.org/1999/xlink">&lt;http://www.ics.uci/mlearn/MLRespository.html&gt;</ce:inter-ref>.
							</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
				</ce:bibliography-sec>
			</ce:bibliography>
		</ja:tail>
	</ja:article></doc:document>
