<doc:document xmlns:doc="http://www.elsevier.com/xml/document/schema"><rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="http://dx.doi.org/10.1016/j.ins.2011.04.017"><dc:format xmlns:dc="http://purl.org/dc/elements/1.1/">application/xml</dc:format><dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">Cost based in-network join strategy in tree routing sensor networks</dc:title><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/"><rdf:Seq><rdf:li>Jun-Ki Min</rdf:li><rdf:li>Heejung Yang</rdf:li><rdf:li>Chin-Wan Chung</rdf:li></rdf:Seq></dc:creator><dc:subject xmlns:dc="http://purl.org/dc/elements/1.1/"><rdf:Bag><rdf:li>Query processing</rdf:li><rdf:li>Sensor network</rdf:li><rdf:li>Join</rdf:li><rdf:li>Cost model</rdf:li></rdf:Bag></dc:subject><dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">Information Sciences 181 (2011) 3443-3458. doi:10.1016/j.ins.2011.04.017</dc:description><prism:aggregationType xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">journal</prism:aggregationType><prism:publicationName xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Information Sciences</prism:publicationName><prism:copyright xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Copyright © 2011 Elsevier Inc. All rights reserved.</prism:copyright><dc:publisher xmlns:dc="http://purl.org/dc/elements/1.1/">Elsevier Inc.</dc:publisher><prism:issn xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">0020-0255</prism:issn><prism:volume xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">181</prism:volume><prism:number xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">16</prism:number><prism:coverDisplayDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">2011</prism:coverDisplayDate><prism:coverDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">2011</prism:coverDate><prism:pageRange xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3443-3458</prism:pageRange><prism:startingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3443</prism:startingPage><prism:endingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">3458</prism:endingPage><prism:doi xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">10.1016/j.ins.2011.04.017</prism:doi><prism:url xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">http://dx.doi.org/10.1016/j.ins.2011.04.017</prism:url><dc:identifier xmlns:dc="http://purl.org/dc/elements/1.1/">doi:10.1016/j.ins.2011.04.017</dc:identifier></rdf:Description></rdf:RDF><dp:document-properties xmlns:dp="http://www.elsevier.com/xml/common/doc-properties/schema"><dp:aggregation-type>Journals</dp:aggregation-type><dp:version-number>S300.1</dp:version-number></dp:document-properties><ja:article docsubtype="fla" xml:lang="en" version="5.1" xmlns:ja="http://www.elsevier.com/xml/ja/schema">
		<ja:item-info>
			<ja:jid>INS</ja:jid>
			<ja:aid>9068</ja:aid>
			<ce:pii xmlns:ce="http://www.elsevier.com/xml/common/schema">S0020-0255(11)00191-5</ce:pii>
			<ce:doi xmlns:ce="http://www.elsevier.com/xml/common/schema">10.1016/j.ins.2011.04.017</ce:doi>
			<ce:copyright type="full-transfer" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema">Elsevier Inc.</ce:copyright>
		</ja:item-info>
		<ce:floats xmlns:ce="http://www.elsevier.com/xml/common/schema">
			<ce:figure id="f0005">
				<ce:label>Fig. 1</ce:label>
				<ce:caption>
					<ce:simple-para id="sp015" view="all">Routing tree and join scenario.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr1"/>
			</ce:figure>
			<ce:figure id="f0010">
				<ce:label>Fig. 2</ce:label>
				<ce:caption>
					<ce:simple-para id="sp020" view="all">Sensing region SR().</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr2"/>
			</ce:figure>
			<ce:figure id="f0015">
				<ce:label>Fig. 3</ce:label>
				<ce:caption>
					<ce:simple-para id="sp025" view="all">Basic join plans.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr3"/>
			</ce:figure>
			<ce:figure id="f0020">
				<ce:label>Fig. 4</ce:label>
				<ce:caption>
					<ce:simple-para id="sp030" view="all">Data transmission with a query region.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr4"/>
			</ce:figure>
			<ce:figure id="f0025">
				<ce:label>Fig. 5</ce:label>
				<ce:caption>
					<ce:simple-para id="sp035" view="all">Hop distances.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr5"/>
			</ce:figure>
			<ce:figure id="f0030">
				<ce:label>Fig. 6</ce:label>
				<ce:caption>
					<ce:simple-para id="sp040" view="all">Partitions of 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf>.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr6"/>
			</ce:figure>
			<ce:figure id="f0035">
				<ce:label>Fig. 7</ce:label>
				<ce:caption>
					<ce:simple-para id="sp045" view="all">An Example of 
						<ce:italic>partitionJoin</ce:italic>.
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr7"/>
			</ce:figure>
			<ce:figure id="f0040">
				<ce:label>Fig. 8</ce:label>
				<ce:caption>
					<ce:simple-para id="sp050" view="all">A greedy algorithm for partition join.</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr8"/>
			</ce:figure>
			<ce:figure id="f0045">
				<ce:label>Fig. 9</ce:label>
				<ce:caption>
					<ce:simple-para id="sp055" view="all">Join selectivity results (
						<ce:italic>SJS</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>. 
							<ce:italic>A</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>0.5).
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr9"/>
			</ce:figure>
			<ce:figure id="f0050">
				<ce:label>Fig. 10</ce:label>
				<ce:caption>
					<ce:simple-para id="sp060" view="all">Selection selectivity results (
						<mml:math altimg="si1.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mi mathvariant="italic">sel</mml:mi>
								<mml:mo stretchy="false">(</mml:mo>
								<mml:msub>
									<mml:mrow>
										<mml:mi>P</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:msub>
								<mml:mo stretchy="false">)</mml:mo>
								<mml:mo>=</mml:mo>
								<mml:mn>0.5</mml:mn>
							</mml:mrow>
						</mml:math>).
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr10"/>
			</ce:figure>
			<ce:figure id="f0055">
				<ce:label>Fig. 11</ce:label>
				<ce:caption>
					<ce:simple-para id="sp065" view="all">Cover node depth results (
						<ce:italic>D</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>2).
					</ce:simple-para>
				</ce:caption>
				<ce:link locator="gr11"/>
			</ce:figure>
			<ce:table frame="topbot" id="t0005" rowsep="0" colsep="0">
				<ce:label>Table 1</ce:label>
				<ce:caption>
					<ce:simple-para id="sp070" view="all">Summary of join plans.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="2" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="left"/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Join plan</ce:entry>
							<ce:entry>Intuition</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>baseJoin</ce:italic>
							</ce:entry>
							<ce:entry>A join is performed at the base station</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>coverJoin</ce:italic>
							</ce:entry>
							<ce:entry>Semijoins are performed at the node that can obtain all sensor readings of two regions</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>sideJoin</ce:italic>
							</ce:entry>
							<ce:entry>Sensor readings of a region are sent to a node in the other side to perform a semijoin</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>partitionJoin</ce:italic>
							</ce:entry>
							<ce:entry>Sensor readings of a region are distributed into nodes in the other side to perform semijoins</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>synopsisJoin</ce:italic>
							</ce:entry>
							<ce:entry>Similar to 
								<ce:italic>partitionJoin</ce:italic> except sending a synopsis instead of sensor readings
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>fullsynopsisJoin</ce:italic>
							</ce:entry>
							<ce:entry>
								<ce:italic>synopsisJoin</ce:italic> is applied to both query regions
							</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0010" rowsep="0" colsep="0">
				<ce:label>Table 2</ce:label>
				<ce:caption>
					<ce:simple-para id="sp075" view="all">Parameters.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="3" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="left"/>
					<cals:colspec colname="col3" align="left"/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Parameter</ce:entry>
							<ce:entry>Default value</ce:entry>
							<ce:entry>Comments</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>sel</ce:italic>(
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>Q</ce:italic>
								</ce:inf>)
							</ce:entry>
							<ce:entry>0.5</ce:entry>
							<ce:entry>Selection selectivity for a region 
								<ce:italic>Q</ce:italic>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>SJS</ce:italic>
							</ce:entry>
							<ce:entry>0.5</ce:entry>
							<ce:entry>Semijoin selectivity</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>C</ce:italic>
								</ce:inf>
							</ce:entry>
							<ce:entry>1</ce:entry>
							<ce:entry>See 
								<ce:cross-ref refid="f0025">Fig. 5</ce:cross-ref>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
							</ce:entry>
							<ce:entry>2</ce:entry>
							<ce:entry>See 
								<ce:cross-ref refid="f0025">Fig. 5</ce:cross-ref>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>
							</ce:entry>
							<ce:entry>2</ce:entry>
							<ce:entry>See 
								<ce:cross-ref refid="f0025">Fig. 5</ce:cross-ref>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>∣
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>∣
							</ce:entry>
							<ce:entry>10</ce:entry>
							<ce:entry># of nodes in 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>∣
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>∣
							</ce:entry>
							<ce:entry>10</ce:entry>
							<ce:entry># of nodes in 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>
							</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
			<ce:table frame="topbot" id="t0015" rowsep="0" colsep="0">
				<ce:label>Table 3</ce:label>
				<ce:caption>
					<ce:simple-para id="sp080" view="all">Memory requirement.</ce:simple-para>
				</ce:caption>
				<cals:tgroup cols="3" xmlns:cals="http://www.elsevier.com/xml/common/cals/schema">
					<cals:colspec colname="col1" align="left"/>
					<cals:colspec colname="col2" align="left"/>
					<cals:colspec colname="col3" align="left"/>
					<cals:thead>
						<cals:row rowsep="1" valign="top">
							<ce:entry>Join plan</ce:entry>
							<ce:entry>MIN data size</ce:entry>
							<ce:entry>MAX data size</ce:entry>
						</cals:row>
					</cals:thead>
					<cals:tbody>
						<cals:row valign="top">
							<ce:entry>coverJoin</ce:entry>
							<ce:entry>443,344 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>))
							</ce:entry>
							<ce:entry/>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>LsideJoin</ce:entry>
							<ce:entry>220,880 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>))
							</ce:entry>
							<ce:entry>222,464 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>))
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>RsideJoin</ce:entry>
							<ce:entry>220,880 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>))
							</ce:entry>
							<ce:entry>222464 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>))
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>LpartitionJoin</ce:entry>
							<ce:entry>61,764 (
								<ce:italic>Lc</ce:italic>
								<ce:inf loc="post">2</ce:inf>)
							</ce:entry>
							<ce:entry>220,880 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>))
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>RpartitionJoin</ce:entry>
							<ce:entry>62,536 (
								<ce:italic>Rc</ce:italic>
								<ce:inf loc="post">2</ce:inf>)
							</ce:entry>
							<ce:entry>222,464 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>))
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>LsynopsisJoin</ce:entry>
							<ce:entry>21,018 (
								<ce:italic>Lc</ce:italic>
								<ce:inf loc="post">2</ce:inf>)
							</ce:entry>
							<ce:entry>220,880 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>))
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>RsynopsisJoin</ce:entry>
							<ce:entry>22,118 (
								<ce:italic>Rc</ce:italic>
								<ce:inf loc="post">2</ce:inf>)
							</ce:entry>
							<ce:entry>222,464 (cov
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>))
							</ce:entry>
						</cals:row>
						<cals:row valign="top">
							<ce:entry>fullsynopsisJoin</ce:entry>
							<ce:entry>21,018 (
								<ce:italic>Lc</ce:italic>
								<ce:inf loc="post">5</ce:inf>)
							</ce:entry>
							<ce:entry>44,998 (
								<ce:italic>Lc</ce:italic>
								<ce:inf loc="post">6</ce:inf>)
							</ce:entry>
						</cals:row>
					</cals:tbody>
				</cals:tgroup>
			</ce:table>
		</ce:floats>
		<ja:head>
			<ce:title xmlns:ce="http://www.elsevier.com/xml/common/schema">Cost based in-network join strategy in tree routing sensor networks</ce:title>
			<ce:author-group xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:author>
					<ce:given-name>Jun-Ki</ce:given-name>
					<ce:surname>Min</ce:surname>
					<ce:cross-ref refid="aff1">
						<ce:sup loc="post">a</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">jkmin@kut.ac.kr</ce:e-address>
				</ce:author>
				<ce:author>
					<ce:given-name>Heejung</ce:given-name>
					<ce:surname>Yang</ce:surname>
					<ce:cross-ref refid="aff2">
						<ce:sup loc="post">b</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">heejung@islab.kaist.ac.kr</ce:e-address>
				</ce:author>
				<ce:author>
					<ce:given-name>Chin-Wan</ce:given-name>
					<ce:surname>Chung</ce:surname>
					<ce:cross-ref refid="aff2">
						<ce:sup loc="post">b</ce:sup>
					</ce:cross-ref>
					<ce:cross-ref refid="cor1">
						<ce:sup loc="post">⁎</ce:sup>
					</ce:cross-ref>
					<ce:e-address type="email">chungcw@kaist.edu</ce:e-address>
				</ce:author>
				<ce:affiliation id="aff1">
					<ce:label>a</ce:label>
					<ce:textfn>School of Internet-Media Engineering, Korea University of Technology and Education, Byeongcheon-myeon, Cheonan, Chungnam 330-708, Republic of Korea</ce:textfn>
				</ce:affiliation>
				<ce:affiliation id="aff2">
					<ce:label>b</ce:label>
					<ce:textfn>Department of Computer Science, Korea Advanced Institute of Science and Technology (KAIST), Daejeon 305-701, Republic of Korea</ce:textfn>
				</ce:affiliation>
				<ce:correspondence id="cor1">
					<ce:label>⁎</ce:label>
					<ce:text>Corresponding author. Tel.: +82 42 869 3537; fax: +82 42 869 3577.</ce:text>
				</ce:correspondence>
			</ce:author-group>
			<ce:date-received day="30" month="11" year="2009" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:date-revised day="6" month="10" year="2010" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:date-accepted day="3" month="4" year="2011" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:abstract class="author" xml:lang="en" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Abstract</ce:section-title>
				<ce:abstract-sec>
					<ce:simple-para id="sp005" view="all">The tiny and smart sensors enable applications which access a network of hundreds or thousands of sensors. In many applications, joins are used frequently to find relationships of readings of different sensors such as the correlation of sensor readings in distinct regions.</ce:simple-para>
					<ce:simple-para id="sp010" view="all">In this paper, we present a cost based in-network join strategy called INJECT. Since the optimal join plan is determined according to various conditions such as data distributions and predicates of joins, it wastes the energy of sensors to use a fixed join plan blindly. Based on the analysis on how join queries can be handled in sensor networks, we devise several join plans. In particular, since the data transmission dominates the energy consumption of a sensor, we devise cost models each of which reflects the transmission cost of a join plan. Experimental results confirm that INJECT chooses the optimal or near optimal plan under various conditions.</ce:simple-para>
				</ce:abstract-sec>
			</ce:abstract>
			<ce:keywords class="keyword" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Keywords</ce:section-title>
				<ce:keyword>
					<ce:text>Query processing</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Sensor network</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Join</ce:text>
				</ce:keyword>
				<ce:keyword>
					<ce:text>Cost model</ce:text>
				</ce:keyword>
			</ce:keywords>
		</ja:head>
		<ja:body view="all">
			<ce:sections xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section id="s0005" view="all">
					<ce:label>1</ce:label>
					<ce:section-title>Introduction</ce:section-title>
					<ce:para id="p0005" view="all">Wireless sensor networks (WSNs) are systems that are typically composed of a large number of sensors and the base station where a user can access data. Sensor nodes in sensor networks are severely constrained in terms of battery power. Replacing the battery of a sensor is either too expensive or impossible. The energy preservation is a major research issue since it directly impacts the life time of a network.</ce:para>
					<ce:para id="p0010" view="all">Recent research has shown that radio communication is the most expensive. Thus, many techniques in diverse areas such as the routing protocol 
						<ce:cross-refs refid="b0045 b0060 b0080">[9,12,16]</ce:cross-refs>, event detection 
						<ce:cross-refs refid="b0005 b0110">[1,22]</ce:cross-refs>, in-network aggregation 
						<ce:cross-ref refid="b0065">[13]</ce:cross-ref>, and approximate data gathering 
						<ce:cross-refs refid="b0025 b0040 b0055 b0075">[5,8,11,15]</ce:cross-refs> have been proposed in order to reduce the communication overhead.
					</ce:para>
					<ce:para id="p0015" view="all">In-network aggregation provides a great opportunity for reducing the communication overhead using the summary data (e.g., SUM) and/or exemplary data (e.g., MIN and MAX). However, a single aggregated value is insufficient to analyze the whole sensor field in some applications 
						<ce:cross-ref refid="b0025">[5]</ce:cross-ref>.
					</ce:para>
					<ce:para id="p0020" view="all">Thus, some data gathering techniques 
						<ce:cross-refs refid="b0025 b0040 b0055 b0075">[5,8,11,15]</ce:cross-refs> in sensor networks have been proposed. Periodic reporting of sensor readings drains the energy of sensors since it results in excessive communication. So, to reduce the communication overhead, in-network approximation techniques have been proposed. In this approach, data model 
						<ce:cross-ref refid="b0055">[11]</ce:cross-ref> or data compression 
						<ce:cross-ref refid="b0075">[15]</ce:cross-ref> technique are applied.
					</ce:para>
					<ce:para id="p0025" view="all">In some applications, a user wants to identify the relationship between sensor readings in different regions. For example, a climatologist wants to analyze the correlation of the rain fall of a region and the temperature of another region. This regional correlation can be expressed as a join query of sensor readings in two regions.</ce:para>
					<ce:para id="p0030" view="all">A naive plan to answer a join query is to gather sensor readings of two regions at the base station and to perform a join operation at the base station. This approach may waste much energy of sensors since sensor readings which will not participate in the join results have to be transmitted to the base station.</ce:para>
					<ce:para id="p0035" view="all">An alternative plan is to perform a join in sensor networks in order to filter out unrelated sensor readings as soon as possible. However, using a fixed in-network join plan blindly may waste the sensor energy as much as the naive plan does. Thus, in this paper, we propose INJECT which is an In-Network Join stratEgy using Cost based optimization in Tree routing sensor networks. Tree based routing has been proposed as an energy efficient mechanism to transmit sensor readings. Due to its simplicity and manageability, many works for sensor networks are based on tree routing where a message from a node is passed to another node through a routing tree. Our work is also based on tree routing.</ce:para>
					<ce:para id="p0040" view="all">Join processing has a long and rich history in the database field. However, due to the hierarchical structure of sensor networks, traditional techniques are not directly applicable. Thus, recently, research on in-network join processing 
						<ce:cross-refs refid="b0085 b0100 b0105 b0110 b0115">[17,20–23]</ce:cross-refs> has been proposed to reduce the communication overhead. In in-network join processing, a node generates join results. However, some techniques just propose join plans without proper cost models. Also, although other work suggests cost models for in-network joins, the proposed cost models are too rough to be used in the query optimization. In addition, some in-network join plans are based on location based routing protocols such as GPSR. Thus, these plans are not applied to the tree-based routing environments.
					</ce:para>
					<ce:para id="p0045" view="all">To the best of our knowledge, our work is the first for the cost-based optimization in tree routing sensor networks. Based on our cost model, accurate cost models for diverse in-network join techniques including the future techniques can be devised.</ce:para>
					<ce:para id="p0050" view="all">
						<ce:italic>Our contribution.</ce:italic> Our work focuses on an efficient in-network join processing with a low transmission cost in order to conserve the energy of sensors. Let sets of sensor readings in a region 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf> and a region 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf> be 
						<ce:italic>L</ce:italic> and 
						<ce:italic>R</ce:italic>, respectively, and a join predicate of 
						<ce:italic>L</ce:italic> and 
						<ce:italic>R</ce:italic> be 
						<ce:italic>P</ce:italic>
						<ce:inf loc="post">
							<ce:italic>JOIN</ce:italic>
						</ce:inf>(
						<ce:italic>L</ce:italic>, 
						<ce:italic>R</ce:italic>). Then a join query is defined as 
						<mml:math altimg="si2.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mi>L</mml:mi>
								<mml:msub>
									<mml:mrow>
										<mml:mi>⋈</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">JOIN</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>L</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>R</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msub>
								<mml:mi>R</mml:mi>
							</mml:mrow>
						</mml:math>. In the result of the join, an element in 
						<ce:italic>L</ce:italic> associates with many elements in 
						<ce:italic>R</ce:italic>, and vice versa. INJECT considers semijoin operators as in-network join operators. Since a semijoin generates tuples which will participate in join results, the unrelated tuples can be filter out. Thus, the network communication overhead is reduced. In INJECT, we assume that actual join operation is performed at the base station which has unlimited power, using the results of semijoins (i.e., the results of 
						<ce:italic>L</ce:italic>
						<ce:hsp sp="0.25"/>⋉
						<ce:hsp sp="0.25"/>
						<ce:italic>R</ce:italic> and 
						<ce:italic>R</ce:italic>
						<ce:hsp sp="0.25"/>⋉
						<ce:hsp sp="0.25"/>
						<ce:italic>L</ce:italic>).
					</ce:para>
					<ce:para id="p0055" view="all">INJECT has the following combination of contributions to perform an in-network join in an energy efficient manner.
						<ce:list id="l0005">
							<ce:list-item id="o0005">
								<ce:label>•</ce:label>
								<ce:para id="p0690" view="all">We propose an in-network join framework using cost based optimization to identify an efficient join plan on tree based routing networks.</ce:para>
							</ce:list-item>
							<ce:list-item id="o0010">
								<ce:label>•</ce:label>
								<ce:para id="p0695" view="all">For INJECT, we devise diverse join plans in sensor network environments. First, we suggest three basic join plans: 
									<ce:italic>baseJoin</ce:italic>, 
									<ce:italic>coverJoin</ce:italic>, and 
									<ce:italic>sideJoin</ce:italic>. And, by the analysis on the hierarchical structure of tree routing networks, we devise 
									<ce:italic>partitionJoin</ce:italic>. In addition, we devise 
									<ce:italic>synopsisJoin</ce:italic> by combining the synopsis technique and 
									<ce:italic>partitionJoin</ce:italic>.
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0015">
								<ce:label>•</ce:label>
								<ce:para id="p0700" view="all">We devise accurate cost models for diverse join plans in tree routing. For cost based optimization, an accurate cost model is an indispensable component. In our work, we make a basic cost model for gathering sensor readings in a query region and sending the gathered readings to a node in the tree based routing environments. Based on the basic cost model, we develop the cost models for the devised join plans.</ce:para>
							</ce:list-item>
							<ce:list-item id="o0020">
								<ce:label>•</ce:label>
								<ce:para id="p0705" view="all">We provide an extensive experimental study of our framework in diverse environments. Our experimental results show that INJECT provides accurate cost models and therefore the most efficient query plan is selected.</ce:para>
							</ce:list-item>
						</ce:list>
					</ce:para>
					<ce:para id="p0060" view="all">
						<ce:italic>Organization of the paper.</ce:italic> In the remainder of the paper, we present details of INJECT. In Section 
						<ce:cross-ref refid="s0010">2</ce:cross-ref>, we present the characteristics of our join operation. Section 
						<ce:cross-ref refid="s0015">3</ce:cross-ref> describes three basic join plans and their cost models. In Section 
						<ce:cross-ref refid="s0030">4</ce:cross-ref>, we present enhanced join plans that we devise. Section 
						<ce:cross-ref refid="s0050">5</ce:cross-ref> contains the experimental results. Section 
						<ce:cross-ref refid="s0085">6</ce:cross-ref> outlines related works. Finally, in Section 
						<ce:cross-ref refid="s0090">7</ce:cross-ref>, we summarize our work and suggest some future studies.
					</ce:para>
				</ce:section>
				<ce:section id="s0010" view="all">
					<ce:label>2</ce:label>
					<ce:section-title>Preliminaries</ce:section-title>
					<ce:para id="p0065" view="all">We first describe some assumptions used in the paper and formalize the in-network join processing problem.</ce:para>
					<ce:para id="p0070" view="all">Let us consider a set of sensor nodes 
						<ce:italic>S</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>{
						<ce:italic>s</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>s</ce:italic>
						<ce:inf loc="post">2</ce:inf>,
						<ce:hsp sp="0.12"/>…
						<ce:hsp sp="0.12"/>,
						<ce:hsp sp="0.12"/>
						<ce:italic>s</ce:italic>
						<ce:inf loc="post">
							<ce:italic>n</ce:italic>
						</ce:inf>} located at positions {(
						<ce:italic>x</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>y</ce:italic>
						<ce:inf loc="post">1</ce:inf>),
						<ce:hsp sp="0.12"/>…
						<ce:hsp sp="0.12"/>,
						<ce:hsp sp="0.12"/>(
						<ce:italic>x</ce:italic>
						<ce:inf loc="post">
							<ce:italic>n</ce:italic>
						</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>y</ce:italic>
						<ce:inf loc="post">
							<ce:italic>n</ce:italic>
						</ce:inf>)}, respectively. Sensor readings can be collected at the base station based on tree routing protocol. Each sensor keeps the hop distance which is the number of hops from the base station to it. Two nodes capable of bi-directional wireless communication are referred to as neighbors. Also, the base station knows the locations of sensors and the tree routing hierarchy among sensors.
					</ce:para>
					<ce:para id="p0075" view="all">In INJECT, a join query is submitted to the base station. The base station generates diverse join plans which will be presented in Sections 
						<ce:cross-refs refid="s0015 s0030">3 and 4</ce:cross-refs>. Then, the base station identifies the optimal join plan among diverse join plans using their cost models.
					</ce:para>
					<ce:para id="p0080" view="all">We analyze the join processing problem in sensor networks for a join query between relations. For the simplicity of presentation, we assume two relations. In reality, two-way joins are the most frequent, and also, they are the basis of m-way joins. A relation can be a set of sensor readings in a region as shown in 
						<ce:cross-ref refid="f0005">Fig. 1</ce:cross-ref>
						<ce:float-anchor refid="f0005"/>. There are many motivating examples about in-network joins in related literatures. Here, we present an SQL form for a join.
						<ce:list id="l0020">
							<ce:list-item id="o0060">
								<ce:para id="p0745" view="all">SELECT 
									<ce:italic>L</ce:italic>.∗, 
									<ce:italic>R</ce:italic>.∗
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0065">
								<ce:para id="p0750" view="all">FROM Sensor 
									<ce:italic>L</ce:italic>, Sensor 
									<ce:italic>R</ce:italic>
								</ce:para>
							</ce:list-item>
							<ce:list-item id="o0070">
								<ce:para id="p0755" view="all">WHERE 
									<ce:italic>L</ce:italic>.location in 
									<ce:italic>Q</ce:italic>
									<ce:inf loc="post">
										<ce:italic>L</ce:italic>
									</ce:inf>
									<ce:list id="l0025">
										<ce:list-item id="o0075">
											<ce:para id="p0760" view="all">AND 
												<ce:italic>R</ce:italic>.location in 
												<ce:italic>Q</ce:italic>
												<ce:inf loc="post">
													<ce:italic>R</ce:italic>
												</ce:inf>
											</ce:para>
										</ce:list-item>
										<ce:list-item id="o0080">
											<ce:para id="p0765" view="all">AND 
												<ce:italic>P</ce:italic>
												<ce:inf loc="post">
													<ce:italic>L</ce:italic>
												</ce:inf>(
												<ce:italic>L</ce:italic>)
											</ce:para>
										</ce:list-item>
										<ce:list-item id="o0085">
											<ce:para id="p0770" view="all">AND 
												<ce:italic>P</ce:italic>
												<ce:inf loc="post">
													<ce:italic>R</ce:italic>
												</ce:inf>(
												<ce:italic>R</ce:italic>)
											</ce:para>
										</ce:list-item>
										<ce:list-item id="o0090">
											<ce:para id="p0775" view="all">AND 
												<ce:italic>P</ce:italic>
												<ce:inf loc="post">
													<ce:italic>JOIN</ce:italic>
												</ce:inf>(
												<ce:italic>L</ce:italic>,
												<ce:hsp sp="0.12"/>
												<ce:italic>R</ce:italic>)
											</ce:para>
										</ce:list-item>
										<ce:list-item id="o0095">
											<ce:para id="p0780" view="all">{SAMPLE INTERVAL 
												<ce:italic>X</ce:italic>} {FOR 
												<ce:italic>D</ce:italic>}
											</ce:para>
										</ce:list-item>
									</ce:list>
								</ce:para>
							</ce:list-item>
						</ce:list>
					</ce:para>
					<ce:para id="p0085" view="all">In the above SQL statement, relations 
						<ce:italic>L</ce:italic> and 
						<ce:italic>R</ce:italic> are the sets of sensor readings restricted by regions 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf> and 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf>, respectively. Also, 
						<ce:italic>P</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf> and 
						<ce:italic>P</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf> are selection predicates for the relations 
						<ce:italic>L</ce:italic> and 
						<ce:italic>R</ce:italic>, respectively. If there is no selection predicate for a relation, all tuples in a relation (i.e., all sensor readings in 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf> (or 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf>)) are sent to the base station. Additionally, 
						<ce:italic>P</ce:italic>
						<ce:inf loc="post">
							<ce:italic>JOIN</ce:italic>
						</ce:inf>(
						<ce:italic>L</ce:italic>,
						<ce:hsp sp="0.12"/>
						<ce:italic>R</ce:italic>) is a join predicate for the relations 
						<ce:italic>L</ce:italic> and 
						<ce:italic>R</ce:italic>. Since the sensor readings are continuously generated, the above SQL statement is continuously executed. For this, we use TinyDB syntax 
						<ce:cross-ref refid="b0070">[14]</ce:cross-ref>: SAMPLE INTERVAL and FOR. The query is executed once per 
						<ce:italic>X</ce:italic> seconds for a period of 
						<ce:italic>D</ce:italic> seconds. The SAMPLE INTERVAL and FOR terms are optional. The default 
						<ce:italic>X</ce:italic> for SAMPLE INTERVAL is 1
						<ce:hsp sp="0.25"/>s and 
						<ce:italic>D</ce:italic> for FOR is ∞.
					</ce:para>
					<ce:para id="p0090" view="all">The problem that we intend to solve is formalized as follows:</ce:para>
					<ce:para id="p0095" view="all">
						<ce:italic>Problem definition</ce:italic>. Given a sensor network consisting of a set of sensor nodes 
						<ce:italic>S</ce:italic>
						<ce:hsp sp="0.25"/>=
						<ce:hsp sp="0.25"/>{
						<ce:italic>s</ce:italic>
						<ce:inf loc="post">1</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>s</ce:italic>
						<ce:inf loc="post">2</ce:inf>,
						<ce:hsp sp="0.12"/>
						<ce:italic>s</ce:italic>
						<ce:inf loc="post">
							<ce:italic>n</ce:italic>
						</ce:inf>}, tree routing is used to disseminate a query and collect sensor readings. Let sets of sensor readings in a region 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf> and a region 
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf> be 
						<ce:italic>L</ce:italic> and 
						<ce:italic>R</ce:italic>, respectively, and the join predicate of 
						<ce:italic>L</ce:italic> and 
						<ce:italic>R</ce:italic> be 
						<ce:italic>P</ce:italic>
						<ce:inf loc="post">
							<ce:italic>JOIN</ce:italic>
						</ce:inf>(
						<ce:italic>L</ce:italic>,
						<ce:hsp sp="0.12"/>
						<ce:italic>R</ce:italic>). Find the most effective plan to process a join query defined as 
						<mml:math altimg="si3.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
							<mml:mrow>
								<mml:mi>L</mml:mi>
								<mml:msub>
									<mml:mrow>
										<mml:mi>⋈</mml:mi>
									</mml:mrow>
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">JOIN</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>L</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="0.12em"/>
										<mml:mi>R</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:msub>
								<mml:mi>R</mml:mi>
							</mml:mrow>
						</mml:math>.
					</ce:para>
					<ce:para id="p0100" view="all">In order to estimate a query cost, the selectivities of selection predicate 
						<ce:italic>P</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf> and 
						<ce:italic>P</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf> as well as join selectivity of join predicate 
						<ce:italic>P</ce:italic>
						<ce:inf loc="post">
							<ce:italic>JOIN</ce:italic>
						</ce:inf>(
						<ce:italic>L</ce:italic>,
						<ce:hsp sp="0.12"/>
						<ce:italic>R</ce:italic>) are required. To obtain these statistics, the base station executes an in-network join plan, 
						<ce:italic>baseJoin</ce:italic> (described in Section 
						<ce:cross-ref refid="s0015">3</ce:cross-ref>), and collects required statistics from join results in learning phases. Also, the query optimizer recomputes the costs of query plans using the history of the previous query results periodically and the base station broadcasts a more efficient plan, if exists. We omit the details of this since our work focuses on the diverse join plans and their accurate cost models.
					</ce:para>
				</ce:section>
				<ce:section id="s0015" view="all">
					<ce:label>3</ce:label>
					<ce:section-title>In-network join processing</ce:section-title>
					<ce:para id="p0105" view="all">In this section, we present three basic join plans considered in INJECT and suggest their cost models based on tree routing. Based on the basic join plans, some extended join plans will be presented in Section 
						<ce:cross-ref refid="s0030">4</ce:cross-ref>.
					</ce:para>
					<ce:para id="p0110" view="all">The proposed join plans are summarized in 
						<ce:cross-ref refid="t0005">Table 1</ce:cross-ref>
						<ce:float-anchor refid="t0005"/>.
					</ce:para>
					<ce:section id="s0020" view="all">
						<ce:label>3.1</ce:label>
						<ce:section-title>Basic join plans</ce:section-title>
						<ce:para id="p0115" view="all">In order to explain the basic join plans and their cost models, we define some basic concepts.
							<ce:enunciation id="n0005">
								<ce:label>Definition 1</ce:label>
								<ce:para id="p0785" view="all">The sensing region of a sensor 
									<ce:italic>s</ce:italic>, 
									<ce:italic>SR</ce:italic>(
									<ce:italic>s</ce:italic>) is a minimum bounding region that covers the locations of 
									<ce:italic>s</ce:italic>’s descendants and itself in a routing tree. The descendants of a sensor 
									<ce:italic>s</ce:italic> are all the nodes that are in its subtree.
								</ce:para>
							</ce:enunciation>
							<ce:enunciation id="n0010">
								<ce:label>Definition 2</ce:label>
								<ce:para id="p0790" view="all">The covering node set of a region 
									<ce:italic>Q</ce:italic>, 
									<ce:italic>cov</ce:italic>(
									<ce:italic>Q</ce:italic>) is a set of nodes each of which has 
									<ce:italic>SR</ce:italic>() containing the given region 
									<ce:italic>Q</ce:italic>.
								</ce:para>
							</ce:enunciation>
							<ce:enunciation id="n0015">
								<ce:label>Definition 3</ce:label>
								<ce:para id="p0795" view="all">The minimal cover node of a region 
									<ce:italic>Q</ce:italic>, 
									<ce:italic>cov</ce:italic>
									<ce:inf loc="post">
										<ce:italic>min</ce:italic>
									</ce:inf>(
									<ce:italic>Q</ce:italic>) is a node whose 
									<ce:italic>SR</ce:italic>() covers the given region and is minimal.
								</ce:para>
							</ce:enunciation>
						</ce:para>
						<ce:para id="p0120" view="all">By 
							<ce:cross-refs refid="n0010 n0015">Definitions 2 and 3</ce:cross-refs>, the node 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>) for a region 
							<ce:italic>Q</ce:italic> is an element in 
							<ce:italic>cov</ce:italic>(
							<ce:italic>Q</ce:italic>). Also, since our data transmission is based on tree routing, 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>) has the maximum hop distance from the base station among elements in 
							<ce:italic>cov</ce:italic>(
							<ce:italic>Q</ce:italic>).
						</ce:para>
						<ce:para id="p0125" view="all">For example, as shown in 
							<ce:cross-ref refid="f0010">Fig. 2</ce:cross-ref>
							<ce:float-anchor refid="f0010"/>, for a given query region 
							<ce:italic>Q</ce:italic> presented as a solid box, the sensing region of 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">2</ce:inf> (=
							<ce:italic>SR</ce:italic>(
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">2</ce:inf>)) covers 
							<ce:italic>Q</ce:italic>. Also, 
							<ce:italic>SR</ce:italic>(
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">1</ce:inf>) covers 
							<ce:italic>Q</ce:italic>. Thus, 
							<ce:italic>cov</ce:italic>(
							<ce:italic>Q</ce:italic>)
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>{
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">1</ce:inf>, 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">2</ce:inf>}. Note that 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">1</ce:inf> and 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">2</ce:inf> can collect all readings of sensors in 
							<ce:italic>Q</ce:italic>. Since 
							<ce:italic>SR</ce:italic>(
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">2</ce:inf>) is smaller than 
							<ce:italic>SR</ce:italic>(
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">1</ce:inf>), 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>)
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">2</ce:inf>. We use a rectangle to illustrate a region for easy understanding. However, any polygon can be used.
						</ce:para>
						<ce:para id="p0130" view="all">Three basic join plans are plotted in 
							<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>
							<ce:float-anchor refid="f0015"/>. Roughly speaking, join plans are classified by the join node where a semijoin operation is performed.
						</ce:para>
						<ce:para id="p0135" view="all">As mentioned earlier, a naive way to answer a join query is to gather all sensor readings at the base station and to perform a join at the base station. We call this plan 
							<ce:italic>baseJoin</ce:italic>.
						</ce:para>
						<ce:para id="p0140" view="all">Another join plan is that an intermediate node in the tree performs semijoins. An intermediate node can collect the sensor readings obtained from sensors in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> and 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf> in order to perform semijoins. Thus, the intermediate node (i.e., join node) is an ancestor node of all sensors in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> and 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>. Thus the join node is 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). We call this plan 
							<ce:italic>coverJoin</ce:italic>.
						</ce:para>
						<ce:para id="p0145" view="all">In 
							<ce:italic>coverJoin</ce:italic>, we do not consider the other nodes in 
							<ce:italic>cov</ce:italic>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) as a join node. Suppose that a semijoin operation at a node 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>cov</ce:italic>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), which is not 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), is an efficient execution plan.It means that the size of the semijoin result is smaller than that of all sensor readings. By 
							<ce:cross-ref refid="n0015">Definition 3</ce:cross-ref>, a semijoin operation can be performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). Thus, it is more efficient that sending the semijoin results from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) rather than 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>.
						</ce:para>
						<ce:para id="p0150" view="all">The final basic join plan is 
							<ce:italic>sideJoin</ce:italic>. In 
							<ce:italic>sideJoin</ce:italic>, as shown in 
							<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>(c), the join column of sensor readings in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> is sent to the other side where a semijoin operation is performed. Thus, a semijoin operation is performed at a node which is an ancestor node of sensors in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>. Therefore, a semijoin is performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0155" view="all">Among above three join plans, 
							<ce:italic>coverJoin</ce:italic> and 
							<ce:italic>sideJoin</ce:italic> are categorized into the in-network join approach since semijoins are performed at nodes in a network. In general, if the join selectivity is very high, the in-network join approach is useless. In contrast, if the join selectivity is very low, an in-network join approach is beneficial since the size of the join result is much smaller than that of sensor readings participating in a join operation. Therefore, by using the cost model, the optimal join plan should be selected.
						</ce:para>
						<ce:para id="p0160" view="all">In our work, we only consider semijoin operators for in-network join processing. Note that, since the base station can get all the tuples (=
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic> and 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>) participating in the join result, the join result can be computed at the base station without loss of information.
						</ce:para>
						<ce:para id="p0165" view="all">Consequently, in 
							<ce:italic>coverJoin</ce:italic>, two semijoin operations (i.e. 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic> and 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>L) are performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) and two semijoin results are sent to the base station.
						</ce:para>
						<ce:para id="p0170" view="all">In 
							<ce:italic>sideJoin</ce:italic>, 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> is performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). To do this, sensor readings in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> are sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). And then the join column, not whole sensor readings, is sent from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). Therefore, 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> is performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) and then 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉(R
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>) is performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) using the semijoin result (=(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>)) obtained from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0175" view="all">Since similar arguments hold when the join column of 
							<ce:italic>R</ce:italic> is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>), we only present the case that the join column of a relation 
							<ce:italic>L</ce:italic> is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) in this paper.
						</ce:para>
					</ce:section>
					<ce:section id="s0025" view="all">
						<ce:label>3.2</ce:label>
						<ce:section-title>Cost model</ce:section-title>
						<ce:para id="p0180" view="all">In this section, we present cost models for INJECT. To estimate costs, various statistical estimations can be included. It will incur additional cost to maintain required statistics incrementally. Thus, in our cost model, we use simple but reasonable statistical estimation. However, techniques for statistical estimations can be orthogonally applied.</ce:para>
						<ce:para id="p0185" view="all">As mention in Section 
							<ce:cross-ref refid="s0010">2</ce:cross-ref>, the base station identifies the optimal join plan in INJECT. In order to disseminate the optimal plan, the energy is consumed. Since the join plans should be propagated to all participating nodes in query regions, the dissemination costs of join plans are similar. In addition, the plan dissemination cost is quite small compared to the join processing cost since the join processing is performed for a period 
							<ce:italic>D</ce:italic>. Therefore, we only consider the join processing cost.
						</ce:para>
						<ce:para id="p0190" view="all">Since the transmission sizes (i.e., sizes of data to be joined) can be obtained using our model, the computation cost can be derived. However, it is a well known fact that the computing cost is ignorable compared to the transmission cost in sensor network environments. In the case of the Berkeley sensor motes, transmitting a single bit is equivalent to 800 instructions in terms of power consumption 
							<ce:cross-ref refid="b0065">[13]</ce:cross-ref>. Thus, like related literature, we omit the computation cost. Furthermore, it is really hard to reflect all aspects to a cost model. Thus, an abstraction is required. For instance, in the query optimization in traditional databases, the disk I/O time is mainly considered although the computing time exists. In addition, the computing cost is mainly determined by the size of data to be joined. Thus, the total computing costs of in-network join plans are similar. Therefore, considering the communication overhead only is sufficient to choose an effective join plan.
						</ce:para>
						<ce:para id="p0195" view="all">In addition, for simplicity, we do not consider a link failure. By retransmission, the link failure can be solved. Thus, using the retransmission probability, our cost model can be extended in a straightforward manner. These assumptions allow us to make a concise cost model.</ce:para>
						<ce:para id="p0200" view="all">As shown in 
							<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>
							<ce:float-anchor refid="f0020"/>, to transmit sensor readings in the region 
							<ce:italic>Q</ce:italic>, sensor readings are gathered at the node 
							<ce:italic>s</ce:italic>(=
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>)) through the tree based routing and then gathered sensor readings are sent to the node 
							<ce:italic>d</ce:italic>.
						</ce:para>
						<ce:para id="p0205" view="all">In addition, as mentioned earlier, the selection operation 
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>Q</ce:italic>
							</ce:inf> is applied to sensor readings of the region 
							<ce:italic>Q</ce:italic>. Let the selectivity of 
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>Q</ce:italic>
							</ce:inf> be 
							<ce:italic>sel</ce:italic>(
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>Q</ce:italic>
							</ce:inf>) which is the proportion of sensor readings that satisfy the selection operation. Note that 
							<ce:italic>sel</ce:italic>(
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>Q</ce:italic>
							</ce:inf>) of a node which is not in the region 
							<ce:italic>Q</ce:italic> is zero.
						</ce:para>
						<ce:para id="p0210" view="all">Let the size of a sensor reading be 
							<ce:italic>r</ce:italic>. Then, when the node 
							<ce:italic>s</ce:italic> transmits a message, the transmission cost to a neighbor, 
							<ce:italic>T</ce:italic>(
							<ce:italic>s</ce:italic>) (i.e., the average size of a message) can be expressed by Eq. 
							<ce:cross-ref refid="e0005">(1)</ce:cross-ref>.
							<ce:display>
								<ce:formula id="e0005">
									<ce:label>(1)</ce:label>
									<mml:math altimg="si4.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>s</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:mi>r</mml:mi>
										<mml:mo>·</mml:mo>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mo>∑</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>c</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi mathvariant="italic">child</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>s</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:munder>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>Using the transmission cost 
							<ce:italic>T</ce:italic>(), we can compute the cost to send all readings in region 
							<ce:italic>Q</ce:italic> to the node 
							<ce:italic>d</ce:italic>. As mentioned earlier, the node 
							<ce:italic>s</ce:italic>(=
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>)) gathers the sensor readings in 
							<ce:italic>Q</ce:italic> and 
							<ce:italic>s</ce:italic> transmits the gathered readings to 
							<ce:italic>d</ce:italic>. Thus, the cost is computed as follows:
							<ce:display>
								<ce:formula id="e0010">
									<ce:label>(2)</ce:label>
									<mml:math altimg="si5.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mi mathvariant="italic">Cost</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>Q</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>d</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>s</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">sending</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>s</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>d</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>To gather the sensor readings at the node 
							<ce:italic>s</ce:italic>, the children of 
							<ce:italic>s</ce:italic> gather sensor readings from their descendants and send gathered readings to 
							<ce:italic>s</ce:italic>. Thus, 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>gathering</ce:italic>
							</ce:inf>(
							<ce:italic>s</ce:italic>) is expressed recursively as follows:
							<ce:display>
								<ce:formula id="e0075">
									<mml:math altimg="si6.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>s</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mo>∑</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>c</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi mathvariant="italic">child</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>s</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:munder>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>When the node 
							<ce:italic>s</ce:italic> transmits data to its ancestors, the transmission costs 
							<ce:italic>T</ce:italic>() of 
							<ce:italic>s</ce:italic>′ ancestors are equal to that of 
							<ce:italic>s</ce:italic>. Thus, the transmission cost from 
							<ce:italic>s</ce:italic> to 
							<ce:italic>d</ce:italic> is expressed as follows, where 
							<ce:italic>hopDiff</ce:italic>(
							<ce:italic>s</ce:italic>,
							<ce:hsp sp="0.12"/>
							<ce:italic>d</ce:italic>) denotes the difference of hop distances between 
							<ce:italic>s</ce:italic> and 
							<ce:italic>d</ce:italic>:
							<ce:display>
								<ce:formula id="e0080">
									<mml:math altimg="si7.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">sending</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>s</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>d</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:mi mathvariant="italic">hopDiff</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>s</mml:mi>
										<mml:mtext>,</mml:mtext>
										<mml:mi>d</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>s</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>Based on Eq. 
							<ce:cross-ref refid="e0010">(2)</ce:cross-ref>, we can derive the cost models of three basic join plans. Suppose that, as shown in 
							<ce:cross-ref refid="f0025">Fig. 5</ce:cross-ref>
							<ce:float-anchor refid="f0025"/>, the difference of hop distances from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>) to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), that from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), as well as that from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to the base station are 
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>, 
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf> and 
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>C</ce:italic>
							</ce:inf>, respectively.
						</ce:para>
						<ce:para id="p0215" view="all">In 
							<ce:italic>baseJoin</ce:italic>, the sensor readings in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> and 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf> are gathered at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>) and 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), respectively. Two gathered data sets move to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). The node 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) sends the data sets came from two nodes to the base station. Thus, the cost of 
							<ce:italic>baseJoin cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>base</ce:italic>
							</ce:inf>() can be derived as follows:
							<ce:display>
								<ce:formula id="e0015">
									<ce:label>(3)</ce:label>
									<mml:math altimg="si8.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">base</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>In 
							<ce:italic>coverJoin</ce:italic>, like 
							<ce:italic>baseJoin</ce:italic>, the sensors in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> and 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf> send data to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>) and 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) as well as the gathered data is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). However, in contrast to the 
							<ce:italic>baseJoin</ce:italic> plan, as shown in 
							<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>(b), semijoin operations are performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0220" view="all">In order to compute the transmission cost from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to the base station, we compute the size of 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic> and the size of 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>. The join selectivity of a semijoin of 
							<ce:italic>L</ce:italic> by 
							<ce:italic>R</ce:italic> gives the fraction of tuples of 
							<ce:italic>L</ce:italic> which join with tuples of 
							<ce:italic>R</ce:italic>. Accurate estimation of the join selectivity is important since the effective join plan is based on the join selectivity. It is difficult to accurately estimate the join selectivity. But, an approximation for the semijoin selectivity was suggested in 
							<ce:cross-ref refid="b0050">[10]</ce:cross-ref> as follows:
							<ce:display>
								<ce:formula id="e0020">
									<ce:label>(4)</ce:label>
									<mml:math altimg="si9.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mi mathvariant="italic">SJS</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>R</mml:mi>
										<mml:msub>
											<mml:mrow>
												<mml:mi>⋉</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mi>L</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:mfrac>
											<mml:mrow>
												<mml:mi mathvariant="italic">size</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Π</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>A</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>L</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">size</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi mathvariant="italic">dom</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>A</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:mfrac>
										<mml:mtext>,where</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:mi mathvariant="italic">dom</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>A</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mspace width="0.35em"/>
										<mml:mtext>is the domain of attribute</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:mi>A</mml:mi>
										<mml:mtext>.</mml:mtext>
									</mml:math>
								</ce:formula>
							</ce:display>In the above equation, the semijoin selectivity 
							<ce:italic>SJS</ce:italic>(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>) is only affected by the size of the join column 
							<ce:italic>A</ce:italic> of 
							<ce:italic>L</ce:italic>. Thus, when the size of the gathered sensor readings in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf> at a certain time is 
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>)), the size of semijoin result is 
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>))
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>). We use 
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf> to denote 
							<ce:italic>SJS</ce:italic>(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>) concisely. Using the semijoin selectivities 
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf> and 
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>, where the join attributes of 
							<ce:italic>R</ce:italic> and 
							<ce:italic>L</ce:italic> are 
							<ce:italic>A</ce:italic>, we can obtain the size of data generated at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0225" view="all">The cost of 
							<ce:italic>coverJoin</ce:italic>, 
							<ce:italic>cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>cover</ce:italic>
							</ce:inf>() is estimated as follows:
							<ce:display>
								<ce:formula id="e0025">
									<ce:label>(5)</ce:label>
									<mml:math altimg="si10.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">cover</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>In the 
							<ce:italic>sideJoin</ce:italic> plan, like the other join plans, all sensor readings are gathered at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>) and 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). But, unlike the other join plans, the join column 
							<ce:italic>A</ce:italic> of 
							<ce:italic>L</ce:italic> is sent to the 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) in order to perform 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>.
						</ce:para>
						<ce:para id="p0230" view="all">Since, from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>) to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), the gathered data is sent, the transmission cost 
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>)) is required.
						</ce:para>
						<ce:para id="p0235" view="all">And then, the projection result of the gathered sensor readings on the join attribute is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). In order to make the cost model concise, following the general convention, we simply assume that the cardinality of a projected result is equal to the cardinality of the original relation. Therefore, the transmission cost is reduced to 
							<mml:math altimg="si11.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:mi>T</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="italic">cov</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">min</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>Q</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>L</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>·</mml:mo>
									<mml:mfrac>
										<mml:mrow>
											<mml:mi>j</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>r</mml:mi>
										</mml:mrow>
									</mml:mfrac>
								</mml:mrow>
							</mml:math>, where 
							<ce:italic>j</ce:italic> is the size of a join column and 
							<ce:italic>r</ce:italic> is the size of a sensor reading. So, the transmission cost of a join column of 
							<ce:italic>L</ce:italic> to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) (= 
							<mml:math altimg="si12.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi>D</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>R</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo>·</mml:mo>
									<mml:mi>T</mml:mi>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="italic">cov</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">min</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>Q</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>L</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>·</mml:mo>
									<mml:mfrac>
										<mml:mrow>
											<mml:mi>j</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>r</mml:mi>
										</mml:mrow>
									</mml:mfrac>
								</mml:mrow>
							</mml:math>) is required in 
							<ce:italic>sideJoin</ce:italic>.
						</ce:para>
						<ce:para id="p0240" view="all">And, as shown in 
							<ce:cross-ref refid="f0015">Fig. 3</ce:cross-ref>(c), the semijoin 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> is performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) and the semijoin result is sent back to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). As shown in the cost of 
							<ce:italic>coverJoin</ce:italic> (Eq. 
							<ce:cross-ref refid="e0025">(5)</ce:cross-ref>), we can obtain the size of the semijoin result using the join selectivity. The size of the semijoin 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> is 
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>))
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>. Thus, the transmission cost of the semijoin result from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) is 
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>))
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>.
						</ce:para>
						<ce:para id="p0245" view="all">Finally, at the node 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), the semijoin 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic> (=
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>)) is performed and the two semijoin results are sent to the base station. This transmission cost is 
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>C</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>(
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>))
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>+
							<ce:hsp sp="0.25"/>
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>))
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>). Therefore, the cost of 
							<ce:italic>sideJoin</ce:italic>, 
							<ce:italic>cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>side</ce:italic>
							</ce:inf>(), is derived as follows:
							<ce:display>
								<ce:formula id="e0030">
									<ce:label>(6)</ce:label>
									<mml:math altimg="si13.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">side</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:mfrac>
											<mml:mrow>
												<mml:mi>j</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>r</mml:mi>
											</mml:mrow>
										</mml:mfrac>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0030" view="all">
					<ce:label>4</ce:label>
					<ce:section-title>Enhanced join plans</ce:section-title>
					<ce:para id="p0250" view="all">In this section, we present other join plans called 
						<ce:italic>partitionJoin</ce:italic> and 
						<ce:italic>synopsisJoin</ce:italic> exploiting hierarchical structures (i.e., tree routing). Even though semijoin and synopsis join approaches are well known in distributed databases (i.e., a flat structure), our work is more general than the previous join approaches for distributed databases. In addition, to choose optimal join locations for 
						<ce:italic>partitionJoin</ce:italic> and 
						<ce:italic>synopsisJoin</ce:italic>, we devise a recursive expression for dynamic programming and its greedy version.
					</ce:para>
					<ce:section id="s0035" view="all">
						<ce:label>4.1</ce:label>
						<ce:section-title>Partition join</ce:section-title>
						<ce:para id="p0255" view="all">In 
							<ce:italic>coverJoin</ce:italic> and 
							<ce:italic>sideJoin</ce:italic> plans, semijoins are performed at one or two nodes. However, in the 
							<ce:italic>partitionJoin</ce:italic> plan, semijoin operations are performed at several nodes.
						</ce:para>
						<ce:para id="p0260" view="all">The basic intuition of 
							<ce:italic>partitionJoin</ce:italic> is that ⋃
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>, where ⋃
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic>. For general join operators, the intuition also holds.
						</ce:para>
						<ce:para id="p0265" view="all">As shown in 
							<ce:cross-ref refid="f0030">Fig. 6</ce:cross-ref>
							<ce:float-anchor refid="f0030"/>, a query region 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf> can be partitioned into several subregions. Each subregion can be obtained using the following definition.
							<ce:enunciation id="n0020">
								<ce:label>Definition 4</ce:label>
								<ce:para id="p0800" view="all">A subregion of a query region 
									<ce:italic>Q</ce:italic>
									<ce:inf loc="post">
										<ce:italic>R</ce:italic>
									</ce:inf> is an element in a set {
									<mml:math altimg="si14.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>Q</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:msub>
														<mml:mrow>
															<mml:mi>R</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mn>1</mml:mn>
														</mml:mrow>
													</mml:msub>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:math>, 
									<mml:math altimg="si15.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>Q</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:msub>
														<mml:mrow>
															<mml:mi>R</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mn>2</mml:mn>
														</mml:mrow>
													</mml:msub>
												</mml:mrow>
											</mml:msub>
											<mml:mtext>,</mml:mtext>
											<mml:mo>…</mml:mo>
											<mml:mtext>,</mml:mtext>
											<mml:msub>
												<mml:mrow>
													<mml:mi>Q</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:msub>
														<mml:mrow>
															<mml:mi>R</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>n</mml:mi>
														</mml:mrow>
													</mml:msub>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:math>} such that, for each 
									<ce:italic>c</ce:italic>
									<ce:hsp sp="0.25"/>∈
									<ce:hsp sp="0.25"/>
									<ce:italic>child</ce:italic>(
									<ce:italic>cov</ce:italic>
									<ce:inf loc="post">
										<ce:italic>min</ce:italic>
									</ce:inf>(
									<ce:italic>Q</ce:italic>
									<ce:inf loc="post">
										<ce:italic>R</ce:italic>
									</ce:inf>)), 
									<mml:math altimg="si16.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>Q</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:msub>
														<mml:mrow>
															<mml:mi>R</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>c</mml:mi>
														</mml:mrow>
													</mml:msub>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:math>
									<ce:hsp sp="0.25"/>=
									<ce:hsp sp="0.25"/>
									<ce:italic>SR</ce:italic>(
									<ce:italic>c</ce:italic>)
									<ce:hsp sp="0.25"/>⋂
									<ce:hsp sp="0.25"/>
									<ce:italic>Q</ce:italic>
									<ce:inf loc="post">
										<ce:italic>R</ce:italic>
									</ce:inf>, where 
									<mml:math altimg="si17.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>Q</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:msub>
														<mml:mrow>
															<mml:mi>R</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>c</mml:mi>
														</mml:mrow>
													</mml:msub>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:math>
									<ce:hsp sp="0.25"/>≠
									<ce:hsp sp="0.25"/>∅.
								</ce:para>
							</ce:enunciation>
						</ce:para>
						<ce:para id="p0270" view="all">An example of 
							<ce:italic>partitionJoin</ce:italic> is described in 
							<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>
							<ce:float-anchor refid="f0035"/>. Since the node 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) gathers sensor readings from 
							<mml:math altimg="si18.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi>Q</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>R</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>c</mml:mi>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math>, the semijoin 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> can be performed at 
							<ce:italic>c</ce:italic> or 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0275" view="all">Thus, the problem of 
							<ce:italic>partitionJoin</ce:italic> is to choose the set of child nodes which perform semijoin operations. This problem is recursively applied to the descendants of 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) since 
							<ce:italic>partitionJoin</ce:italic> can be applied to a subregion 
							<mml:math altimg="si19.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi>Q</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>R</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>c</mml:mi>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math>. For example, as shown in 
							<ce:cross-ref refid="f0035">Fig. 7</ce:cross-ref>, the nodes 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">1</ce:inf> and 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">2</ce:inf> receive 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) and return 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">1</ce:inf>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> and 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">2</ce:inf>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>, respectively. But, 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">3</ce:inf> just sends 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">3</ce:inf>. Thus, 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">3</ce:inf> ⋉ L is performed at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). Note that, 
							<ce:italic>partitionJoin</ce:italic> can be recursively applied to children of 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">1</ce:inf> and 
							<ce:italic>s</ce:italic>
							<ce:inf loc="post">2</ce:inf>.
						</ce:para>
						<ce:para id="p0280" view="all">Let 
							<ce:italic>cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partition</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>, 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) be the cost of the 
							<ce:italic>partitionJoin</ce:italic> plan. Like 
							<ce:italic>sideJoin</ce:italic>, the join column of 
							<ce:italic>L</ce:italic> is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) and the semijoin result of 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> is transmitted to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) in 
							<ce:italic>partitionJoin</ce:italic>. However, in contrast to 
							<ce:italic>sideJoin</ce:italic>, the join column of 
							<ce:italic>L</ce:italic> moves down to child nodes of 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). And, some child nodes whose 
							<ce:italic>SR</ce:italic>() s cover 
							<mml:math altimg="si20.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi>Q</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>R</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>i</mml:mi>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math> generate the result of 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> but the other child nodes simply return their gathered readings. Thus, the cost 
							<ce:italic>cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partition</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>, 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) is derived as follows:
							<ce:display>
								<ce:formula id="e0035">
									<ce:label>(7)</ce:label>
									<mml:math altimg="si21.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">partition</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">partial</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:mfrac>
											<mml:mrow>
												<mml:mi>j</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>r</mml:mi>
											</mml:mrow>
										</mml:mfrac>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>C</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>The term 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partial</ce:italic>
							</ce:inf>() is used in 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partition</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>,
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) instead of 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>gathering</ce:italic>
							</ce:inf>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>)) in 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>side</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>, 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0285" view="all">When a node sends a message to another node, the receiving node consumes energy to receive the message. The receiving cost is generally proportional to the sending cost.
							<ce:footnote id="fn1">
								<ce:label>1</ce:label>
								<ce:note-para>In 
									<ce:cross-ref refid="b0090">[18]</ce:cross-ref>, the authors say that the receiving cost is generally 60% less than the sending cost.
								</ce:note-para>
							</ce:footnote>
							<ce:cross-ref refid="fn1">
								<ce:sup loc="post">1</ce:sup>
							</ce:cross-ref> Here, we use 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>s</ce:italic>
							</ce:inf>() and 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>r</ce:italic>
							</ce:inf>() in 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partial</ce:italic>
							</ce:inf>() instead of 
							<ce:italic>T</ce:italic>() since, by broadcasting from a parent, several children receive a message in WSN environments.
						</ce:para>
						<ce:para id="p0290" view="all">The term 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partial</ce:italic>
							</ce:inf>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>), 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>)) is as follows:
							<ce:display>
								<ce:formula id="e0040">
									<ce:label>(8)</ce:label>
									<mml:math altimg="si22.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">partial</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>C</mml:mi>
												<mml:mo>⊆</mml:mo>
												<mml:mi mathvariant="italic">qchild</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="italic">cov</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">min</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:msub>
										<mml:mrow>
											<mml:mfenced open="{" close="}">
												<mml:mrow>
													<mml:msub>
														<mml:mrow>
															<mml:mi>T</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>s</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="italic">cov</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">min</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>Q</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>L</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>·</mml:mo>
													<mml:mfrac>
														<mml:mrow>
															<mml:mi>j</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>r</mml:mi>
														</mml:mrow>
													</mml:mfrac>
													<mml:mo>+</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mo>∑</mml:mo>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>c</mml:mi>
															<mml:mo>∈</mml:mo>
															<mml:mi>C</mml:mi>
														</mml:mrow>
													</mml:munder>
													<mml:msub>
														<mml:mrow>
															<mml:mi>T</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>r</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="italic">cov</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">min</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>Q</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>L</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>·</mml:mo>
													<mml:mfrac>
														<mml:mrow>
															<mml:mi>j</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>r</mml:mi>
														</mml:mrow>
													</mml:mfrac>
													<mml:mo>+</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mo>∑</mml:mo>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>c</mml:mi>
															<mml:mo>∈</mml:mo>
															<mml:mi>C</mml:mi>
														</mml:mrow>
													</mml:munder>
													<mml:mi>T</mml:mi>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:mi>c</mml:mi>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>·</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="italic">SJS</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>L</mml:mi>
															<mml:mo>.</mml:mo>
															<mml:mi>A</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo>+</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mo>∑</mml:mo>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>c</mml:mi>
															<mml:mo>∈</mml:mo>
															<mml:mi>C</mml:mi>
														</mml:mrow>
													</mml:munder>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="italic">Cost</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">partial</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="italic">cov</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">min</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi>Q</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi>L</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mtext>,</mml:mtext>
													<mml:mi>c</mml:mi>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>+</mml:mo>
													<mml:munder>
														<mml:mrow>
															<mml:mo>∑</mml:mo>
														</mml:mrow>
														<mml:mrow>
															<mml:msup>
																<mml:mrow>
																	<mml:mi>c</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mo>′</mml:mo>
																</mml:mrow>
															</mml:msup>
															<mml:mo>∈</mml:mo>
															<mml:mi mathvariant="italic">qchild</mml:mi>
															<mml:mo stretchy="false">(</mml:mo>
															<mml:msub>
																<mml:mrow>
																	<mml:mi mathvariant="italic">cov</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi mathvariant="italic">min</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo stretchy="false">(</mml:mo>
															<mml:msub>
																<mml:mrow>
																	<mml:mi>Q</mml:mi>
																</mml:mrow>
																<mml:mrow>
																	<mml:mi>R</mml:mi>
																</mml:mrow>
															</mml:msub>
															<mml:mo stretchy="false">)</mml:mo>
															<mml:mo stretchy="false">)</mml:mo>
															<mml:mo>-</mml:mo>
															<mml:mi>C</mml:mi>
														</mml:mrow>
													</mml:munder>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msub>
														<mml:mrow>
															<mml:mi mathvariant="italic">Cost</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mi mathvariant="italic">gathering</mml:mi>
														</mml:mrow>
													</mml:msub>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msup>
														<mml:mrow>
															<mml:mi>c</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mo>′</mml:mo>
														</mml:mrow>
													</mml:msup>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo>+</mml:mo>
													<mml:mi>T</mml:mi>
													<mml:mo stretchy="false">(</mml:mo>
													<mml:msup>
														<mml:mrow>
															<mml:mi>c</mml:mi>
														</mml:mrow>
														<mml:mrow>
															<mml:mo>′</mml:mo>
														</mml:mrow>
													</mml:msup>
													<mml:mo stretchy="false">)</mml:mo>
													<mml:mo stretchy="false">)</mml:mo>
												</mml:mrow>
											</mml:mfenced>
										</mml:mrow>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:mtext>where</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:mi mathvariant="italic">qchild</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mspace width="0.35em"/>
										<mml:mtext>is a set of children whose</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:mi mathvariant="italic">SR</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mspace width="0.35em"/>
										<mml:mtext>overlap with</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mspace width="0.35em"/>
										<mml:mtext>and</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>s</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mspace width="0.35em"/>
										<mml:mtext>if</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:mi>C</mml:mi>
										<mml:mo>=</mml:mo>
										<mml:mo>∅</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>In 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partial</ce:italic>
							</ce:inf>(), a subset 
							<ce:italic>C</ce:italic> of 
							<ce:italic>qchild</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>)) is the set of nodes which generate the results of semijoins. To do this, 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) is sent to 
							<ce:italic>C</ce:italic>. Its cost is 
							<mml:math altimg="si23.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi>T</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>s</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="italic">cov</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">min</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>Q</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>L</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>·</mml:mo>
									<mml:mfrac>
										<mml:mrow>
											<mml:mi>j</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>r</mml:mi>
										</mml:mrow>
									</mml:mfrac>
								</mml:mrow>
							</mml:math>. Then, all nodes in 
							<ce:italic>C</ce:italic> receive 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>). The cost is 
							<mml:math altimg="si24.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mo>∑</mml:mo>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>c</mml:mi>
											<mml:mo>∈</mml:mo>
											<mml:mi>C</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:msub>
										<mml:mrow>
											<mml:mi>T</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>r</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="italic">cov</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi mathvariant="italic">min</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">(</mml:mo>
									<mml:msub>
										<mml:mrow>
											<mml:mi>Q</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>L</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo stretchy="false">)</mml:mo>
									<mml:mo>·</mml:mo>
									<mml:mfrac>
										<mml:mrow>
											<mml:mi>j</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>r</mml:mi>
										</mml:mrow>
									</mml:mfrac>
								</mml:mrow>
							</mml:math>.
						</ce:para>
						<ce:para id="p0295" view="all">The transmission cost of 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> from 
							<ce:italic>c</ce:italic>
							<ce:hsp sp="0.25"/>∈
							<ce:hsp sp="0.25"/>
							<ce:italic>C</ce:italic> is 
							<ce:italic>T</ce:italic>(
							<ce:italic>c</ce:italic>)
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>. Since 
							<ce:italic>partitionJoin</ce:italic> is applied recursively to 
							<ce:italic>c</ce:italic>, 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partial</ce:italic>
							</ce:inf>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>), 
							<ce:italic>c</ce:italic>) represents this recursion. Also, since a child 
							<ce:italic>c</ce:italic>′, which does not perform a semijoin, simply gathers sensor readings of descendants and transmits to its parent, the term (
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>gathering</ce:italic>
							</ce:inf>(
							<ce:italic>c</ce:italic>′)
							<ce:hsp sp="0.25"/>+
							<ce:hsp sp="0.25"/>
							<ce:italic>T</ce:italic>(
							<ce:italic>c</ce:italic>′)) is used.
						</ce:para>
						<ce:para id="p0300" view="all">If 
							<ce:italic>C</ce:italic> is empty, 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>s</ce:italic>
							</ce:inf>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>))
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>0 since 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) does not need to be transmitted to the children. Note that, if it is beneficial that 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) does not transmit 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) to child nodes, 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partition</ce:italic>
							</ce:inf>() is equal to 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>side</ce:italic>
							</ce:inf>(). Therefore, 
							<ce:italic>sideJoin</ce:italic> is a specific plan of 
							<ce:italic>partitionJoin</ce:italic>.
						</ce:para>
						<ce:para id="p0305" view="all">In the optimal plan obtained from the above recursive expression in Eq. 
							<ce:cross-ref refid="e0040">(8)</ce:cross-ref>, each child has the optimal plan. In other words, the principle of optimality holds. Thus, dynamic programming can be applied to find the optimal join plan. The time complexity of dynamic programming is O(2
							<ce:sup loc="post">
								<ce:italic>n</ce:italic>
							</ce:sup>), where 
							<ce:italic>n</ce:italic> is the number of descendant nodes of 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), since all subsets of descendants are evaluated.
						</ce:para>
						<ce:para id="p0310" view="all">In order to reduce the time complexity, we devise a greedy method. 
							<ce:cross-ref refid="f0040">Fig. 8</ce:cross-ref>
							<ce:float-anchor refid="f0040"/> shows a greedy algorithm for 
							<ce:italic>partitionJoin</ce:italic>. This algorithm traverses the subtree of 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) in a breadth-first traversal manner.
						</ce:para>
						<ce:para id="p0315" view="all">The procedure 
							<ce:italic>compute</ce:italic>_
							<ce:italic>partial()</ce:italic> performs the following:
							<ce:list id="l0010">
								<ce:list-item id="o0025">
									<ce:label>•</ce:label>
									<ce:para id="p0710" view="all">Candidate children which may generate the semijoin results are computed (Lines 7–14). If a child node 
										<ce:italic>c</ce:italic>
										<ce:hsp sp="0.25"/>∈
										<ce:hsp sp="0.25"/>
										<ce:italic>qchild</ce:italic>() generates the semijoin result, 
										<ce:italic>c</ce:italic> receives 
										<ce:italic>Π</ce:italic>
										<ce:inf loc="post">
											<ce:italic>A</ce:italic>
										</ce:inf>(
										<ce:italic>L</ce:italic>) and returns the result of 
										<ce:italic>R</ce:italic>
										<ce:inf loc="post">
											<ce:italic>c</ce:italic>
										</ce:inf>
										<ce:hsp sp="0.25"/>⋉
										<ce:hsp sp="0.25"/>
										<ce:italic>L</ce:italic>. Thus, if the transmission cost 
										<ce:italic>T</ce:italic>(
										<ce:italic>c</ce:italic>) is greater than the sum of the receiving cost of 
										<ce:italic>Π</ce:italic>
										<ce:inf loc="post">
											<ce:italic>A</ce:italic>
										</ce:inf>(
										<ce:italic>L</ce:italic>) and the transmission cost of the semijoin result (Line 8), it may be beneficial that the semijoin is performed at 
										<ce:italic>c</ce:italic>. If 
										<ce:italic>c</ce:italic> is a candidate, the cost sums up as 
										<ce:italic>cost</ce:italic>
										<ce:inf loc="post">
											<ce:italic>C</ce:italic>
										</ce:inf> (Line 10).
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0030">
									<ce:label>•</ce:label>
									<ce:para id="p0715" view="all">Children for generating the semijoin results are computed (Line 15–21). In order to perform semijoins at a subset 
										<ce:italic>C</ce:italic>, a parent node (i.e., aNode) sends 
										<ce:italic>Π</ce:italic>
										<ce:inf loc="post">
											<ce:italic>A</ce:italic>
										</ce:inf>(
										<ce:italic>L</ce:italic>). Thus, when the benefit (= 
										<mml:math altimg="si25.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mo>∑</mml:mo>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>c</mml:mi>
														<mml:mo>∈</mml:mo>
														<mml:mi>C</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mi>T</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>c</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>-</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="italic">cost</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>C</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:math>) is greater than 
										<mml:math altimg="si26.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>T</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>s</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="italic">cov</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">min</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>L</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>·</mml:mo>
												<mml:mfrac>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>r</mml:mi>
													</mml:mrow>
												</mml:mfrac>
											</mml:mrow>
										</mml:math>, doing semijoins at 
										<ce:italic>C</ce:italic> is efficient (Line 15). If it is beneficial to perform the semijoins at 
										<ce:italic>C</ce:italic>, we can further consider the children of 
										<ce:italic>C</ce:italic> (Line 16). The time complexity of our algorithm is O(
										<ce:italic>n</ce:italic>) since the algorithm traverses child nodes in the breadth first traversal manner.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0035">
									<ce:label>•</ce:label>
									<ce:para id="p0720" view="all">
										<ce:italic>Cost</ce:italic>
										<ce:inf loc="post">
											<ce:italic>partial</ce:italic>
										</ce:inf>(
										<ce:italic>cov</ce:italic>
										<ce:inf loc="post">
											<ce:italic>min</ce:italic>
										</ce:inf>(
										<ce:italic>Q</ce:italic>
										<ce:inf loc="post">
											<ce:italic>L</ce:italic>
										</ce:inf>), 
										<ce:italic>cov</ce:italic>
										<ce:inf loc="post">
											<ce:italic>min</ce:italic>
										</ce:inf>(
										<ce:italic>Q</ce:italic>
										<ce:inf loc="post">
											<ce:italic>R</ce:italic>
										</ce:inf>)) based on the heuristic is computed as 
										<ce:italic>Cost</ce:italic>
										<ce:inf loc="post">
											<ce:italic>partial</ce:italic>
										</ce:inf> (Lines 3–22). 
										<ce:italic>Cost</ce:italic>
										<ce:inf loc="post">
											<ce:italic>partial</ce:italic>
										</ce:inf> is initialized by 0 (Line 3). If it is beneficial to perform semijoins at 
										<ce:italic>C</ce:italic> (Line 15), 
										<ce:italic>Cost</ce:italic>
										<ce:inf loc="post">
											<ce:italic>partial</ce:italic>
										</ce:inf> is added to the sending cost from parent to 
										<ce:italic>C</ce:italic> (=
										<mml:math altimg="si27.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
											<mml:mrow>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>T</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>s</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="italic">cov</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">min</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>L</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>·</mml:mo>
												<mml:mfrac>
													<mml:mrow>
														<mml:mi>j</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>r</mml:mi>
													</mml:mrow>
												</mml:mfrac>
											</mml:mrow>
										</mml:math>) and 
										<ce:italic>cost</ce:italic>
										<ce:inf loc="post">
											<ce:italic>C</ce:italic>
										</ce:inf> (Line 17). If it is not beneficial to perform a semijoin at a child 
										<ce:italic>c</ce:italic>, 
										<ce:italic>Cost</ce:italic>
										<ce:inf loc="post">
											<ce:italic>partial</ce:italic>
										</ce:inf> is added to 
										<ce:italic>Cost</ce:italic>
										<ce:inf loc="post">
											<ce:italic>gathering</ce:italic>
										</ce:inf>(
										<ce:italic>c</ce:italic>) and 
										<ce:italic>T</ce:italic>(
										<ce:italic>c</ce:italic>) (Lines 12, 20).
									</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
						<ce:para id="p0320" view="all">Thus, the query optimizer can choose the best plan between 
							<ce:italic>partitionJoin</ce:italic> and 
							<ce:italic>sideJoin</ce:italic> by the comparison of 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>partial</ce:italic>
							</ce:inf> and 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>gathering</ce:italic>
							</ce:inf> (
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>)).
						</ce:para>
					</ce:section>
					<ce:section id="s0040" view="all">
						<ce:label>4.2</ce:label>
						<ce:section-title>Synopsis join</ce:section-title>
						<ce:para id="p0325" view="all">In 
							<ce:italic>partitionJoin</ce:italic> presented in Section 
							<ce:cross-ref refid="s0035">4.1</ce:cross-ref>, the transmission cost for 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) is a key factor to apply 
							<ce:italic>partitionJoin</ce:italic>. Thus, if we can reduce this cost, a more efficient join plan can be obtained.
						</ce:para>
						<ce:para id="p0330" view="all">A synopsis is a summary of a relation. By using a synopsis, we may reduce this cost. We call this method 
							<ce:italic>synopsisJoin</ce:italic>. In our work, with respect to the join condition, different synopses are used.
						</ce:para>
						<ce:para id="p0335" view="all">As mentioned in 
							<ce:cross-ref refid="b0110">[22]</ce:cross-ref>, when a join is not an equi-join, sending the min (or max) value is sufficient to perform a join. For example, if a join condition is 
							<ce:italic>L</ce:italic>.
							<ce:italic>A</ce:italic>
							<ce:hsp sp="0.25"/>&lt;
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic>.
							<ce:italic>A</ce:italic>, the minimum value of 
							<ce:italic>L</ce:italic>.
							<ce:italic>A</ce:italic> is only required to perform 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> since all tuples in 
							<ce:italic>R</ce:italic> with 
							<ce:italic>R</ce:italic>.
							<ce:italic>A</ce:italic> values greater than the minimum value of 
							<ce:italic>L</ce:italic>.
							<ce:italic>A</ce:italic> participate in a join operation.
						</ce:para>
						<ce:para id="p0340" view="all">For an equi-join, we use the bloom filter 
							<ce:cross-ref refid="b0015">[3]</ce:cross-ref>. The bloom filter consists of an array of 
							<ce:italic>m</ce:italic> bits and a set of 
							<ce:italic>k</ce:italic> independent hash functions each of which maps an element to an integer in the range of [1, 
							<ce:italic>m</ce:italic>]. An element in a set is represented in the bloom filter by setting all positions, computed by hash functions, of the bit array to 1. We can check a membership using the bloom filter. Suppose that the bloom filter is constructed using a set of attribute values of 
							<ce:italic>L</ce:italic>.
							<ce:italic>A</ce:italic>. If at least one of the positions related to an attribute value of the array is 0, the attribute value is not a member. Thus, by using the membership checking feature of the bloom filter, an equi-join is performed without the original relation. There can be some false positives associated with using the bloom filter, however they are not significant.
						</ce:para>
						<ce:para id="p0345" view="all">
							<ce:italic>synopsisJoin</ce:italic> is divided into two specific plans: 
							<ce:italic>synopsisJoin</ce:italic> and a variant called 
							<ce:italic>fullsynopsisJoin</ce:italic>.
						</ce:para>
						<ce:para id="p0350" view="all">The 
							<ce:italic>synopsisJoin</ce:italic> plan is similar to 
							<ce:italic>partitionJoin</ce:italic> except that a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) is sent from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0355" view="all">In the previous plans, the size of data to be transmitted is computed. But, since the fixed sized synopsis is transmitted, a difference model is required.</ce:para>
						<ce:para id="p0360" view="all">In 
							<ce:italic>synopsisJoin</ce:italic>, 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) may not send a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) if 
							<ce:italic>L</ce:italic> does not come from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>). Let 
							<ce:italic>m</ce:italic> be the size of a synopsis and 
							<ce:italic>P</ce:italic>(
							<ce:italic>s</ce:italic>) be the probability that a node 
							<ce:italic>s</ce:italic> transmits data.
						</ce:para>
						<ce:para id="p0365" view="all">Then, 
							<ce:italic>P</ce:italic>(
							<ce:italic>s</ce:italic>)
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>1
							<ce:hsp sp="0.25"/>−
							<ce:hsp sp="0.25"/>Prob (node 
							<ce:italic>s</ce:italic> does not transmit data). The transmission probability 
							<ce:italic>P</ce:italic>() is determined by a query region and the selectivity of a selection predicate. In 
							<ce:cross-ref refid="f0020">Fig. 4</ce:cross-ref>, in order for 
							<ce:italic>s</ce:italic> not to transmit data, the sensor reading of the node 
							<ce:italic>s</ce:italic> does not satisfy the selection condition 
							<ce:italic>P</ce:italic>
							<ce:inf loc="post">
								<ce:italic>Q</ce:italic>
							</ce:inf> as well as all children of 
							<ce:italic>s</ce:italic> do not transmit data to 
							<ce:italic>s</ce:italic>. Therefore, 
							<ce:italic>P</ce:italic>(
							<ce:italic>s</ce:italic>) can be expressed by Eq. 
							<ce:cross-ref refid="e0045">(9)</ce:cross-ref>.
							<ce:display>
								<ce:formula id="e0045">
									<ce:label>(9)</ce:label>
									<mml:math altimg="si28.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:mi>P</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>s</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo>-</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo>-</mml:mo>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mi>∏</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>c</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi mathvariant="italic">child</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:mi>s</mml:mi>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:munder>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mn>1</mml:mn>
										<mml:mo>-</mml:mo>
										<mml:mi>P</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>So, the average transmission cost for a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>), 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>sysL</ce:italic>
							</ce:inf>, is derived as follows:
							<ce:display>
								<ce:formula id="e0050">
									<ce:label>(10)</ce:label>
									<mml:math altimg="si29.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">sysL</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mi>m</mml:mi>
										<mml:mo>·</mml:mo>
										<mml:mi>P</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>Therefore, 
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>sysL</ce:italic>
							</ce:inf> is the synopsis transmission cost from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0370" view="all">And then, similar to 
							<ce:italic>partitionJoin</ce:italic>, a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) is propagated to descendants of 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to perform semijoins. This cost is derived as Eq. 
							<ce:cross-ref refid="e0055">(11)</ce:cross-ref>. 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>sysL</ce:italic>,
								<ce:italic>s</ce:italic>
							</ce:inf> and 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>sysL</ce:italic>,
								<ce:italic>r</ce:italic>
							</ce:inf> are the sending and receiving cost of a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>), respectively. Additionally, in 
							<ce:cross-ref refid="f0040">Fig. 8</ce:cross-ref>, 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>r</ce:italic>
							</ce:inf>, and 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>s</ce:italic>
							</ce:inf> at Lines 8, 10, 15, and 17 are replaced with 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>sysL</ce:italic>,
								<ce:italic>r</ce:italic>
							</ce:inf> and 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>sysL</ce:italic>,
								<ce:italic>s</ce:italic>
							</ce:inf>, respectively, for the greedy algorithm of 
							<ce:italic>synopsisJoin</ce:italic>.
							<ce:display>
								<ce:formula id="e0055">
									<ce:label>(11)</ce:label>
									<mml:math altimg="si30.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">partial</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi mathvariant="italic">synopsis</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>C</mml:mi>
												<mml:mo>⊆</mml:mo>
												<mml:mi mathvariant="italic">qchild</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="italic">cov</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">min</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">{</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">sysL</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi>s</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mo>∑</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>c</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi>C</mml:mi>
											</mml:mrow>
										</mml:munder>
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">sysL</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi>r</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mo>∑</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>c</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi>C</mml:mi>
											</mml:mrow>
										</mml:munder>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mo>∑</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>c</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi>C</mml:mi>
											</mml:mrow>
										</mml:munder>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">partial</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi mathvariant="italic">synopsis</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mo>∑</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:msup>
													<mml:mrow>
														<mml:mi>c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mo>′</mml:mo>
													</mml:mrow>
												</mml:msup>
												<mml:mo>∈</mml:mo>
												<mml:mi mathvariant="italic">qchild</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="italic">cov</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">min</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo>-</mml:mo>
												<mml:mi>C</mml:mi>
											</mml:mrow>
										</mml:munder>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">gathering</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msup>
											<mml:mrow>
												<mml:mi>c</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msup>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msup>
											<mml:mrow>
												<mml:mi>c</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mo>′</mml:mo>
											</mml:mrow>
										</mml:msup>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">}</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:mspace width="1em"/>
										<mml:mtext>where</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">sysL</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi>s</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>=</mml:mo>
										<mml:mn>0</mml:mn>
										<mml:mspace width="0.35em"/>
										<mml:mtext>if</mml:mtext>
										<mml:mspace width="0.35em"/>
										<mml:mi>C</mml:mi>
										<mml:mo>=</mml:mo>
										<mml:mo>∅</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>In 
							<ce:italic>synopsisJoin</ce:italic>, 
							<ce:italic>L</ce:italic> is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). In this case, since some tuples in 
							<ce:italic>L</ce:italic> will not participate in the join result, it wastes the energy of sensors.
						</ce:para>
						<ce:para id="p0375" view="all">To solve this problem, we devise the 
							<ce:italic>fullsynopsisJoin</ce:italic> plan. In 
							<ce:italic>fullsynopsisJoin</ce:italic>, 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>) sends a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) instead of 
							<ce:italic>L</ce:italic> itself to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>), and then 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) sends the synopsis to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0380" view="all">
							<ce:italic>fullsynopsisJoin</ce:italic> consists of four steps.
							<ce:list id="l0015">
								<ce:list-item id="o0040">
									<ce:label>•</ce:label>
									<ce:para id="p0725" view="all">Generating a synopsis of 
										<ce:italic>Π</ce:italic>
										<ce:inf loc="post">
											<ce:italic>A</ce:italic>
										</ce:inf>(
										<ce:italic>L</ce:italic>) on 
										<ce:italic>Q</ce:italic>
										<ce:inf loc="post">
											<ce:italic>L</ce:italic>
										</ce:inf>.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0045">
									<ce:label>•</ce:label>
									<ce:para id="p0730" view="all">Performing 
										<ce:italic>synopsisJoin</ce:italic> plan on 
										<ce:italic>Q</ce:italic>
										<ce:inf loc="post">
											<ce:italic>R</ce:italic>
										</ce:inf>.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0050">
									<ce:label>•</ce:label>
									<ce:para id="p0735" view="all">Performing 
										<ce:italic>synopsisJoin</ce:italic> plan on 
										<ce:italic>Q</ce:italic>
										<ce:inf loc="post">
											<ce:italic>L</ce:italic>
										</ce:inf> with the synopsis of 
										<ce:italic>Π</ce:italic>
										<ce:inf loc="post">
											<ce:italic>A</ce:italic>
										</ce:inf>(
										<ce:italic>R</ce:italic>
										<ce:hsp sp="0.25"/>⋉
										<ce:hsp sp="0.25"/>
										<ce:italic>L</ce:italic>) using the second step’s result.
									</ce:para>
								</ce:list-item>
								<ce:list-item id="o0055">
									<ce:label>•</ce:label>
									<ce:para id="p0740" view="all">Sending the semijoin results to the base station.</ce:para>
								</ce:list-item>
							</ce:list>
						</ce:para>
						<ce:para id="p0385" view="all">At the first step, when the minimum value of attribute 
							<ce:italic>L</ce:italic>.
							<ce:italic>A</ce:italic> is used as a synopsis, each node in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> sends the minimum value among data from children and its reading. When the bloom filter is used, a node in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> generates the bloom filter by 
							<ce:bold>OR</ce:bold>ing of child nodes’ bloom filters and inserting the hashed value of its reading since the bloom filter 
							<ce:italic>BF</ce:italic>
							<ce:inf loc="post">
								<ce:italic>U</ce:italic>
							</ce:inf> for a set 
							<ce:italic>U</ce:italic> is equal to 
							<mml:math altimg="si31.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
								<mml:mrow>
									<mml:msub>
										<mml:mrow>
											<mml:mi>∨</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:mi>i</mml:mi>
										</mml:mrow>
									</mml:msub>
									<mml:msub>
										<mml:mrow>
											<mml:mi mathvariant="italic">BF</mml:mi>
										</mml:mrow>
										<mml:mrow>
											<mml:msub>
												<mml:mrow>
													<mml:mi>U</mml:mi>
												</mml:mrow>
												<mml:mrow>
													<mml:mi>i</mml:mi>
												</mml:mrow>
											</mml:msub>
										</mml:mrow>
									</mml:msub>
								</mml:mrow>
							</mml:math>, where ⋃
							<ce:italic>U</ce:italic>
							<ce:inf loc="post">
								<ce:italic>i</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>=
							<ce:hsp sp="0.25"/>
							<ce:italic>U</ce:italic>. Thus, the cost of the first step 
							<ce:italic>Cost</ce:italic>
							<ce:inf loc="post">
								<ce:italic>con</ce:italic>
							</ce:inf>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>)) is derived as follows:
							<ce:display>
								<ce:formula id="e0060">
									<ce:label>(12)</ce:label>
									<mml:math altimg="si32.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">con</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:munder>
											<mml:mrow>
												<mml:mo>∑</mml:mo>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>c</mml:mi>
												<mml:mo>∈</mml:mo>
												<mml:mi mathvariant="italic">child</mml:mi>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="italic">cov</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi mathvariant="italic">min</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">(</mml:mo>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>L</mml:mi>
													</mml:mrow>
												</mml:msub>
												<mml:mo stretchy="false">)</mml:mo>
												<mml:mo stretchy="false">)</mml:mo>
											</mml:mrow>
										</mml:munder>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">con</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>+</mml:mo>
										<mml:mi>P</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mi>c</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:mi>m</mml:mi>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>At the second step, the synopsis is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) through 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) and 
							<ce:italic>synopsisJoin</ce:italic> is applied on 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>. Thus, the cost for the second step is as follows:
							<ce:display>
								<ce:formula id="e0065">
									<ce:label>(13)</ce:label>
									<mml:math altimg="si33.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi mathvariant="italic">sys</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>L</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">sysL</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">partial</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi mathvariant="italic">synopsis</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>As a result of the second step, the result of 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> is collected at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). At the third step, this result is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). Using this result, a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>) is made at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) and sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>). And then, 
							<ce:italic>synopsisJoin</ce:italic> is applied on 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> to obtain 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic>. Thus, the cost for the third step is derived as follows:
							<ce:display>
								<ce:formula id="e0070">
									<ce:label>(14)</ce:label>
									<mml:math altimg="si34.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:mi>T</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">SJS</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
												<mml:mo>.</mml:mo>
												<mml:mi>A</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>D</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>·</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>T</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">sysR</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo>+</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">Cost</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">partial</mml:mi>
												<mml:mtext>,</mml:mtext>
												<mml:mi mathvariant="italic">synopsis</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>R</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mtext>,</mml:mtext>
										<mml:msub>
											<mml:mrow>
												<mml:mi mathvariant="italic">cov</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi mathvariant="italic">min</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>Q</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:math>
								</ce:formula>
							</ce:display>In the second term of Eq. 
							<ce:cross-ref refid="e0070">(14)</ce:cross-ref>, we use 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>sysR</ce:italic>
							</ce:inf> as the transmission cost for the synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>). When a set of tuples in 
							<ce:italic>R</ce:italic> appears with the probability 
							<ce:italic>P</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>)), if the semijoin selectivity is not zero, a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>) is not empty. Thus, 
							<ce:italic>T</ce:italic>
							<ce:inf loc="post">
								<ce:italic>sysR</ce:italic>
							</ce:inf> is sufficient to use as a the transmission cost for the synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>).
						</ce:para>
						<ce:para id="p0390" view="all">Finally, 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) receives the result of 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic> from 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>) and sends the union of 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> and 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic> to the base station. This cost is 
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>)
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>+
							<ce:hsp sp="0.25"/>
							<ce:italic>D</ce:italic>
							<ce:inf loc="post">
								<ce:italic>C</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>(
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>))
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>+
							<ce:hsp sp="0.25"/>
							<ce:italic>T</ce:italic>(
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>))
							<ce:hsp sp="0.25"/>·
							<ce:hsp sp="0.25"/>
							<ce:italic>SJS</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>.
								<ce:italic>A</ce:italic>
							</ce:inf>).
						</ce:para>
						<ce:para id="p0395" view="all">Here, in order to maintain the consistency of the other plans, we explain that 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) keeps the results of 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> to send the union of 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> and 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic>. However, actually, the result of 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> is generated at the second step and that of 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic> is generated at the third step. Thus, it is possible to send each semijoin result to the base station at the end of each step without keeping the result of 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> at 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>).
						</ce:para>
					</ce:section>
					<ce:section id="s0045" view="all">
						<ce:label>4.3</ce:label>
						<ce:section-title>Memory requirement of in-network join plans</ce:section-title>
						<ce:para id="p0400" view="all">Generally, sensor nodes have limited memory space. The memory requirement of each join plan should be considered. In this section, we briefly present the memory requirement of each join plans due to the space limitation.</ce:para>
						<ce:para id="p0405" view="all">In 
							<ce:italic>coverJoin</ce:italic>, 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) keeps whole 
							<ce:italic>L</ce:italic> and 
							<ce:italic>R</ce:italic> to perform 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> and 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>R.
						</ce:para>
						<ce:para id="p0410" view="all">In 
							<ce:italic>sideJoin</ce:italic>, 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) keeps 
							<ce:italic>R</ce:italic> to perform 
							<ce:italic>R</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic> and 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) keeps 
							<ce:italic>L</ce:italic> to perform 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic>.
						</ce:para>
						<ce:para id="p0415" view="all">Compared to 
							<ce:italic>sideJoin</ce:italic>, 
							<ce:italic>partitionJoin</ce:italic> has an advantage for the memory space. In 
							<ce:italic>partitionJoin</ce:italic>, a sensor 
							<ce:italic>c</ce:italic> in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf> needs to keep 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⊂
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic> and 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) to perform 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>L</ce:italic>. Thus, when 
							<ce:italic>R</ce:italic> is partitioned into a set of 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf>’s, if the sum of the size of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) and the maximum size of 
							<ce:italic>R</ce:italic>
							<ce:inf loc="post">
								<ce:italic>c</ce:italic>
							</ce:inf> is less than the memory limitation, 
							<ce:italic>partitionJoin</ce:italic> can be performed.
						</ce:para>
						<ce:para id="p0420" view="all">
							<ce:italic>synopsisJoin</ce:italic> reduces the memory requirements of sensors in 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf> compared to 
							<ce:italic>partitionJoin</ce:italic> since a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) is used instead of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>).
						</ce:para>
						<ce:para id="p0425" view="all">However, in 
							<ce:italic>sideJoin, paritionJoin, synopsisJoin</ce:italic>, 
							<ce:italic>L</ce:italic> should be kept in 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>) to perform 
							<ce:italic>L</ce:italic>
							<ce:hsp sp="0.25"/>⋉
							<ce:hsp sp="0.25"/>
							<ce:italic>R</ce:italic>. Thus, if the memory space of a sensor (i.e., 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>
							<ce:hsp sp="0.25"/>⋃
							<ce:hsp sp="0.25"/>
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>)) is smaller than the size of 
							<ce:italic>L</ce:italic>, 
							<ce:italic>sideJoin</ce:italic>, 
							<ce:italic>partitionJoin</ce:italic> and 
							<ce:italic>synopsisJoin</ce:italic> cannot be applied.
						</ce:para>
						<ce:para id="p0430" view="all">In contrast to the other plans, in 
							<ce:italic>fullsynopisJoin</ce:italic>, whole relations 
							<ce:italic>L</ce:italic> and 
							<ce:italic>R</ce:italic> are not required at either of the two query region since 
							<ce:italic>synopisJoin</ce:italic> plan is applied on both 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> and 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>. Thus, the memory requirement of 
							<ce:italic>fullsynopsisJoin</ce:italic> is the smallest among the devised in-network join plans.
						</ce:para>
					</ce:section>
				</ce:section>
				<ce:section id="s0050" view="all">
					<ce:label>5</ce:label>
					<ce:section-title>Experiments</ce:section-title>
					<ce:para id="p0435" view="all">In this section, we demonstrate the effectiveness of INJECT and show the efficiency of our proposed in-network join plans. Thus, to show the effectiveness of INJECT, we implement diverse join plans: 
						<ce:italic>baseJoin</ce:italic>, 
						<ce:italic>coverJoin</ce:italic>, 
						<ce:italic>sideJoin</ce:italic>, 
						<ce:italic>partitionJoin</ce:italic>, 
						<ce:italic>synopsisJoin</ce:italic> and 
						<ce:italic>fullsynopsisJoin</ce:italic>. We empirically compared the performances of devised join plans and show that INJECT chooses the optimal or near optimal plan over the diverse environments.
					</ce:para>
					<ce:section id="s0055" view="all">
						<ce:label>5.1</ce:label>
						<ce:section-title>Experimental environment</ce:section-title>
						<ce:para id="p0440" view="all">In this section, we present the features of the experimental data set and the parameters to configure diverse environments.</ce:para>
						<ce:para id="p0445" view="all">The default network configuration of experiments is 10
							<ce:hsp sp="0.25"/>×
							<ce:hsp sp="0.25"/>10 grid and sensor nodes are placed in each grid point. The base station is located on the upper left corner. The routing tree is constructed using the FHF (First-Heard-From) network configuration algorithm 
							<ce:cross-ref refid="b0070">[14]</ce:cross-ref>. The maximum hop distance of the network tree is eight.
						</ce:para>
						<ce:para id="p0450" view="all">As shown in our basic cost model in Eq. 
							<ce:cross-ref refid="e0010">(2)</ce:cross-ref>, the transmission cost is affected by the selection selectivity and the size of a query region. In addition, the join selectivity affects the communication cost. Thus, to simulate diverse conditions of networks, we use some parameters. The default parameter settings used in our experiments are summarized in 
							<ce:cross-ref refid="t0010">Table 2</ce:cross-ref>
							<ce:float-anchor refid="t0010"/>.
						</ce:para>
						<ce:para id="p0455" view="all">We set the size of a tuple to 44 bytes and the size of join attribute to 8 bytes. For 
							<ce:italic>synopsisJoin</ce:italic> and 
							<ce:italic>fullsynopsisJoin</ce:italic>, the bloom filter is used. We set the size of a bloom filter to 30 bytes.
						</ce:para>
						<ce:para id="p0460" view="all">In our experiments, we run the join query for an interval of 1000
							<ce:hsp sp="0.25"/>epochs. We show the accumulated costs of estimation using the proposed cost models and those of actual execution.
						</ce:para>
						<ce:para id="p0465" view="all">Generally, according to the sensor’s type, the energy consumption of data transmission is different. And, our cost model is based on the size of data transmission. Thus, we use the amount of transmitted data as the performance metric.
							<ce:footnote id="fn2">
								<ce:label>2</ce:label>
								<ce:note-para>Since the transmission size of each node can be estimated using our cost model, the other measures such as the number of data transmissions and energy consumption can be derived easily. However, we omit it due to the space limitation.</ce:note-para>
							</ce:footnote>
							<ce:cross-ref refid="fn2">
								<ce:sup loc="post">2</ce:sup>
							</ce:cross-ref>
						</ce:para>
					</ce:section>
					<ce:section id="s0060" view="all">
						<ce:label>5.2</ce:label>
						<ce:section-title>Experimental results</ce:section-title>
						<ce:para id="p0470" view="all">In each experiment, we vary one of the parameters and show its effect. With a few exceptions, the estimated cost accurately reflects the relative rank for each plan.</ce:para>
						<ce:para id="p0475" view="all">In previous sections, we only present the case that 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>) (or a synopsis of 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>L</ce:italic>)) is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>R</ce:italic>
							</ce:inf>). However, except 
							<ce:italic>baseJoin</ce:italic> and 
							<ce:italic>coverJoin</ce:italic>, the join column of a relation is sent to the opposite side. For example, 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>R</ce:italic>) can be sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>) in 
							<ce:italic>sideJoin</ce:italic>. Thus, in our experimental result, we attach the prefixes 
							<ce:italic>L</ce:italic> and 
							<ce:italic>R</ce:italic> in each plan to represent these cases. The prefix 
							<ce:italic>L</ce:italic> denotes that a semijoin is performed at 
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf> side (i.e., 
							<ce:italic>Π</ce:italic>
							<ce:inf loc="post">
								<ce:italic>A</ce:italic>
							</ce:inf>(
							<ce:italic>R</ce:italic>) is sent to 
							<ce:italic>cov</ce:italic>
							<ce:inf loc="post">
								<ce:italic>min</ce:italic>
							</ce:inf>(
							<ce:italic>Q</ce:italic>
							<ce:inf loc="post">
								<ce:italic>L</ce:italic>
							</ce:inf>)). The prefix 
							<ce:italic>R</ce:italic> denotes the opposite case.
						</ce:para>
						<ce:section id="s0065" view="all">
							<ce:label>5.2.1</ce:label>
							<ce:section-title>Join selectivity</ce:section-title>
							<ce:para id="p0480" view="all">To show the effect of the join selectivity, we set 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> for 
								<ce:italic>R</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>L</ce:italic> to 0.5 and vary the semijoin selectivity (
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf>) for 
								<ce:italic>L</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>R</ce:italic> from 0.1 to 1.0.
							</ce:para>
							<ce:para id="p0485" view="all">
								<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>
								<ce:float-anchor refid="f0045"/> shows the results of the estimated costs and actual costs of diverse plans. As shown in 
								<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>, the pattern of estimate costs is quite similar to that of the actual costs.
							</ce:para>
							<ce:para id="p0490" view="all">INJECT estimates that 
								<ce:italic>LfullsynopsisJoin</ce:italic> is superior to other plans when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is from 0.1 to 0.7 and 
								<ce:italic>RsynopsisJoin</ce:italic> is the best plan when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is from 0.8 to 1. In the result of actual costs shown in 
								<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>(b), 
								<ce:italic>LfullsynopsisJoin</ce:italic> shows the best performance when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is from 0.1 to 0.6. And 
								<ce:italic>RsynopsisJoin</ce:italic> is superior when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is from 0.8 to 1. When 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is 0.7, the 
								<ce:italic>RfullsynopsisJoin</ce:italic> shows the best performance. But the performance of 
								<ce:italic>LfullsynopsisJoin</ce:italic> is very close to that of 
								<ce:italic>RfullsynopsisJoin</ce:italic>. This result confirms that INJECT chooses the optimal or near optimal plan among diverse in-network join plans.
							</ce:para>
							<ce:para id="p0495" view="all">Generally, the transmission costs of basic join plans (
								<ce:italic>baseJoin</ce:italic>, 
								<ce:italic>coverJoin</ce:italic>, 
								<ce:italic>sideJoin</ce:italic>) are higher than the enhanced join plans (
								<ce:italic>partitionJoin</ce:italic>, 
								<ce:italic>synopsisJoin</ce:italic>, 
								<ce:italic>fullsynopsisJoin</ce:italic>). Among the enhanced join plans, the costs of 
								<ce:italic>synopsisJoin</ce:italic> and 
								<ce:italic>fullsynopsisJoin</ce:italic> are much less than those of the other plans in almost all cases.
							</ce:para>
							<ce:para id="p0500" view="all">Since, in 
								<ce:italic>baseJoin</ce:italic>, all tuples of 
								<ce:italic>L</ce:italic> and 
								<ce:italic>R</ce:italic> satisfying selection predicates are sent to the base station, the semijoin selectivity does not affect the performance of 
								<ce:italic>baseJoin</ce:italic>.
							</ce:para>
							<ce:para id="p0505" view="all">In 
								<ce:italic>coverJoin</ce:italic>, 
								<ce:italic>L</ce:italic> and 
								<ce:italic>R</ce:italic> are sent to 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>) and the results of 
								<ce:italic>L</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>R</ce:italic> and 
								<ce:italic>R</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>L</ce:italic> are sent to the base station. Thus, since the size of 
								<ce:italic>L</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>R</ce:italic> increases as 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> increases, the cost of 
								<ce:italic>coverJoin</ce:italic> increases.
							</ce:para>
							<ce:para id="p0510" view="all">Now we consider 
								<ce:italic>LsideJoin</ce:italic> and 
								<ce:italic>RsideJoin</ce:italic> plans. As 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> increases, the number of L’s tuples participating in a semijoin result increases. In other words, the size of 
								<ce:italic>L</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>R</ce:italic> is smaller than that of 
								<ce:italic>R</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>L</ce:italic> when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is smaller than 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf>. Therefore, when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is smaller than 0.5, 
								<ce:italic>LsideJoin</ce:italic> is better than 
								<ce:italic>RsideJoin</ce:italic> since many tuples of 
								<ce:italic>L</ce:italic> are filtered out by the semijoin 
								<ce:italic>L</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>R</ce:italic> at 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>). But, when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is greater than 0.5, 
								<ce:italic>RsideJoin</ce:italic> is better than 
								<ce:italic>LsideJoin</ce:italic>. Similar arguments hold on 
								<ce:italic>LpartitionJoin</ce:italic> and 
								<ce:italic>RpartitionJoin</ce:italic> as well as 
								<ce:italic>LsynopsisJoin</ce:italic> and 
								<ce:italic>RsynopsisJoin</ce:italic>.
							</ce:para>
							<ce:para id="p0515" view="all">In contrast to the other join plans, 
								<ce:italic>LfullsynopsisJoin</ce:italic> and 
								<ce:italic>RfullsynonsisJoin</ce:italic> show the similar performance since semijoins using synopses are performed at both sides. The difference of 
								<ce:italic>LfullsynopsisJoin</ce:italic> and 
								<ce:italic>RfullsynonsisJoin</ce:italic> is that an initial synopsis is generated at which side. This cost is mainly affected by the selection selectivity 
								<ce:italic>sel</ce:italic>(
								<ce:italic>P</ce:italic>
								<ce:inf loc="post">
									<ce:italic>Q</ce:italic>
								</ce:inf>) for a query region 
								<ce:italic>Q</ce:italic>.
							</ce:para>
							<ce:para id="p0520" view="all">As mentioned in Sections 
								<ce:cross-refs refid="s0035 s0040">4.1 and 4.2</ce:cross-refs>, in 
								<ce:italic>partitionJoin</ce:italic> and 
								<ce:italic>synopsisJoin</ce:italic> plans, a query region 
								<ce:italic>Q</ce:italic> is partitioned into subregions 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>c</ce:italic>
								</ce:inf> and a join column or a synopsis is distributed to subregions.
							</ce:para>
							<ce:para id="p0525" view="all">However, as mentioned above, as 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> increases, the number of tuples of 
								<ce:italic>L</ce:italic> which will contribute to a join result increases. Thus, in each subregion, a small number of tuples will be filtered out. But the cost to distribute 
								<ce:italic>Π</ce:italic>
								<ce:inf loc="post">
									<ce:italic>A</ce:italic>
								</ce:inf>(
								<ce:italic>R</ce:italic>) or a synopsis of 
								<ce:italic>Π</ce:italic>
								<ce:inf loc="post">
									<ce:italic>A</ce:italic>
								</ce:inf>(
								<ce:italic>R</ce:italic>) is required. Thus, when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is greater than 0.7, our partition algorithm computes that no partitioning of 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf> is beneficial. In these cases, 
								<ce:italic>LpartitionJoin</ce:italic> acts as 
								<ce:italic>LsideJoin</ce:italic>. Compared to 
								<ce:italic>LpartitionJoin</ce:italic>, 
								<ce:italic>LsynopsisJoin</ce:italic> is slightly better since a synopsis of 
								<ce:italic>Π</ce:italic>
								<ce:inf loc="post">
									<ce:italic>A</ce:italic>
								</ce:inf>(
								<ce:italic>R</ce:italic>) instead of 
								<ce:italic>Π</ce:italic>
								<ce:inf loc="post">
									<ce:italic>A</ce:italic>
								</ce:inf>(
								<ce:italic>R</ce:italic>) is sent to 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>).
							</ce:para>
							<ce:para id="p0530" view="all">In contrast, 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> is partitioned into several subregions in 
								<ce:italic>RpartitionJoin</ce:italic> and 
								<ce:italic>RsynopsisJoin</ce:italic> since 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is fixed at 0.5. Thus, 
								<ce:italic>RpartitionJoin</ce:italic> and 
								<ce:italic>RsynopsisJoin</ce:italic> show better performance than 
								<ce:italic>RsideJoin</ce:italic>.
							</ce:para>
							<ce:para id="p0535" view="all">
								<ce:italic>LfullsynopsisJoin</ce:italic> and 
								<ce:italic>RfullsynopsisJoin</ce:italic> show the best performance when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is smaller than 0.7 since the partition strategy is applied to both side and many tuples are filtered out. However, when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is greater than 0.7, 
								<ce:italic>LfullsynopsisJoin</ce:italic> and 
								<ce:italic>RfullsynopsisJoin</ce:italic> are worse than 
								<ce:italic>RpartitionJoin</ce:italic> and 
								<ce:italic>RsynopsisJoin</ce:italic> since 
								<ce:italic>L/RfullsynopsisJoin</ce:italic> act as 
								<ce:italic>LsideJoin</ce:italic> on 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf> although 
								<ce:italic>L/RfullsynopsisJoin</ce:italic> behave on 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> like 
								<ce:italic>RsynopsisJoin</ce:italic>.
							</ce:para>
							<ce:para id="p0540" view="all">One of interesting points is that the costs of 
								<ce:italic>LsideJoin</ce:italic>, 
								<ce:italic>LpartitionJoin</ce:italic>, and 
								<ce:italic>LsynopsisJoin</ce:italic> are greater than that of 
								<ce:italic>coverJoin</ce:italic> when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is greater than 0.7. In particular, when 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> is 1.0, the costs of 
								<ce:italic>LsideJoin</ce:italic> and 
								<ce:italic>LpartitionJoin</ce:italic> approach to that of 
								<ce:italic>baseJoin</ce:italic>. This result indicates that using a fixed in-network join plan blindly wastes the energy as much as a naive join plan (i.e., 
								<ce:italic>baseJoin</ce:italic>), and therefore, cost based optimization is required.
							</ce:para>
							<ce:para id="p0545" view="all">Compared to actual costs, the average of relative error rates (=∣(
								<ce:italic>estimated cost</ce:italic>
								<ce:hsp sp="0.25"/>−
								<ce:hsp sp="0.25"/>
								<ce:italic>actual cost</ce:italic>)/
								<ce:italic>actual cost</ce:italic>∣) is about 5% and the maximum of the relative error rates is 18%. Therefore, the proposed cost models accurately estimate the transmission costs.
							</ce:para>
						</ce:section>
						<ce:section id="s0070" view="all">
							<ce:label>5.2.2</ce:label>
							<ce:section-title>Selection selectivity</ce:section-title>
							<ce:para id="p0550" view="all">This experiment tests the effect of the selection selectivity. We set the selection selectivity of 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf> (= 
								<mml:math altimg="si35.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>L</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math>) to 0.5 and vary the selection selectivity of 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> (= 
								<mml:math altimg="si36.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math>) from 0.1 to 1.0. Other parameters are all set to their default values. The results are shown in 
								<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>
								<ce:float-anchor refid="f0050"/>. The patterns of the estimated costs and the actual costs are also similar. The average of relative error rates is about 7%.
							</ce:para>
							<ce:para id="p0555" view="all">In this experiment, INJECT chooses 
								<ce:italic>LpartitionJoin</ce:italic> as the optimal plan when 
								<mml:math altimg="si37.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> is small (i.e., 0.1∼0.3). As shown in 
								<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>(b), 
								<ce:italic>LfullsynopsisJoin</ce:italic> shows the best performance when 
								<mml:math altimg="si38.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> is small. However, the performance gap between 
								<ce:italic>LfullsynopsisJoin</ce:italic> and 
								<ce:italic>LpartitionJoin</ce:italic> is quite small. In addition, as expected by INJECT, 
								<ce:italic>RfullsynopsisJoin</ce:italic> shows the best performance on other cases.
							</ce:para>
							<ce:para id="p0560" view="all">As the selection selectivity increases, the transmission cost also increases. Thus, in contrast to the result for 
								<ce:italic>baseJoin</ce:italic> in 
								<ce:cross-ref refid="f0045">Fig. 9</ce:cross-ref>, the cost of 
								<ce:italic>baseJoin</ce:italic> increases. The cost of 
								<ce:italic>coverJoin</ce:italic> also increases. But, since 
								<ce:italic>R</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>L</ce:italic> and 
								<ce:italic>L</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>R</ce:italic> instead 
								<ce:italic>R</ce:italic> and 
								<ce:italic>L</ce:italic> are sent from 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>∪
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>) to the base station in 
								<ce:italic>coverJoin</ce:italic>, 
								<ce:italic>coverJoin</ce:italic> is better than 
								<ce:italic>baseJoin</ce:italic>.
							</ce:para>
							<ce:para id="p0565" view="all">As 
								<mml:math altimg="si39.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> increases, the number of tuples of 
								<ce:italic>R</ce:italic> satisfying the selection predicate increases. Thus, it is beneficial that a semijoin is performed at 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> side. Therefore, as shown in 
								<ce:cross-ref refid="f0050">Fig. 10</ce:cross-ref>, when 
								<mml:math altimg="si40.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> is greater than 
								<mml:math altimg="si41.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>L</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:mo>=</mml:mo>
										<mml:mn>0.5</mml:mn>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math>, a plan in which a semijoin is performed at 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> side (e.g., 
								<ce:italic>RsideJoin</ce:italic>) has a smaller transmission cost than its counterpart (e.g., 
								<ce:italic>LsideJoin</ce:italic>).
							</ce:para>
							<ce:para id="p0570" view="all">As mentioned in Section 
								<ce:cross-ref refid="s0065">5.2.1</ce:cross-ref>, the behaviors of 
								<ce:italic>LfullsynopsisJoin</ce:italic> and 
								<ce:italic>RfullsynopsisJoin</ce:italic> are similar except that an initial synopsis is constructed at which side. As presented in Eqs. 
								<ce:cross-refs refid="e0045 e0060">(9) and (12)</ce:cross-refs>, the synopsis construction cost is affected by the selection selectivity. In 
								<ce:italic>LfullsynopsisJoin</ce:italic>, the initial synopsis is constructed at 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> side. As 
								<mml:math altimg="si42.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> increases, the synopsis construction cost on 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> increases. Thus, the performance of 
								<ce:italic>LfullsynopsisJoin</ce:italic> becomes worse than that of 
								<ce:italic>RfullsynopsisJoin</ce:italic>.
							</ce:para>
							<ce:para id="p0575" view="all">Recall that, as mentioned in Section 
								<ce:cross-ref refid="s0065">5.2.1</ce:cross-ref>, partitioning a query region is beneficial when the join selectivity is not high. In this experiment, we set 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> and 
								<ce:italic>SJS</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>.
									<ce:italic>A</ce:italic>
								</ce:inf> to 0.5. Therefore, as 
								<mml:math altimg="si43.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:mi mathvariant="italic">sel</mml:mi>
										<mml:mo stretchy="false">(</mml:mo>
										<mml:msub>
											<mml:mrow>
												<mml:mi>P</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>Q</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>R</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
										<mml:mo stretchy="false">)</mml:mo>
									</mml:mrow>
								</mml:math> increases, the performance gap between 
								<ce:italic>RsideJoin</ce:italic> which gathers tuples satisfying a selection predicate at 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>) and the join plans applying partition strategy on 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> (i.e., 
								<ce:italic>RpartitionJoin</ce:italic>, 
								<ce:italic>RsynopsisJoin</ce:italic>, 
								<ce:italic>L/RfullsynopsisJoin</ce:italic>) increases.
							</ce:para>
						</ce:section>
						<ce:section id="s0075" view="all">
							<ce:label>5.2.3</ce:label>
							<ce:section-title>Cover node depth</ce:section-title>
							<ce:para id="p0580" view="all">In this experiment, we vary the hop distance and show its effect. We set 
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>C</ce:italic>
								</ce:inf> and 
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf> to 1 and 2, respectively. We change 
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> from a smaller value to a larger value than 
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>. The results are shown in 
								<ce:cross-ref refid="f0055">Fig. 11</ce:cross-ref>
								<ce:float-anchor refid="f0055"/>.
							</ce:para>
							<ce:para id="p0585" view="all">As shown in 
								<ce:cross-ref refid="f0055">Fig. 11</ce:cross-ref>, since we set the selection selectivity and join selectivity at each side to the same, when 
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> and 
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf> are the same (=2), the performance of a plan performing a semijoin at 
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> and that of its counterpart are the same.
							</ce:para>
							<ce:para id="p0590" view="all">Although the size of transmitted data of 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>) and that of 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>) are the same, nodes having a larger hop distance to 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>) have a larger transmission cost. In the case of 
								<ce:italic>LsynopsisJoin</ce:italic> and 
								<ce:italic>RsynopsisJoin</ce:italic>, the smaller cost plan is changed from 
								<ce:italic>RsynopsisJoin</ce:italic> to 
								<ce:italic>LsynopsisJoin</ce:italic> as 
								<ce:italic>D</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf> increases. Other plans also show similar patterns. The average relative error rate of all cases is about 6%.
							</ce:para>
						</ce:section>
						<ce:section id="s0080" view="all">
							<ce:label>5.2.4</ce:label>
							<ce:section-title>Memory requirement</ce:section-title>
							<ce:para id="p0595" view="all">Sensor nodes generally have limited memory space. Therefore, the memory consumption of each join plan should be considered. In this section, we show the minimum and maximum memory requirements of each in-network join plan with default parameters. In 
								<ce:cross-ref refid="t0015">Table 3</ce:cross-ref>
								<ce:float-anchor refid="t0015"/>, the minimum size and maximum size (in bytes) of accumulated memory requirement of a node as well as the corresponding nodes in parentheses are presented. 
								<mml:math altimg="si44.gif" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML">
									<mml:mrow>
										<mml:msub>
											<mml:mrow>
												<mml:mi>L</mml:mi>
											</mml:mrow>
											<mml:mrow>
												<mml:msub>
													<mml:mrow>
														<mml:mi>c</mml:mi>
													</mml:mrow>
													<mml:mrow>
														<mml:mi>i</mml:mi>
													</mml:mrow>
												</mml:msub>
											</mml:mrow>
										</mml:msub>
									</mml:mrow>
								</mml:math> is a child of 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>).
							</ce:para>
							<ce:para id="p0600" view="all">Because, in 
								<ce:italic>coverJoin</ce:italic>, 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>) keeps whole 
								<ce:italic>L</ce:italic> and 
								<ce:italic>R</ce:italic> to perform 
								<ce:italic>R</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>L</ce:italic> and 
								<ce:italic>L</ce:italic>
								<ce:hsp sp="0.25"/>⋉
								<ce:hsp sp="0.25"/>
								<ce:italic>R</ce:italic>, 
								<ce:italic>coverJoin</ce:italic> requires larger memory space. 
								<ce:italic>LsideJoin</ce:italic> and 
								<ce:italic>RsideJoin</ce:italic> reduce the memory requirement because one relation of 
								<ce:italic>L</ce:italic> and 
								<ce:italic>R</ce:italic> should be kept at each cover node.
							</ce:para>
							<ce:para id="p0605" view="all">
								<ce:italic>partitionJoin</ce:italic> requires smaller memory space than 
								<ce:italic>sideJoin</ce:italic> because a relation is partitioned into subregions. In the case of 
								<ce:italic>synopsisJoin</ce:italic>, the required memory space is smaller than the 
								<ce:italic>partitionJoin</ce:italic> because a synopsis is used instead of the projection result. However, in 
								<ce:italic>partitionJoin</ce:italic> and 
								<ce:italic>sideJoin</ce:italic>, 
								<ce:italic>cov</ce:italic>
								<ce:inf loc="post">
									<ce:italic>min</ce:italic>
								</ce:inf>(
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>L</ce:italic>
								</ce:inf>
								<ce:hsp sp="0.25"/>⋃
								<ce:hsp sp="0.25"/>
								<ce:italic>Q</ce:italic>
								<ce:inf loc="post">
									<ce:italic>R</ce:italic>
								</ce:inf>) keeps the other relation.
							</ce:para>
							<ce:para id="p0610" view="all">
								<ce:italic>fullsynopsisJoin</ce:italic> reduces required memory space much more because the partitioning strategy is applied to both query region. Therefore, although the memory space of a sensor is smaller than a relation, 
								<ce:italic>fullsynopsisJoin</ce:italic> can be applied.
							</ce:para>
						</ce:section>
					</ce:section>
				</ce:section>
				<ce:section id="s0085" view="all">
					<ce:label>6</ce:label>
					<ce:section-title>Related work</ce:section-title>
					<ce:para id="p0615" view="all">Joins are common in applications for target tracking, event detecting, correlation analysis, and so on. In the database literature, several sensor data management systems such as Cougar 
						<ce:cross-ref refid="b0035">[7]</ce:cross-ref> and TinyDB 
						<ce:cross-ref refid="b0070">[14]</ce:cross-ref> have been introduced. However, these systems do not support joins efficiently. Basically, in these systems, joins are performed at the base station like the 
						<ce:italic>baseJoin</ce:italic> plan.
					</ce:para>
					<ce:para id="p0620" view="all">Recently, some works for the in-network join processing have been conducted.</ce:para>
					<ce:para id="p0625" view="all">Albadi et al. propose REED 
						<ce:cross-ref refid="b0005">[1]</ce:cross-ref> which is a distributed join algorithm for event detection. In REED, some conditions for event detection are specified as a stable relation. REED supports joins between sensor data and a static relation built outside the networks. Thus, they do not consider joins of sensor readings in distinct regions.
					</ce:para>
					<ce:para id="p0630" view="all">Bonfils and Bonnet 
						<ce:cross-ref refid="b0020">[4]</ce:cross-ref> suggest an adaptive algorithm for finding the optimal join location. Similar work is performed 
						<ce:cross-ref refid="b0095">[19]</ce:cross-ref> for the environments that data is transmitted through a hierarchy of network nodes with progressively increasing computing power and network bandwidth. This work considers that the join is performed at only one node.
					</ce:para>
					<ce:para id="p0635" view="all">Yang et al. 
						<ce:cross-ref refid="b0110">[22]</ce:cross-ref>, propose the two-phase self join (TPSJ) approach. TPSJ is a kind of the semantic optimization technique. In TPSJ, the base station gathers some sensor readings which act as a stable relation like REED 
						<ce:cross-ref refid="b0005">[1]</ce:cross-ref>. Then, the gathered sensor readings are distributed through sensor networks and each sensor performs join operation. In TPSJ, the distribution cost of gathered readings is reduced if currently gathered readings are contained in previously distributed readings. But in order to check the containment, the sensor reading composing the stable table should be transmitted to the base station.
					</ce:para>
					<ce:para id="p0640" view="all">Some in-network join methods between two regions in sensor networks were presented in 
						<ce:cross-refs refid="b0030 b0085 b0100">[6,17,20]</ce:cross-refs>. 
						<ce:cross-ref refid="b0085">[17]</ce:cross-ref> considers the optimal join location using the cost model. In this work, the optimal join location is near to the weighted centroid of three points: two center points of two query regions and the base station. But, the cost models used in these methods are not accurate since they did not consider join selectivities and they assume that all sensor readings in a query region are collected at the center of the region.
					</ce:para>
					<ce:para id="p0645" view="all">A similar work is done in 
						<ce:cross-ref refid="b0100">[20]</ce:cross-ref>, in this work, as the optimal join location, the weighted Fermat point is obtained.
					</ce:para>
					<ce:para id="p0650" view="all">Coman et al. 
						<ce:cross-ref refid="b0030">[6]</ce:cross-ref> presented three join plans which are similar to our three basic join plans. External join in 
						<ce:cross-ref refid="b0030">[6]</ce:cross-ref> is identical to our 
						<ce:italic>baseJoin</ce:italic>. Mediated join 
						<ce:cross-ref refid="b0030">[6]</ce:cross-ref> is similar to our 
						<ce:italic>coverJoin</ce:italic> since two relation is joined at a node. Like 
						<ce:cross-ref refid="b0100">[20]</ce:cross-ref> the weighted Fermat point is considered as the join location in mediate join. But, since our work is based on tree routing, the join location of 
						<ce:italic>coverJoin</ce:italic> is 
						<ce:italic>cov</ce:italic>
						<ce:inf loc="post">
							<ce:italic>min</ce:italic>
						</ce:inf>(
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>⋃
						<ce:hsp sp="0.25"/>
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf>). If we align the routing tree to make the weighted Fermat point 
						<ce:italic>cov</ce:italic>
						<ce:inf loc="post">
							<ce:italic>min</ce:italic>
						</ce:inf>(
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>L</ce:italic>
						</ce:inf>
						<ce:hsp sp="0.25"/>⋃
						<ce:hsp sp="0.25"/>
						<ce:italic>Q</ce:italic>
						<ce:inf loc="post">
							<ce:italic>R</ce:italic>
						</ce:inf>), 
						<ce:italic>coverJoin</ce:italic> is quite similar to mediate join. Local join 
						<ce:cross-ref refid="b0030">[6]</ce:cross-ref> is similar to our 
						<ce:italic>sideJoin</ce:italic> since a relation is transmitted into the counterpart. Unlike 
						<ce:italic>sideJoin</ce:italic>, local join distributes a relation into all nodes in the counterpart region. Note that, in 
						<ce:italic>partitionJoin</ce:italic>, a generalization of 
						<ce:italic>sideJoin</ce:italic>, a relation (actually, a join column) is distributed with respect to the cost model. Thus, with the cost model of 
						<ce:italic>partitionJoin</ce:italic>, we can obtain the more efficient distribution plan.
					</ce:para>
					<ce:para id="p0655" view="all">All work above except 
						<ce:cross-ref refid="b0030">[6]</ce:cross-ref> focuses on a general join operator. In order to reduce the communication overhead, we consider semijoins and synopsis joins. Semijoins and synopsis joins are used widely in the distributed database environments 
						<ce:cross-ref refid="b0010">[2]</ce:cross-ref>. However, these methods are not applied directly since sensor networks are hierarchically structured.
					</ce:para>
					<ce:para id="p0660" view="all">In 
						<ce:cross-ref refid="b0115">[23]</ce:cross-ref>, a synopsis join algorithm for in-network join processing is proposed. In this work, a histogram is used as a synopsis. The authors suggest a synopsis join location based on the cost model. In the aspect of using synopsis joins, the work of 
						<ce:cross-ref refid="b0115">[23]</ce:cross-ref> is similar to ours. But, the cost model used in 
						<ce:cross-ref refid="b0115">[23]</ce:cross-ref> is too rough to use in query optimization since the purpose of the cost model is finding the weighted centroid of two regions’ centers. Furthermore, this technique cannot be used in tree routing environments since the synopsis join is performed at any node (i.e., a weighted centroid) in a network, like 
						<ce:cross-ref refid="b0085">[17]</ce:cross-ref>.
					</ce:para>
					<ce:para id="p0665" view="all">Stern et al. propose SENS-Join method 
						<ce:cross-ref refid="b0105">[21]</ce:cross-ref> in order to avoid shipping tuples through the network that do not join. The join plan of SENS-Join consists of two phase like 
						<ce:cross-ref refid="b0115">[23]</ce:cross-ref>. In 
						<ce:cross-ref refid="b0105">[21]</ce:cross-ref>, SENS-Join uses a compact representation of join attribute values based on the quad tree. Some techniques used in 
						<ce:cross-ref refid="b0105">[21]</ce:cross-ref>, such as gathering values of a join attribute rather than whole tuples, can be applied in our work orthogonally. However, in 
						<ce:cross-ref refid="b0105">[21]</ce:cross-ref>, the cost model for SENS-Join is not presented. As mentioned above, according to various conditions, the optimal query plan is changed. Thus, the cost model is an indispensable component to choose the best query plan. Also, they only show the efficiency of SENS-Join compared with 
						<ce:italic>baseJoin</ce:italic>.
					</ce:para>
				</ce:section>
				<ce:section id="s0090" view="all">
					<ce:label>7</ce:label>
					<ce:section-title>Conclusion</ce:section-title>
					<ce:para id="p0670" view="all">In this work, we suggest the cost based join strategy, called INJECT, for tree routing sensor networks. To do this, we suggest diverse join plans. And, based on the basic cost model to gather sensor readings in a region and to transmit the gathered data to a certain node via tree routing, we devise cost models for diverse join plans. Since we devise the cost models based on reasonable assumptions, we have confidence that our cost models can be easily extended to other join plans.</ce:para>
					<ce:para id="p0675" view="all">To show the performances of our devised join plans and effectiveness of the cost based query optimization in tree routing sensor networks, we implement diverse join plans, and conduct an extensive experimental study over diverse conditions.</ce:para>
					<ce:para id="p0680" view="all">In our experiment, we show that some devised join plans show the best performance over other cases. However, there is no superior plan over all cases. Our experiments show that our proposed method, INJECT, chooses the optimal or near optimal join plan over diverse cases. Thus, INJECT extends the lifetime of sensor networks.</ce:para>
					<ce:para id="p0685" view="all">This work focuses on the efficient in-network processing for a single join query. Thus, as the future work, we will conduct a study about a technique that efficiently processes multiple join queries in networks, simultaneously, as well as the corresponding cost model.</ce:para>
				</ce:section>
			</ce:sections>
			<ce:acknowledgment xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Acknowledgements</ce:section-title>
				<ce:para id="p0805" view="all">We would like to thank the editor and anonymous reviewers for their helpful comments. This work was supported in part by the 
					<ce:grant-sponsor id="GS1" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">National Research Foundation of Korea grant funded by the Korean government</ce:grant-sponsor> (No. 
					<ce:grant-number refid="GS1">2010-0016165</ce:grant-number>) and in part by the 
					<ce:grant-sponsor id="GS2" xlink:type="simple" xlink:role="http://www.elsevier.com/xml/linking-roles/grant-sponsor" xmlns:xlink="http://www.w3.org/1999/xlink">National Research Foundation of Korea grant funded by the Korean government (MEST)</ce:grant-sponsor> (No. 
					<ce:grant-number refid="GS2">2011-0000377</ce:grant-number>).
				</ce:para>
			</ce:acknowledgment>
		</ja:body>
		<ja:tail view="all">
			<ce:bibliography id="bi005" view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>References</ce:section-title>
				<ce:bibliography-sec id="bs005">
					<ce:bib-reference id="b0005">
						<ce:label>[1]</ce:label>
						<ce:other-ref>
							<ce:textref>D.J. Abadi, S. Madden, W. Lindner, Reed: robust, efficient filtering and event detection in sensor networks, in: Proceedings of VLDB, 2005, pp. 769–780.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0010">
						<ce:label>[2]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>P.A.</ce:given-name>
										<ce:surname>Bernstein</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.-M.W.</ce:given-name>
										<ce:surname>Chiu</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Using semi-joins to solve relational queries</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. ACM</sb:maintitle>
										</sb:title>
										<sb:volume-nr>28</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>1</sb:issue-nr>
									<sb:date>1981</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>25</sb:first-page>
									<sb:last-page>40</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0015">
						<ce:label>[3]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>B.H.</ce:given-name>
										<ce:surname>Bloom</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Space/time trade-offs in hash coding with allowable errors</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Commun. ACM</sb:maintitle>
										</sb:title>
										<sb:volume-nr>13</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>7</sb:issue-nr>
									<sb:date>1970</sb:date>
								</sb:issue>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0020">
						<ce:label>[4]</ce:label>
						<ce:other-ref>
							<ce:textref>B.J. Bonfils, P. Bonnet, Adaptive and decentralized operator placement for in-network query processing, in: Proceedings of Information Processing in Sensor Networks, 2003, pp. 47–62.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0025">
						<ce:label>[5]</ce:label>
						<ce:other-ref>
							<ce:textref>D. Chu, A. Deshpande, J.M. Hellerstein, W. Hong, Approximate data collection in sensor networks using probabilistic models, in: Proceedings of ICDE, 2006, p. 48.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0030">
						<ce:label>[6]</ce:label>
						<ce:other-ref>
							<ce:textref>A. Coman, M.A. Nascimento, J. Sander, On join location in sensor networks, in: Proceedings of International Conference on Mobile Data Management (MDM), 2007, pp. 190–197.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0035">
						<ce:label>[7]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.</ce:given-name>
										<ce:surname>Demers</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>Gehrke</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.</ce:given-name>
										<ce:surname>Rajaraman</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>N.</ce:given-name>
										<ce:surname>Trigoni</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>Y.</ce:given-name>
										<ce:surname>Yao</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>The cougar project: a work-in-progress report</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>SIGMOD Record</sb:maintitle>
										</sb:title>
										<sb:volume-nr>32</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>3</sb:issue-nr>
									<sb:date>2003</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>9</sb:first-page>
									<sb:last-page>18</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0040">
						<ce:label>[8]</ce:label>
						<ce:other-ref>
							<ce:textref>A. Deshpande, C. Guestrin, S. Madden, J.M. Hellerstein, W. Hong, Model-driven data acquisition in sensor networks, in: Proceedings of VLDB, 2004, pp. 588–599.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0045">
						<ce:label>[9]</ce:label>
						<ce:other-ref>
							<ce:textref>W.R. Heinzelman, A. Chandrakasan, H. Balakrishnan, Energy-efficient communication protocol for wireless microsensor networks, in: Proceedings of Annual Hawaii International Conference on System Sciences(HICSS), 2000.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0050">
						<ce:label>[10]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>A.R.</ce:given-name>
										<ce:surname>Hevner</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.B.</ce:given-name>
										<ce:surname>Yao</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Query processing in distributed database systems</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>IEEE Trans. Software Eng.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>5</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>3</sb:issue-nr>
									<sb:date>1979</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>177</sb:first-page>
									<sb:last-page>187</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0055">
						<ce:label>[11]</ce:label>
						<ce:other-ref>
							<ce:textref>Y. Kotidis, Snapshot queries: towards data-centric sensor networks, in: Proceedings of ICDE, 2005, pp. 131–142.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0060">
						<ce:label>[12]</ce:label>
						<ce:other-ref>
							<ce:textref>S. Lindsey, C.S. Raghavendra, K.M. Sivalingam, Data gathering in sensor networks using the energy delay metric, in: Proceedings of IPDPS, 2001, p. 188.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0065">
						<ce:label>[13]</ce:label>
						<ce:other-ref>
							<ce:textref>S. Madden, M.J. Franklin, J.M. Hellerstein, W. Hong, Tag: a tiny aggregation service for ad-hoc sensor networks, in: Proceedings of OSDI, 2002.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0070">
						<ce:label>[14]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Madden</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.J.</ce:given-name>
										<ce:surname>Franklin</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.M.</ce:given-name>
										<ce:surname>Hellerstein</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>W.</ce:given-name>
										<ce:surname>Hong</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Tinydb: an acquisitional query processing system for sensor networks</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>ACM Trans. Database Syst.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>30</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>1</sb:issue-nr>
									<sb:date>2005</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>122</sb:first-page>
									<sb:last-page>173</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0075">
						<ce:label>[15]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>F.</ce:given-name>
										<ce:surname>Marcelloni</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.</ce:given-name>
										<ce:surname>Vecchio</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Enabling energy-efficient and lossy-aware data compression in wireless sensor networks by multi-objective evolutionary optimization</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>10</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1924</sb:first-page>
									<sb:last-page>1941</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0080">
						<ce:label>[16]</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>C.</ce:given-name>
										<ce:surname>Ok</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Lee</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>P.</ce:given-name>
										<ce:surname>Mitra</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>S.</ce:given-name>
										<ce:surname>Kumara</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Distributed routing in wireless sensor networks using energy welfare metric</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>Inform. Sci.</sb:maintitle>
										</sb:title>
										<sb:volume-nr>180</sb:volume-nr>
									</sb:series>
									<sb:issue-nr>9</sb:issue-nr>
									<sb:date>2010</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1656</sb:first-page>
									<sb:last-page>1670</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="b0085">
						<ce:label>[17]</ce:label>
						<ce:other-ref>
							<ce:textref>A. Pandit, H. Gupta, Communication-efficient implementation of range-joins in sensor networks, in: Proceedings of DASFAA, 2006, pp. 859–869.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0090">
						<ce:label>[18]</ce:label>
						<ce:other-ref>
							<ce:textref>A. Silberstein, R. Braynard, Y. Yang, Constraint chaining: on energy-efficient continuous monitoring in sensor networks, in: Proceedings of ACM SIGMOD, 2006, pp. 157–168.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0095">
						<ce:label>[19]</ce:label>
						<ce:other-ref>
							<ce:textref>U. Srivastava, K. Munagala, J. Widom, Operator placement for in-network stream query processing, in: Proceedings of ACM PODS, 2005, pp. 250–258.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0100">
						<ce:label>[20]</ce:label>
						<ce:other-ref>
							<ce:textref>M. Stern, Optimal locations for join processing in sensor networks, in: Proceedings of International Conference on Mobile Data Management (MDM), 2007, pp. 336–340.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0105">
						<ce:label>[21]</ce:label>
						<ce:other-ref>
							<ce:textref>M. Stern, E. Buchmann, K. Böhn, Towards efficient processing of general-purpose joins in sensor networks, in: Proceedings of ICDE, 2009.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0110">
						<ce:label>[22]</ce:label>
						<ce:other-ref>
							<ce:textref>X. Yang, H.B. Lim, M.T. Özsu, K.L. Tan, In-network execution of monitoring queries in sensor networks, in: Proceedings of ACM SIGMOD, 2007, pp. 521–532.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
					<ce:bib-reference id="b0115">
						<ce:label>[23]</ce:label>
						<ce:other-ref>
							<ce:textref>H. Yu, E.-P. Lim, and J. Zhang, On in-network synopsis join processing for sensor networks, in: Proceedings of the International Conference on Mobile Data Management, 2006, p. 32.</ce:textref>
						</ce:other-ref>
					</ce:bib-reference>
				</ce:bibliography-sec>
			</ce:bibliography>
		</ja:tail>
	</ja:article></doc:document>
