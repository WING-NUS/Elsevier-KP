<doc:document xmlns:doc="http://www.elsevier.com/xml/document/schema"><rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="http://dx.doi.org/10.1016/0020-0255(74)90010-3"><dc:format xmlns:dc="http://purl.org/dc/elements/1.1/">application/xml</dc:format><dc:title xmlns:dc="http://purl.org/dc/elements/1.1/">On self-modifying programs</dc:title><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/"><rdf:Seq><rdf:li>Raymond Reiter</rdf:li></rdf:Seq></dc:creator><dc:description xmlns:dc="http://purl.org/dc/elements/1.1/">Information Sciences 7 (1974) 157-169. doi:10.1016/0020-0255(74)90010-3</dc:description><prism:aggregationType xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">journal</prism:aggregationType><prism:publicationName xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Information Sciences</prism:publicationName><prism:copyright xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">Copyright © unknown. Published by Elsevier Inc.</prism:copyright><dc:publisher xmlns:dc="http://purl.org/dc/elements/1.1/">Elsevier Inc.</dc:publisher><prism:issn xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">0020-0255</prism:issn><prism:volume xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">7</prism:volume><prism:coverDisplayDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">1974</prism:coverDisplayDate><prism:coverDate xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">1974</prism:coverDate><prism:pageRange xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">157-169</prism:pageRange><prism:startingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">157</prism:startingPage><prism:endingPage xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">169</prism:endingPage><prism:doi xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">10.1016/0020-0255(74)90010-3</prism:doi><prism:url xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/">http://dx.doi.org/10.1016/0020-0255(74)90010-3</prism:url><dc:identifier xmlns:dc="http://purl.org/dc/elements/1.1/">doi:10.1016/0020-0255(74)90010-3</dc:identifier></rdf:Description></rdf:RDF><dp:document-properties xmlns:dp="http://www.elsevier.com/xml/common/doc-properties/schema"><dp:raw-text>INFORMATION SCIENCES 7, 157-169 (1974) 157

On Self-Modifying Programs

RAYMOND REITER

Department ofComputer Science, University of British Columbia,
Vancouver 8, B.C., Canada

Communicated by Azriel Rosenfeld and K. S. Fu

ABSTRACT

A model for self-modifying program schemata is presented. Essentially this augments
lanov program schemata with certain self-modifying primitives. An appropriate algorithm
for the decomposition of a directed graph is developed and applied to yield an lanov
schema equivalent to a given self-modifying schema. Generalizations of the model are
considered. In particular, certain growing programs are seen to lie outside the class of
lanov schemata.

INTRODUCTION

The usual models of algorithmic processes in the theory of computation
(e.g., Turing Machines, partial recursive functions, etc.) deal with fixed struc-
tures by means of which a computation is effected. Similarly, more realistic
models of programs (e.g., program schemata [3,5,7]) deal with fixed structure
flowcharts which characterize the flow of control in the execution of an
algorithm. However, all assembly languages, as well as certain high level
languages in interpretive mode (e.g., LISP), admit programs which dynamically
modify themselves. Curiously enough there has been very little research
reported on a theory of self-modifying programs. A very early reference to the
problem may be found in [2] where, in their description of a flowcharting
language, Goldstine and von Neumann introduce a flowchart primitive, called
a variable remote connection, which functions like the label variable of .PL/I.
In artificial intelligence circles there has been continual speculation over the
role of program self-modification in learning and in the attendant restructuring
of intelligent systems. In [10] ,Winograd describes a system for understanding
natural language which dynamically generates programs (in MICROPLANNER)
for subsequent execution. The work on automatic program writing by
Waldinger and Lee [9] and more recently, Manna and Waldinger [6], can also
be viewed in this light.

© American Eisevier Publishing Company, Inc., 1974

158                                                     RAYMOND REITER

Of course, no form of self-modification can enlarge the class of computable
functions. What does appear to be affected, in a fundamental way, is the nature
of the control of a computation. Intuitively one feels that suitable self-modifi-
cation primitives introduce control structures very different from the usual
program loops, branches, and recursion. Conceivably, this additional descrip-
tive power can lead to languages more suitable for describing large scale
intelligent systems.

One approach to the study of control structures in programming languages
is through the introduction of appropriate program schemata. In a schema, the
control is formalised, while the primitive computations and tests are left
uninterpreted. Examples of this approach are: [4] for parallel control, [8]
for recursive control, and [3, 5] for iterative control. Given such models, one
can then investigate the relative "powers" of different control mechanisms.
For example, it is known [8] that recursion is strictly more powerful than
iteration.

This paper presents a simple model of program self-modification, embedded
in the language of lanov program schemata [3,7]. We ask whether this
additional control structure yields a more powerful class of schemata than
those of lanov. Because our model is essentially finite state, the answer
turns out to be negative. However, by slightly generalizing the self-modification
primitives so as to permit programs to grow, we can easily obtain programs
lying outside the class of lanov schemata.

Section 1 presents an algorithm which, under appropriate conditions,
decomposes a node labelled directed graph in such a way that we can
associate a unique state with each node of the resulting graph. This
procedure is applied to the model for self-modifying schemata of Section
2 to prove lanov closure. Section 3 briefly discusses generalizations of the
model.

The reader is assumed to be familiar with the basic notions of lanov
schemata as described in, say [7].

1. FINITE STATE DECOMPOSITION OF GRAPHS

We consider finite directed graphs G such that

1. G has a distinguished initial node «o 

2. Every node of G is accessible from fly.

3. Each node of G is labelled. We denote the labelling of node n, by A,.

A walk is a sequence of node labellings W=\^,\, ,.. ., \^ such that, for
1 &lt;'&lt;/, "1.+, is an immediate successor of n,.. n, is the initial node of W,
and n^ its terminal node. W is a walk to n^ if n^ = «0  W will sometimes be
called a walk from n, when its terminal node is irrelevent to the discussion.

ON SELF-MODIFYING PROGRAMS                                     159

We assume that associated with G is a function o which maps the set of all
walks from «o into a finite set oî states, a must have the property

TT If Wi and W-i are walks to the same node m, if (m, n) is an edge ofG,
and if W is an arbitrary walk from n, then a{Wi}= a(W^) =&gt; a(Wi W)= a(W^W).

Let G and G' be node labelled directed graphs, with distinguished nodes
«o and no, respectively. G is'dhomomorphic image of G'if there exists a
function

h: Node set of G 'ont0, Node set of G
such that

1. h(no)=rio.

2. (n,',n/') is an edge of G' W {h(n',},h{nj)) is an edge ofG'.

3. n' and h(n') have the same label.

The function h is a homomorphism.

It is clear that for every walk W from «0 in G there is an equal walk from
no in G' and conversely. This remark is the basis for our applications of the
algorithm of this section to flowcharts, as in Section 2.

In this section, we show how to construct, given G and a function o satis-
fying property TT, a finite node labelled directed graph G' such that

1. GisahomomophicimageofG'.

2. For any pair of walks W[ and W{ to the same node n' of G', a(W\) =

oM.

THE ALGORITHM

Essentially, the algorithm does "node splitting" on G. A node is split
whenever two walks to it define different states. Property TT together with
the existence of finitely many states quarantees termination.

We construct a sequence Go, Gi,. . ., Gr, .. . , of directed graphs, each
of which contains copies of nodes of G. A copy in Gr of the node n of G
will be denoted by n'. There may be several copies of the same node n of
G, in which case they will all be ambiguously denoted by n'.

1. Let Go be the edge-free graph with single node no labelled \o- Thi8
node is the distinguished initial node ofG,., for each r'. Let r = 0.

2. Suppose, for all nodes m' ofG', that m' has as immediate successor,
a copyw' of a node« ofG iff(m,n) is an edge ofG. Then exit with G' = Gr-

3. If, in Gr, a node m' has no immediate successor n', while in G w has an
immediate successor n, then:

(a) Suppose Gr has one or more, say k, occurrences of a node n' such that,
in G, n is an immediate successor of m. Let Sî, îîi, . . . , Î2^ be arbitrary
walks, in Gr, to the node m' and the k nodes n', respectively (Fig. l(a)).
If there exists  such that a(SÎ\n) = o(^j), me" Gr+i is obtained by
adding the edge (m', n') shown dotted in Figure l(a).

160

RAYMOND REITER




Fig. Ka).

(b) Otherwise, Gr+i is obtained from Gr by adding a new node n' labelled

\fi, together with an edge from m to this new copy ofn.
4. Set r &lt;- r + 1 and go to 2.

LEMMA 1. Let p' be a given copy, in Gr, of a node p of G,and suppose Wi
and W-t are walks to p. Then a(Wi ) = 0(^2 ).

Proof. Induction on r. For r = 0 the result is immediate. Assume the result
for all nodes ofGr, and consider G'i.+i.

Case (a). Gr^i is obtained from Gr by 3(a). If all walks m G^+i to p' exist
also in Gr, the result follows by induction hypothesis. Otherwise, any walk
W to p' in G'f.+i which does not exist in Gr must "traverse" the new edge
(m', n'), in which case there must be a walk V^ from n' to p', which exists in
both Gr and G^.i. If Vi = An, \q,..., \p let V = \q,   , ^p  Now, by
construction, there also exists a walk Î2/ to n' which exists in both Gr and
Gr+i. Hence SÎ/V is a walk to p' m both Gr and Gr^.^. Then we can write

W = U\nWi\W^\ ...Wi\nV,

where U, Wi, W^,.. ., W( are (not necessarily distinct) walks in both Gr and
Gr+i (see Fig. l(b)). Each walk W^ has as initial node an immediate successor
ofn'. Now by the induction hypothesis, o(U) = o-(î2) (see Fig. l(a)). Hence,
by property n, o(W) = a(SÎ\Wi \n .. . W,\nV)- By construction, CT(î2À) =
u(î2/) so by property P, a(W) = a(SÎ,Wi An ... W,\ V). But ^,,Wi is a walk
in Gr, so by the induction hypothesis, a(SÎ/Wi) = a(Sî) whence, by property w,
a(W)=o(nÀn^Àn ... H/,XF),etc. Finally, we obtain a(W)= a(SÎ\^V)=
o(P,jV). But H'was an arbitrary walk top' m Gr+i which does not occur in
Gr, so by the induction hypothesis, all walks to p' define the same state.

ON SELF-MODIFYING PROGRAMS 161




Fig. l(b).

Case (b). G^+i is obtained from Gr by 3(b). Then, if p' is other than the
node n' added to obtain G'c+i, the lemma holds by induction hypothesis, since
no new walks top' have been created. Otherwise,?' is n'. But then any two
walks Wi and W^ to p' are of the form Wi = Ui \ and W^ = U^\, where î/i
and U-i are walks in Gr to m', so that o(t/i) = aCU^by the induction
hypothesis. By property TT, o(Wi )= o(W-i ).

LEMMA 2 (Termination). Suppose, in Gr, there exist two distinct copies
p' of a node p ofG. If W^ is a walk to the first copy and Wi a walk to the
second, then o(Wi) ^ o(H^).

Proof. Obvious. By Lemma 1, all walks to a given node p' of Gr+i define
the same state. By construction, if Gr+i is obtained from Gr by adding a new
copy p', then at least one walk to this new copy in Gr+i must define a different
state than that associated with any other copyp'.

Since there are only finitely many states possible, Lemma 2 guarantees
termination of the algorithm. Since, in G, all nodes are accessible from no,
the exit condition 2. of the algorithm assures us that the function h, defined
by h(n') = n for all nodes n of G, is a homomorphism.

THEOREM . The algorithm terminates with a graph G', such that G is a
homomorphic image ofG'. For any pair of walks Wi, W^ to the same node
n' ofG', we have a(Wi') = a(W^). In G', the number of copies n' of a node n
of G is at most \Range (o) l.

2. SELF-MODIFYING SCHEMATA

In this section, we present a simple model of program self-modification.
Essentially, the model augments lanov program schemata [3,7] with operators

162                                                RAYMOND REITER

which, upon execution, alter designated instructions of the schema. In addition,
we provide for label variables which permit dynamically changing GOTO's.

Using the results of the previous section, we prove that any such self-
modifying lanov schema is equivalent to an ordinary schema.

SYNTAX

Our model of a self-modifying programming language has the following
syntax:

(test variable): :=p\q\r...

(operator): :=A\B\C...

(fixed label): ^LO\Ll\L2...

(variable label): :=LVO\LV\\LV1. ..

dabei): :=(fixed label) | (variable label)

(operation): :=&lt;fixed labeDdo (operator), goto dabei)

(test): :=&lt;fixed label);/&lt;test variable) goto dabei) else goto dabei)

dabei modifier): :=&lt;variable label) «-(fixed label)

(operator modifier): :=&lt;fixed label)&lt;-(operator)| (fixed label)-&lt;-dabel modifier)!

(fixed label)-&lt;-(operator modifier)
(instruction modifier): :=&lt;fixed labeDcto dabei modifier), ^o?odabel)| (fixed

labeDdo (operator modifier), ^ofôdabel)
(instruction): :=(operation)| (test) | (instruction modifier)

A self-modifying program schema is any finite sequence of instructions, each
instruction of which is labelled by a unique fixed label.

If an (instruction) is an (operation) or (instruction modifier) we shall call
it a DO instruction, a is called the scope of the DO instruction (fixed label)
doot,goto dabei), p is also called the scope of the test instruction (fixed
label) if p goto dabei) else goto dabei). We shall often refer to an instruction
with, say, (fixed label) = L, as instruction L.

INTERPRETATION

As usual, the operators are uninterpreted. The test variables are unin-
terpreted Boolean variables. The role of the fixed labels is clear. Variable
labels are meant to bind fixed variables and are initially unbounded. An attempt
to execute goto dabei) is undefined if label is an unbound variable label, or
is bound to a fixed label with no associated instruction, of if it is a fixed label
with no associated instruction. Otherwise, control is transferred to that
instruction specified by dabei), if dabei) is fixed, or by its current binding, if
(label) is variable. With this condition in mind, if an instruction is an operation
or a test, it is interpreted as for lanov schemata. If an instruction / is an
instruction modifier there are two possibilities:

ON SELF-MODIFYING PROGRAMS                                     163

A. I is of the form
(fixed label) do Gabel modifier), goto Gabel).

Suppose Gabel modifier) is L V-^L. Then upon execution of /, L V is bound
to L. In addition, if Gabel) is L V, then the next instruction to be executed
isL.

B.  is of the form
(fixed label) do (operator modifier), goto Gabel).

Then (operator modifier) is L i-a, where L is a fixed label and a is an operator,
label modifier, or operator modifier, lï L has no associated instruction in the
program, or if L labels a test instruction, the result of executing / is undefined.
Otherwise, L labels an instruction of the form

L daß, goto Gabel),

where ß is an operator, label modifier, or operator modifier. After execution
of/, this instruction is replaced, in the program, by

L do a,goto Gabel)

and control is transferred to Gabel) of instruction /.

These informal remarks are now made precise.

We formally specifiy what it means to execute a self-modifying program
P by defining three sequences:

(a) an admissible label sequence L^ ,L^,..., L^ of fixed labels of P

(b) an execution sequence L^ ,L^,... ,L^_^

(c) a state sequence So,Si,. .. ,Sr-^. If P has m variable labels L V\,
LV1,... ,LVm, and n DO instructions labelled Ll,L2,... ,Ln then
each 5'; is an m + n component state (B^ ,B^,.. . , Bm, Ci, C-i,..., C).

These sequences must satisfy the following conditions:

1. L, labels the first instruction of P. So = (0,. . . , 0, Q'i,.   , a«) where.

for 1 &lt; ; &lt; r, a, is the scope of the DO instruction L,.
1. Suppose, for 1 &lt;&lt;/- 1, that instruction /-;. is

L,, do a, goto (label)
and5,-i = (ßi,. . . ,B^, Ci,... . C).

Case (;'). C,. is an operator, say C,. =A. Then Sj =.S'y-i andZ-; =A. If
(label) is fixed/then L,.^ = dabei). If (label) is variable, say (label) = L Vp, then
Bp ^ 0, and Z,,^ =Bp.

Case (ii). Q. is an instruction modifier, say C,. = Lk-^ß. Then Lk is a DO
instruction, S, L (Bi,..., Bm, Ci,.. ., Ck-i, ß, Ck^i,..., C), and 2^. =
Lk-^ß. Li.  is determined as in Case (i).

164                                                  RAYMOND REITER

Case (Ui). C,, is a label modifier, say Ci. = LVk-'-L. Then S, = (.81,. ..,
B-i,L,B^i,'..,B,n,Q,...,C^,3indL^=LVk^L. If dabei) is fixed,
Li.^ = dabei). If dabei) is variable, say (label) =LVp, then if p = A, L,   =L,
while ifp^k, then Bp^(f&gt; and Z,. = 5p.

3. Suppose, for l &lt;  &lt; r - l, that instruction Z,,. is
,,. if p goto dabeDi else goto dabei);

and «Sy-i = (5i,..., Bm, Ci,..., Cn). Then Sj = 5/-i and one of the
following two conditions holds.

(j) Z,,.  is determined from dabeDi as in 2. Case (;'), andZ;. =p.
(ii) L,,  is determined from dabei).; as in 2. Case (;'), and£,. =p.

An admissible label sequence specifies those instructions encountered in a
legitimate execution of the program, where by "legitimate" we mean that
branches on variable labels are taken according to their current bindings. A
state indicates these current bindings (as5i,.. . ,B^,), together with the
current scopes of the DO instructions (as Ci,.. ., Cn). 5, = &lt;f&gt; indicates that
L Vi is currently unbound. An execution sequence is simply a history of the
operators, test exits, and modifiers encountered in an execution of the
program.

Given an execution sequence L^,..., Z,,   , an operator-test sequence is
obtained by deleting any term Li. which is an operator modifier or label
modifier. This sequence yields a history of the "real computation", namely
those operators and test exits, in the order in which they are effected, during
an execution of the program.

Two self-modifying programs are strongly equivalent if they have the same
operator-test sequences. Notice that if two lanov schemata are equivalent ( [7] )
they need not be strongly equivalent. However, strong equivalence implies
equivalence, which is sufficient for our purposes.

Example 1.

LQdoLV&lt;-L\,gotoL3

L3 do A, goto L4

L4 if p goto L 2 else goto L V

L2doLl^-C,gotoL5

L l do L 3 &lt;-Z, V^LÎ, goto L 5

LSdo B,gotoL6

L6 ifq goto L3 else goto LI

LI do H, goto L~l.

Two admissible label sequences are:

LO,L3,L4,Ll,L5,L6,L3,L4,L2,L5,L6sind

ON SELF-MODIFYING PROGRAMS                                     165

LO,L3,L4,L2,L5,L6,L3,L4,L\,L5,L6 with corresponding operator-test
sequences A, p,B,q,p, B and

A,p,B,q,A,p,C.

REPRESENTATION AS A DIRECTED GRAPH

In order to utilize the results of Section 1, we represent a self-modifying
program as a directed graph and then define an appropriate notion of state
on this graph. We then decompose this graph according to the algorithm of
Section 1. Finally, the resulting graph is altered in a natural way to yield the
flowchart of an lanov schema strongly equivalent to the original program.

First, represent a program P by a directed graph G. G has a node, labelled
Li, for each instruction Li of P. For each occurrence of goto Lj in P, say
within instruction Li, G has an edge from Li to Lj. For each occurrence of a
variable label LV'mP, determine all of the possible bindings of LV. There can be
only finitely many such bindings, say Lï,..., Lk. For each occurrence of
goto L V in P, say within an instruction Li, G has edges from Li to each of
LI,... ,Lk. (An attempt to execute goto L V will be undefined ifLVis
currently unbound or if L V is bound to a fixed label with no associated
instruction. We could accommodate this possibility by introducing an
"undefined" node, joining to it the node Li. This approach introduces an
inessential complexity to the analysis, which we choose to avoid by considering
only well-formed programs for which L V is properly bound whenever goto L V
is to be executed. Clearly, there is a procedure for testing a given program for
wellformedness.) Finally, G has as distinguished initial node, that node LO
which labels the first instruction of P. With no loss in generality, assume that
all nodes of G are accessible from LO. Figure 2(a) is the graph G for the
program of Example 1.

For each walk W = L^,. . . ,L^ from Z,0 in G, define a state a(W) as follows:

1. If K' is an admissible label sequence, then it has associated with it a state
sequence Sy, Si,.. ., Sr-^. Define a(W) = Sr-\.

2. If W is inadmissible, define a(W) = ÎÎ.

It follows that there are only finitely many states, and a satisfies property
TT of Section 1.

Now apply to G the algorithm of Section 1 to obtain a graph G', such that
G is a homomorphic image of G'. In G', all walks to a given node define the
same state so that we can associate a state with each node. Figure 2(b) is the
graph G' for the program of Example 1. The dotted box S2 denotes a subgraph
all of whose nodes have state SÎ. States are indicated alongside nodes. If no
state is indicated beside a node, its state is assumed to be that of its predecessor.
For clarity, we have used an "abbreviated" state vector (Bi, C\, G-],) where Bi
denotes the binding of L V, and Ci,C-t denotes the scopes ofLl,L3,
respectively.

166

RAYMOND REITER







Fig. 2(a).

Now, remove all nodes of G' whose associated state is SÎ, together with
those edges directed to them yielding a graph G". By the construction ofG',
and the fact that G is a homomorphic image of G', every walk in G" from its
start node is an admissible label sequence OÎP, and conversely, every admissible
label sequence is such a walk in G". Now, replace each node label Li OÎG" by




Fig. 2(c).

ON SELF-MODIFYING PROGRAMS                                    167

the component C, of its state, if Li is a DO instruction, or by the scope of
instruction Li '\i Li is a test instruction. Furthermore, since in G" all walks to
a given node define the same state, we can safely delete all nodes labelled by
an instruction or label modifier. The resulting graph (after appropriately
adding T or F to the branches of a test) is the flowchart of an lanov schema.
This schema is strongly equivalent to the self-modifying program P. Figure 2(c)
is the lanov flowchart for the program of Example 1.

It follows that all of the problems (e.g., the halting, divergence, and equiva-
lence problems) which are decidable for lanov schemata remain decidable for
self-modifying schemata.

3. REMARKS

Our model of self-modification does not permit test instructions to be
modified, so that program flow of control is alterable only through label
modification. Also, in our model, the size of "core storage" remains fixedno
instruction "locations" are created or destroyed. There are a number of ways
in which the model could be generalized, without altering the basic result of
the previous section. For example, it is not difficult to see that if we allow any,
or all, of the following types of self-modification, we do not transcend the
class of lanov schemata

1. Replace any instruction (test, operation, or modifier) by any given
instruction.

2. Replace the instruction Li by the instruction Lj.

3. Create new instructions where these are specified in the program,
e.g., create "L3 do A,goto LV1."

4. Erase instructions.

5. Allow fixed labels to be replaced by other fixed labels or by variable
labels.

or any of a number of different variations on this theme. Essentially, our
model and any generalization of it as above models self-modifying programs
whose behavior can be simulated by setting and testing finite switches. For
example, the program of Example 1 can be simulated by the flowchart of
Fig. 2(d) which represents an lanov schema augmented by suitable facilities
for setting and testing switches. Using techniques very like those of Section 2,
one can prove that any such augmented lanov schema is equivalent to an
ordinary schema, which is the basis for our claim that generalizations like 1-5
above do not change the basic result of Section 2.

On the other hand, if we permit a program to grow in an unbounded fashion,
we can easily exceed the limits of lanov schemata. For example, suppose we
introduce three new instruction modifications.

168

RAYMOND REITER




Fig. 2(d).

1. copyLtoLV. If LV is currently bound to Li, then upon execution,
the body of the instruction labelled L replaces that labelled Li.

2. point L to L V. If L V is currently bound to Li, and if L labels do a,
goto dabei), then after execution, L labels do a,goto Li.

3. LV-^ gen. Upon execution, LV is bound to a new fixed label, distinct
from any which has thus far occurred.

Notice that (1) and (2) together with our language of Section 2 will yield
equivalent lanov schemata. However, (3) permits dynamic core allocation for
program space, and as the following example shows, takes us outside the class
of lanov schemata.

Example.

LO ifq goto L3 else goto L l

L\ do A, goto LI

Lido H, goto LI

L3 do L V &lt;- gen, goto L4

L4 copy LI to L V, goto L 5

L5 point LI to LV, goto LO.

If we interpret H as the halt operator and define the trace of a program to
be the set of operator-test sequences terminating with H, then the trace of this

ON SELF-MODIFYING PROGRAMS                                       169

program is {qn~lqA"H\n &gt; 1} which is not regular, and hence cannot be the
trace of any lanov schema.

The consideration of such growing programs leads to strong analogies with
theories of growing automata [1]. Questions involving minimal complete sets
of self-modification primitives, conditions for self reproduction, and the
synthesis of self-modifying programs seem to us worthy of future investigation.

This work was done under National Research Council of Canada grant
A 7642. The author wishes to thank Richard S. Bird for a number of revealing
conversations.

REFERENCES

1. E. F. Codai, Cellular Automata, Academic Press, New York (1968).

2. H.H. Goldstine and J. von Neumann, Planning and coding problems for an electronic
computing instrument, Part II, Vol. 1, in John van Neumann Collected Works, Vol. V,
Pergamon Press, New York (1963).

3. I. I. lanov, The logical schemes of algorithms, m Problems o f Cybernetics (1958),
pp. 75-125.

4. R. M. Karp and R. E. Miller, Parallel program schemata, J. Comput. System Sei.,
147-195 (1969).

5. D.C. Luckham, D. M. R. Park, and M. S. Paterson, On formalized computer programs,
J. Comput. System Sei., 220-249 (1970).

6. Z. Manna and R. J. Waldinger, Toward automatic program synthesis, C. ACM,
151-165 (1971).

7. J. D. Rutledge, On lanov's program schemata, J. ACM, 1-9 (1964).

8. H. R. Strong, Jr., Translating recursion equations into flow charts, J. Comput. System
Sei., 254-285 (1971).

9. R. J. Waldinger and R. C. T. Lee, PROW: A step toward automatic program writing,

Proc. Intern. Joint Conf. Artificial Intelligence, Washington, D.C., 1969.
10. T. Winograd, Procedures as a representation for data in a computer program for
understanding natural language, M.I.T. Project MAC TR-84, February, 1971.

Received February 12, 1973</dp:raw-text><dp:aggregation-type>Journals</dp:aggregation-type><dp:version-number>S350.1</dp:version-number></dp:document-properties><cja:converted-article version="4.5.2" docsubtype="fla" xml:lang="en" xmlns:cja="http://www.elsevier.com/xml/cja/schema">
		<cja:item-info>
			<cja:jid>INS</cja:jid>
			<cja:aid>74900103</cja:aid>
			<ce:pii xmlns:ce="http://www.elsevier.com/xml/common/schema">0020-0255(74)90010-3</ce:pii>
			<ce:doi xmlns:ce="http://www.elsevier.com/xml/common/schema">10.1016/0020-0255(74)90010-3</ce:doi>
			<ce:copyright type="unknown" year="1974" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
		</cja:item-info>
		<cja:head>
			<ce:title xmlns:ce="http://www.elsevier.com/xml/common/schema">On self-modifying programs</ce:title>
			<ce:author-group xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:author>
					<ce:given-name>Raymond</ce:given-name>
					<ce:surname>Reiter</ce:surname>
				</ce:author>
				<ce:affiliation>
					<ce:textfn>Department of Computer Science, University of British Columbia, Vancouver 8, B.C., Canada</ce:textfn>
				</ce:affiliation>
			</ce:author-group>
			<ce:date-received day="12" month="2" year="1973" xmlns:ce="http://www.elsevier.com/xml/common/schema"/>
			<ce:miscellaneous xmlns:ce="http://www.elsevier.com/xml/common/schema">Communicated by Azriel Rosenfeld and K. S. Fu</ce:miscellaneous>
			<ce:abstract class="author" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>Abstract</ce:section-title>
				<ce:abstract-sec>
					<ce:simple-para view="all">A model for self-modifying program schemata is presented. Essentially this augments Ianov program schemata with certain self-modifying primitives. An appropriate algorithm for the decomposition of a directed graph is developed and applied to yield an Ianov schema equivalent to a given self-modifying schema. Generalizations of the model are considered. In particular, certain growing programs are seen to lie outside the class of Ianov schemata.</ce:simple-para>
				</ce:abstract-sec>
			</ce:abstract>
		</cja:head>
		<cja:tail>
			<ce:bibliography view="all" xmlns:ce="http://www.elsevier.com/xml/common/schema">
				<ce:section-title>References</ce:section-title>
				<ce:bibliography-sec>
					<ce:bib-reference id="BIB1">
						<ce:label>1.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>E.F.</ce:given-name>
										<ce:surname>Codd</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Cellular Automata</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:book>
									<sb:date>1968</sb:date>
									<sb:publisher>
										<sb:name>Academic Press</sb:name>
										<sb:location>New York</sb:location>
									</sb:publisher>
								</sb:book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB2">
						<ce:label>2.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.H.</ce:given-name>
										<ce:surname>Goldstine</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>J.</ce:given-name>
										<ce:surname>von Neumann</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Planning and coding problems for an electronic computing instrument</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:comment>Part II</sb:comment>
							<sb:host>
								<sb:edited-book>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>John von Neumann Collected Works</sb:maintitle>
											</sb:title>
											<sb:volume-nr>Vol. 1</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>1963</sb:date>
									<sb:publisher>
										<sb:name>Pergamon Press</sb:name>
										<sb:location>New York</sb:location>
									</sb:publisher>
								</sb:edited-book>
							</sb:host>
							<sb:host>
								<sb:edited-book>
									<sb:book-series>
										<sb:series>
											<sb:title>
												<sb:maintitle>John von Neumann Collected Works</sb:maintitle>
											</sb:title>
											<sb:volume-nr>Vol. V</sb:volume-nr>
										</sb:series>
									</sb:book-series>
									<sb:date>1963</sb:date>
									<sb:publisher>
										<sb:name>Pergamon Press</sb:name>
										<sb:location>New York</sb:location>
									</sb:publisher>
								</sb:edited-book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB3">
						<ce:label>3.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>I.I.</ce:given-name>
										<ce:surname>Ianov</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>The logical schemes of algorithms</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Problems of Cybernetics</sb:maintitle>
									</sb:title>
									<sb:date>1958</sb:date>
								</sb:edited-book>
								<sb:pages>
									<sb:first-page>75</sb:first-page>
									<sb:last-page>125</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB4">
						<ce:label>4.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.M.</ce:given-name>
										<ce:surname>Karp</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.E.</ce:given-name>
										<ce:surname>Miller</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Parallel program schemata</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Comput. System Sci.</sb:maintitle>
										</sb:title>
									</sb:series>
									<sb:date>1969</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>147</sb:first-page>
									<sb:last-page>195</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB5">
						<ce:label>5.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>D.C.</ce:given-name>
										<ce:surname>Luckham</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>D.M.R.</ce:given-name>
										<ce:surname>Park</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>M.S.</ce:given-name>
										<ce:surname>Paterson</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>On formalized computer programs</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Comput. System Sci.</sb:maintitle>
										</sb:title>
									</sb:series>
									<sb:date>1970</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>220</sb:first-page>
									<sb:last-page>249</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB6">
						<ce:label>6.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>Z.</ce:given-name>
										<ce:surname>Manna</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.J.</ce:given-name>
										<ce:surname>Waldinger</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Toward automatic program synthesis</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>C. ACM</sb:maintitle>
										</sb:title>
									</sb:series>
									<sb:date>1971</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>151</sb:first-page>
									<sb:last-page>165</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB7">
						<ce:label>7.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>J.D.</ce:given-name>
										<ce:surname>Rutledge</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>On Ianov's program schemata</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. ACM</sb:maintitle>
										</sb:title>
									</sb:series>
									<sb:date>1964</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>1</sb:first-page>
									<sb:last-page>9</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB8">
						<ce:label>8.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>H.R.</ce:given-name>
										<ce:surname>Strong</ce:surname>
										<ce:suffix>Jr.</ce:suffix>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Translating recursion equations into flow charts</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>J. Comput. System Sci.</sb:maintitle>
										</sb:title>
									</sb:series>
									<sb:date>1971</sb:date>
								</sb:issue>
								<sb:pages>
									<sb:first-page>254</sb:first-page>
									<sb:last-page>285</sb:last-page>
								</sb:pages>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB9">
						<ce:label>9.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>R.J.</ce:given-name>
										<ce:surname>Waldinger</ce:surname>
									</sb:author>
									<sb:author>
										<ce:given-name>R.C.T.</ce:given-name>
										<ce:surname>Lee</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>PROW: A step toward automatic program writing</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:edited-book>
									<sb:title>
										<sb:maintitle>Proc. Intern. Joint Conf. Artificial Intelligence</sb:maintitle>
									</sb:title>
									<sb:conference>Washington, D.C.</sb:conference>
									<sb:date>1969</sb:date>
								</sb:edited-book>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
					<ce:bib-reference id="BIB10">
						<ce:label>10.</ce:label>
						<sb:reference xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/schema">
							<sb:contribution langtype="en">
								<sb:authors>
									<sb:author>
										<ce:given-name>T.</ce:given-name>
										<ce:surname>Winograd</ce:surname>
									</sb:author>
								</sb:authors>
								<sb:title>
									<sb:maintitle>Procedures as a representation for data in a computer program for understanding natural language</sb:maintitle>
								</sb:title>
							</sb:contribution>
							<sb:host>
								<sb:issue>
									<sb:series>
										<sb:title>
											<sb:maintitle>M.I.T. Project MAC TR-84</sb:maintitle>
										</sb:title>
									</sb:series>
									<sb:date>February, 1971</sb:date>
								</sb:issue>
							</sb:host>
						</sb:reference>
					</ce:bib-reference>
				</ce:bibliography-sec>
			</ce:bibliography>
		</cja:tail>
	</cja:converted-article></doc:document>
